{"version":3,"file":"single-selection-controller.js","sourceRoot":"","sources":["single-selection-controller.ts"],"names":[],"mappings":"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","sourcesContent":["/**\n * @license\n *  Copyright 2020 Google Inc. All Rights Reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n *\n *     Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n/**\n * Unique symbol for marking roots\n */\nconst selectionController = Symbol('selection controller');\n\n/**\n * Set of checkable elements with added metadata\n */\nexport class SingleSelectionSet {\n  selected: CheckableElement|null = null;\n  ordered: CheckableElement[]|null = null;\n  readonly set = new Set<CheckableElement>();\n}\n\n/**\n * Element that is checkable consumed by\n * `SingleSelectionController` and `SingleSelectionSet`\n */\nexport type CheckableElement = HTMLElement&{\n  name: string;\n  checked: boolean;\n  formElementTabIndex?: number;\n};\n\n/**\n * Controller that provides behavior similar to a native `<input type=\"radio\">`\n * group.\n *\n * Behaviors:\n *\n * - Selection via key navigation (currently LTR is supported)\n * - Deselection of other grouped, checkable controls upon selection\n * - Grouping of checkable elements by name\n *   - Defaults grouping scope to host shadow root\n *   - Document-wide scoping enabled\n * - Land focus only on checked element. Focuses leading element when none\n *   checked.\n *\n * Intended Usage:\n *\n * ```ts\n * class MyElement extends HTMLElement {\n *   private selectionController: SingleSelectionController | null = null;\n *   name = \"\";\n *   global = false;\n *\n *   private _checked = false;\n *   set checked(checked: boolean) {\n *     const oldVal = this._checked;\n *     if (checked === oldVal) return;\n *\n *     this._checked = checked;\n *\n *     if (this.selectionController) {\n *       this.selectionController.update(this)\n *     }\n *   }\n *\n *   get checked() {\n *     return this._checked;\n *   }\n *\n *   connectedCallback() {\n *     this.selectionController = SelectionController.getController(this);\n *     this.selectionController.register(this);\n *     this.selectionController.update(this);\n *   }\n *\n *   disconnectedCallback() {\n *     this.selectionController!.unregister(this);\n *     this.selectionController = null;\n *   }\n * }\n * ```\n */\nexport class SingleSelectionController {\n  private readonly sets: {[name: string]: SingleSelectionSet} = {};\n\n  private focusedSet: SingleSelectionSet|null = null;\n\n  private mouseIsDown = false;\n\n  private updating = false;\n\n  /**\n   * Get a controller for the given element. If no controller exists, one will\n   * be created. Defaults to getting the controller scoped to the element's root\n   * node shadow root unless `element.global` is true. Then, it will get a\n   * `window.document`-scoped controller.\n   *\n   * @param element Element from which to get / create a SelectionController. If\n   *     `element.global` is true, it gets a selection controller scoped to\n   *     `window.document`.\n   */\n  static getController(element: HTMLElement|HTMLElement&{global: boolean}) {\n    const useGlobal =\n        !('global' in element) || ('global' in element && element.global);\n    const root = useGlobal ? document as Document &\n            {[selectionController]?: SingleSelectionController} :\n                             element.getRootNode() as Node &\n            {[selectionController]?: SingleSelectionController};\n    let controller = root[selectionController];\n    if (controller === undefined) {\n      controller = new SingleSelectionController(root);\n      root[selectionController] = controller;\n    }\n    return controller;\n  }\n\n  constructor(element: Node) {\n    element.addEventListener('keydown', (e: Event) => {\n      this.keyDownHandler(e as KeyboardEvent);\n    });\n    element.addEventListener('mousedown', () => {\n      this.mousedownHandler();\n    });\n    element.addEventListener('mouseup', () => {\n      this.mouseupHandler();\n    });\n  }\n\n  protected keyDownHandler(e: KeyboardEvent) {\n    const element = e.target as EventTarget | CheckableElement;\n    if (!('checked' in element)) {\n      return;\n    }\n    if (!this.has(element)) {\n      return;\n    }\n    if (e.key == 'ArrowRight' || e.key == 'ArrowDown') {\n      this.selectNext(element);\n    } else if (e.key == 'ArrowLeft' || e.key == 'ArrowUp') {\n      this.selectPrevious(element);\n    }\n  }\n\n  protected mousedownHandler() {\n    this.mouseIsDown = true;\n  }\n\n  protected mouseupHandler() {\n    this.mouseIsDown = false;\n  }\n\n  /**\n   * Whether or not the controller controls  the given element.\n   *\n   * @param element element to check\n   */\n  has(element: CheckableElement) {\n    const set = this.getSet(element.name);\n    return set.set.has(element);\n  }\n\n  /**\n   * Selects and returns the controlled element previous to the given element in\n   * document position order. See\n   * [Node.compareDocumentPosition](https://developer.mozilla.org/en-US/docs/Web/API/Node/compareDocumentPosition).\n   *\n   * @param element element relative from which preceding element is fetched\n   */\n  selectPrevious(element: CheckableElement) {\n    const order = this.getOrdered(element);\n    const i = order.indexOf(element);\n    const previous = order[i - 1] || order[order.length - 1];\n    this.select(previous);\n\n    return previous;\n  }\n\n  /**\n   * Selects and returns the controlled element next to the given element in\n   * document position order. See\n   * [Node.compareDocumentPosition](https://developer.mozilla.org/en-US/docs/Web/API/Node/compareDocumentPosition).\n   *\n   * @param element element relative from which following element is fetched\n   */\n  selectNext(element: CheckableElement) {\n    const order = this.getOrdered(element);\n    const i = order.indexOf(element);\n    const next = order[i + 1] || order[0];\n    this.select(next);\n\n    return next;\n  }\n\n  select(element: CheckableElement) {\n    element.click();\n  }\n\n  /**\n   * Focuses the selected element in the given element's selection set. User's\n   * mouse selection will override this focus.\n   *\n   * @param element Element from which selection set is derived and subsequently\n   *     focused.\n   * @deprecated update() method now handles focus management by setting\n   *     appropriate tabindex to form element.\n   */\n  focus(element: CheckableElement) {\n    // Only manage focus state when using keyboard\n    if (this.mouseIsDown) {\n      return;\n    }\n    const set = this.getSet(element.name);\n    const currentFocusedSet = this.focusedSet;\n    this.focusedSet = set;\n    if (currentFocusedSet != set && set.selected && set.selected != element) {\n      set.selected.focus();\n    }\n  }\n\n  /**\n   * @return Returns true if atleast one radio is selected in the radio group.\n   */\n  isAnySelected(element: CheckableElement): boolean {\n    const set = this.getSet(element.name);\n\n    for (const e of set.set) {\n      if (e.checked) {\n        return true;\n      }\n    }\n\n    return false;\n  }\n\n  /**\n   * Returns the elements in the given element's selection set in document\n   * position order.\n   * [Node.compareDocumentPosition](https://developer.mozilla.org/en-US/docs/Web/API/Node/compareDocumentPosition).\n   *\n   * @param element Element from which selection set is derived and subsequently\n   *     ordered.\n   */\n  getOrdered(element: CheckableElement) {\n    const set = this.getSet(element.name);\n    if (!set.ordered) {\n      set.ordered = Array.from(set.set);\n      set.ordered.sort(\n          (a, b) =>\n              a.compareDocumentPosition(b) == Node.DOCUMENT_POSITION_PRECEDING ?\n              1 :\n              0);\n    }\n    return set.ordered;\n  }\n\n  /**\n   * Gets the selection set of the given name and creates one if it does not yet\n   * exist.\n   *\n   * @param name Name of set\n   */\n  getSet(name: string): SingleSelectionSet {\n    if (!this.sets[name]) {\n      this.sets[name] = new SingleSelectionSet();\n    }\n    return this.sets[name];\n  }\n\n  /**\n   * Register the element in the selection controller.\n   *\n   * @param element Element to register. Registers in set of `element.name`.\n   */\n  register(element: CheckableElement) {\n    // TODO(b/168546148): Remove accessing 'name' via getAttribute() when new\n    // base class is created without single selection controller. Component\n    // maybe booted up after it is connected to DOM in which case properties\n    // (including `name`) are not updated yet.\n    const name = element.name || element.getAttribute('name') || '';\n    const set = this.getSet(name);\n    set.set.add(element);\n    set.ordered = null;\n  }\n\n  /**\n   * Unregister the element from selection controller.\n   *\n   * @param element Element to register. Registers in set of `element.name`.\n   */\n  unregister(element: CheckableElement) {\n    const set = this.getSet(element.name);\n    set.set.delete(element);\n    set.ordered = null;\n    if (set.selected == element) {\n      set.selected = null;\n    }\n  }\n\n  /**\n   * Unselects other elements in element's set if element is checked. Noop\n   * otherwise.\n   *\n   * @param element Element from which to calculate selection controller update.\n   */\n  update(element: CheckableElement) {\n    if (this.updating) {\n      return;\n    }\n    this.updating = true;\n    const set = this.getSet(element.name);\n    if (element.checked) {\n      for (const e of set.set) {\n        if (e == element) {\n          continue;\n        }\n        e.checked = false;\n      }\n      set.selected = element;\n    }\n\n    // When tabbing through land focus on the checked radio in the group.\n    if (this.isAnySelected(element)) {\n      for (const e of set.set) {\n        if (e.formElementTabIndex === undefined) {\n          break;\n        }\n\n        e.formElementTabIndex = e.checked ? 0 : -1;\n      }\n    }\n    this.updating = false;\n  }\n}\n"]}