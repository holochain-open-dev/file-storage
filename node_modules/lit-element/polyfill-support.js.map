{"version":3,"file":"polyfill-support.js","sources":["../reactive-element/src/polyfill-support.ts","../lit-html/src/polyfill-support.ts","src/polyfill-support.ts"],"sourcesContent":["/**\n * @license\n * Copyright 2017 Google LLC\n * SPDX-License-Identifier: BSD-3-Clause\n */\n\n/**\n * ReactiveElement patch to support browsers without native web components.\n *\n * This module should be used in addition to loading the web components\n * polyfills via @webcomponents/webcomponentjs. When using those polyfills\n * support for polyfilled Shadow DOM is automatic via the ShadyDOM polyfill, but\n * support for Shadow DOM like css scoping is opt-in. This module uses ShadyCSS\n * to scope styles defined via the `static styles` property.\n *\n * @packageDocumentation\n */\n\ninterface RenderOptions {\n  readonly renderBefore?: ChildNode | null;\n  scope?: string;\n}\n\nconst SCOPED = '__scoped';\n\ntype CSSResults = Array<{cssText: string} | CSSStyleSheet>;\n\ninterface PatchableReactiveElementConstructor {\n  [SCOPED]: boolean;\n  elementStyles: CSSResults;\n  shadowRootOptions: ShadowRootInit;\n  _$handlesPrepareStyles?: boolean;\n}\n\ninterface PatchableReactiveElement extends HTMLElement {\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any, @typescript-eslint/no-misused-new\n  new (...args: any[]): PatchableReactiveElement;\n  constructor: PatchableReactiveElementConstructor;\n  connectedCallback(): void;\n  hasUpdated: boolean;\n  _$didUpdate(changedProperties: unknown): void;\n  createRenderRoot(): Element | ShadowRoot;\n  renderOptions: RenderOptions;\n}\n\n// eslint-disable-next-line @typescript-eslint/no-explicit-any\n(globalThis as any)['reactiveElementPlatformSupport'] ??= ({\n  ReactiveElement,\n}: {\n  ReactiveElement: PatchableReactiveElement;\n}) => {\n  // polyfill-support is only needed if ShadyCSS or the ApplyShim is in use\n  // We test at the point of patching, which makes it safe to load\n  // webcomponentsjs and polyfill-support in either order\n  if (\n    window.ShadyCSS === undefined ||\n    (window.ShadyCSS.nativeShadow && !window.ShadyCSS.ApplyShim)\n  ) {\n    return;\n  }\n\n  // console.log(\n  //   '%c Making ReactiveElement compatible with ShadyDOM/CSS.',\n  //   'color: lightgreen; font-style: italic'\n  // );\n\n  const elementProto = ReactiveElement.prototype;\n\n  // In noPatch mode, patch the ReactiveElement prototype so that no\n  // ReactiveElements must be wrapped.\n  if (\n    window.ShadyDOM &&\n    window.ShadyDOM.inUse &&\n    window.ShadyDOM.noPatch === true\n  ) {\n    window.ShadyDOM.patchElementProto(elementProto);\n  }\n\n  /**\n   * Patch to apply adoptedStyleSheets via ShadyCSS\n   */\n  const createRenderRoot = elementProto.createRenderRoot;\n  elementProto.createRenderRoot = function (this: PatchableReactiveElement) {\n    // Pass the scope to render options so that it gets to lit-html for proper\n    // scoping via ShadyCSS.\n    const name = this.localName;\n    // If using native Shadow DOM must adoptStyles normally,\n    // otherwise do nothing.\n    if (window.ShadyCSS!.nativeShadow) {\n      return createRenderRoot.call(this);\n    } else {\n      if (!this.constructor.hasOwnProperty(SCOPED)) {\n        (this.constructor as PatchableReactiveElementConstructor)[\n          SCOPED\n        ] = true;\n        // Use ShadyCSS's `prepareAdoptedCssText` to shim adoptedStyleSheets.\n        const css = (this\n          .constructor as PatchableReactiveElementConstructor).elementStyles.map(\n          (v) =>\n            v instanceof CSSStyleSheet\n              ? Array.from(v.cssRules).reduce(\n                  (a: string, r: CSSRule) => (a += r.cssText),\n                  ''\n                )\n              : v.cssText\n        );\n        window.ShadyCSS?.ScopingShim?.prepareAdoptedCssText(css, name);\n        if (this.constructor._$handlesPrepareStyles === undefined) {\n          window.ShadyCSS!.prepareTemplateStyles(\n            document.createElement('template'),\n            name\n          );\n        }\n      }\n      return (\n        this.shadowRoot ??\n        this.attachShadow(\n          (this.constructor as PatchableReactiveElementConstructor)\n            .shadowRootOptions\n        )\n      );\n    }\n  };\n\n  /**\n   * Patch connectedCallback to apply ShadyCSS custom properties shimming.\n   */\n  const connectedCallback = elementProto.connectedCallback;\n  elementProto.connectedCallback = function (this: PatchableReactiveElement) {\n    connectedCallback.call(this);\n    // Note, must do first update separately so that we're ensured\n    // that rendering has completed before calling this.\n    if (this.hasUpdated) {\n      window.ShadyCSS!.styleElement(this);\n    }\n  };\n\n  /**\n   * Patch update to apply ShadyCSS custom properties shimming for first\n   * update.\n   */\n  const didUpdate = elementProto._$didUpdate;\n  elementProto._$didUpdate = function (\n    this: PatchableReactiveElement,\n    changedProperties: unknown\n  ) {\n    const isFirstUpdate = !this.hasUpdated;\n    didUpdate.call(this, changedProperties);\n    // Note, must do first update here so rendering has completed before\n    // calling this and styles are correct by updated/firstUpdated.\n    if (isFirstUpdate) {\n      window.ShadyCSS!.styleElement(this);\n    }\n  };\n};\n","/**\n * @license\n * Copyright 2017 Google LLC\n * SPDX-License-Identifier: BSD-3-Clause\n */\n\n/**\n * lit-html patch to support browsers without native web components.\n *\n * This module should be used in addition to loading the web components\n * polyfills via @webcomponents/webcomponentjs. When using those polyfills\n * support for polyfilled Shadow DOM is automatic via the ShadyDOM polyfill.\n * Scoping classes are added to DOM nodes to facilitate CSS scoping that\n * simulates the style scoping Shadow DOM provides. ShadyDOM does this scoping\n * to all elements added to the DOM. This module provides an important\n * optimization for this process by pre-scoping lit-html template\n * DOM. This means ShadyDOM does not have to scope each instance of the\n * template DOM. Instead, each template is scoped only once.\n *\n * Creating scoped CSS is not covered by this module. It is, however, integrated\n * into the lit-element and @lit/reactive-element packages. See the ShadyCSS docs\n * for how to apply scoping to CSS:\n * https://github.com/webcomponents/polyfills/tree/master/packages/shadycss#usage.\n *\n * @packageDocumentation\n */\n\ninterface RenderOptions {\n  readonly renderBefore?: ChildNode | null;\n  scope?: string;\n}\n\ninterface ShadyTemplateResult {\n  strings: TemplateStringsArray;\n  _$litType$?: string;\n}\n\n// Note, this is a dummy type as the full type here is big.\ninterface Directive {\n  __directive?: Directive;\n}\n\ninterface DirectiveParent {\n  _$parent?: DirectiveParent;\n  __directive?: Directive;\n  __directives?: Array<Directive | undefined>;\n}\n\ninterface PatchableChildPartConstructor {\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any, @typescript-eslint/no-misused-new\n  new (...args: any[]): PatchableChildPart;\n}\n\ninterface PatchableChildPart {\n  __directive?: Directive;\n  _$committedValue: unknown;\n  _$startNode: ChildNode;\n  _$endNode: ChildNode | null;\n  options: RenderOptions;\n  _$setValue(value: unknown, directiveParent: DirectiveParent): void;\n  _$getTemplate(result: ShadyTemplateResult): HTMLTemplateElement;\n}\n\ninterface PatchableTemplate {\n  el: HTMLTemplateElement;\n}\n\ninterface PatchableTemplateConstructor {\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any, @typescript-eslint/no-misused-new\n  new (...args: any[]): PatchableTemplate;\n  createElement(html: string, options?: RenderOptions): HTMLTemplateElement;\n}\n\ninterface PatchableTemplateInstance {\n  _$template: PatchableTemplate;\n}\n\n// Scopes that have had styling prepared. Note, must only be done once per\n// scope.\nconst styledScopes: Set<string> = new Set();\n// Map of css per scope. This is collected during first scope render, used when\n// styling is prepared, and then discarded.\nconst scopeCssStore: Map<string, string[]> = new Map();\n\nconst ENABLE_SHADYDOM_NOPATCH = true;\n\n/**\n * lit-html patches. These properties cannot be renamed.\n * * ChildPart.prototype._$getTemplate\n * * ChildPart.prototype._$setValue\n */\n// eslint-disable-next-line @typescript-eslint/no-explicit-any\n(globalThis as any)['litHtmlPlatformSupport'] ??= (\n  Template: PatchableTemplateConstructor,\n  ChildPart: PatchableChildPartConstructor\n) => {\n  // polyfill-support is only needed if ShadyCSS or the ApplyShim is in use\n  // We test at the point of patching, which makes it safe to load\n  // webcomponentsjs and polyfill-support in either order\n  if (\n    window.ShadyCSS === undefined ||\n    (window.ShadyCSS.nativeShadow && !window.ShadyCSS.ApplyShim)\n  ) {\n    return;\n  }\n\n  // console.log(\n  //   '%c Making lit-html compatible with ShadyDOM/CSS.',\n  //   'color: lightgreen; font-style: italic'\n  // );\n\n  const wrap =\n    ENABLE_SHADYDOM_NOPATCH &&\n    window.ShadyDOM?.inUse &&\n    window.ShadyDOM?.noPatch === true\n      ? window.ShadyDOM!.wrap\n      : (node: Node) => node;\n\n  const needsPrepareStyles = (name: string | undefined) =>\n    name !== undefined && !styledScopes.has(name);\n\n  const cssForScope = (name: string) => {\n    let scopeCss = scopeCssStore.get(name);\n    if (scopeCss === undefined) {\n      scopeCssStore.set(name, (scopeCss = []));\n    }\n    return scopeCss;\n  };\n\n  const prepareStyles = (name: string, template: HTMLTemplateElement) => {\n    // Get styles\n    const scopeCss = cssForScope(name);\n    const hasScopeCss = scopeCss.length !== 0;\n    if (hasScopeCss) {\n      const style = document.createElement('style');\n      style.textContent = scopeCss.join('\\n');\n      // Note, it's important to add the style to the *end* of the template so\n      // it doesn't mess up part indices.\n      template.content.appendChild(style);\n    }\n    // Mark this scope as styled.\n    styledScopes.add(name);\n    // Remove stored data since it's no longer needed.\n    scopeCssStore.delete(name);\n    // ShadyCSS removes scopes and removes the style under ShadyDOM and leaves\n    // it under native Shadow DOM\n    window.ShadyCSS!.prepareTemplateStyles(template, name);\n    // Note, under native Shadow DOM, the style is added to the beginning of the\n    // template. It must be moved to the *end* of the template so it doesn't\n    // mess up part indices.\n    if (hasScopeCss && window.ShadyCSS!.nativeShadow) {\n      template.content.appendChild(template.content.querySelector('style')!);\n    }\n  };\n\n  const scopedTemplateCache = new Map<\n    string | undefined,\n    Map<TemplateStringsArray, PatchableTemplate>\n  >();\n\n  /**\n   * Override to extract style elements from the template\n   * and store all style.textContent in the shady scope data.\n   * Note, it's ok to patch Template since it's only used via ChildPart.\n   */\n  const originalCreateElement = Template.createElement;\n  Template.createElement = function (html: string, options?: RenderOptions) {\n    const element = originalCreateElement.call(Template, html, options);\n    const scope = options?.scope;\n    if (scope !== undefined) {\n      if (!window.ShadyCSS!.nativeShadow) {\n        window.ShadyCSS!.prepareTemplateDom(element, scope);\n      }\n      const scopeCss = cssForScope(scope);\n      // Remove styles and store textContent.\n      const styles = element.content.querySelectorAll(\n        'style'\n      ) as NodeListOf<HTMLStyleElement>;\n      // Store the css in this template in the scope css and remove the <style>\n      // from the template _before_ the node-walk captures part indices\n      scopeCss.push(\n        ...Array.from(styles).map((style) => {\n          style.parentNode?.removeChild(style);\n          return style.textContent!;\n        })\n      );\n    }\n    return element;\n  };\n\n  const renderContainer = document.createDocumentFragment();\n  const renderContainerMarker = document.createComment('');\n\n  const childPartProto = ChildPart.prototype;\n  /**\n   * Patch to apply gathered css via ShadyCSS. This is done only once per scope.\n   */\n  const setValue = childPartProto._$setValue;\n  childPartProto._$setValue = function (\n    this: PatchableChildPart,\n    value: unknown,\n    directiveParent: DirectiveParent = this\n  ) {\n    const container = wrap(this._$startNode).parentNode!;\n    const scope = this.options?.scope;\n    if (container instanceof ShadowRoot && needsPrepareStyles(scope)) {\n      // Note, @apply requires outer => inner scope rendering on initial\n      // scope renders to apply property values correctly. Style preparation\n      // is tied to rendering into `shadowRoot`'s and this is typically done by\n      // custom elements. If this is done in `connectedCallback`, as is typical,\n      // the code below ensures the right order since content is rendered\n      // into a fragment first so the hosting element can prepare styles first.\n      // If rendering is done in the constructor, this won't work, but that's\n      // not supported in ShadyDOM anyway.\n      const startNode = this._$startNode;\n      const endNode = this._$endNode;\n\n      // Temporarily move this part into the renderContainer.\n      renderContainer.appendChild(renderContainerMarker);\n      this._$startNode = renderContainerMarker;\n      this._$endNode = null;\n\n      // Note, any nested template results render here and their styles will\n      // be extracted and collected.\n      setValue.call(this, value, directiveParent);\n\n      // Get the template for this result or create a dummy one if a result\n      // is not being rendered.\n      const template = (value as ShadyTemplateResult)?._$litType$\n        ? (this._$committedValue as PatchableTemplateInstance)._$template.el\n        : document.createElement('template');\n      prepareStyles(scope!, template);\n\n      // Note, this is the temporary startNode.\n      renderContainer.removeChild(renderContainerMarker);\n      // When using native Shadow DOM, include prepared style in shadowRoot.\n      if (window.ShadyCSS?.nativeShadow) {\n        const style = template.content.querySelector('style');\n        if (style !== null) {\n          renderContainer.appendChild(style.cloneNode(true));\n        }\n      }\n      container.insertBefore(renderContainer, endNode);\n      // Move part back to original container.\n      this._$startNode = startNode;\n      this._$endNode = endNode;\n    } else {\n      setValue.call(this, value, directiveParent);\n    }\n  };\n\n  /**\n   * Patch ChildPart._$getTemplate to look up templates in a cache bucketed\n   * by element name.\n   */\n  childPartProto._$getTemplate = function (\n    this: PatchableChildPart,\n    result: ShadyTemplateResult\n  ) {\n    const scope = this.options?.scope;\n    let templateCache = scopedTemplateCache.get(scope);\n    if (templateCache === undefined) {\n      scopedTemplateCache.set(scope, (templateCache = new Map()));\n    }\n    let template = templateCache.get(result.strings);\n    if (template === undefined) {\n      templateCache.set(\n        result.strings,\n        (template = new Template(result, this.options))\n      );\n    }\n    return template;\n  };\n};\n\nif (ENABLE_SHADYDOM_NOPATCH) {\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any, @typescript-eslint/no-misused-new\n  (globalThis as any)[\n    'litHtmlPlatformSupport'\n  ].noPatchSupported = ENABLE_SHADYDOM_NOPATCH;\n}\n","/**\n * @license\n * Copyright 2017 Google LLC\n * SPDX-License-Identifier: BSD-3-Clause\n */\n\n/**\n * LitElement patch to support browsers without native web components.\n *\n * This module should be used in addition to loading the web components\n * polyfills via @webcomponents/webcomponentjs. When using those polyfills\n * support for polyfilled Shadow DOM is automatic via the ShadyDOM polyfill, but\n * support for Shadow DOM like css scoping is opt-in. This module uses ShadyCSS\n * to scope styles defined via the `static styles` property and styles included\n * in the render method. There are some limitations to be aware of:\n * * only styles that are included in the first render of a component are scoped.\n * * In addition, support for the deprecated `@apply` feature of ShadyCSS is\n * only provided for styles included in the template and not styles provided\n * via the static styles property.\n * * Lit parts cannot be used in styles included in the template.\n *\n * @packageDocumentation\n */\n\nimport '@lit/reactive-element/polyfill-support.js';\nimport 'lit-html/polyfill-support.js';\n\ninterface RenderOptions {\n  readonly renderBefore?: ChildNode | null;\n  scope?: string;\n}\n\ninterface PatchableLitElementConstructor {\n  _$handlesPrepareStyles?: boolean;\n}\n\ninterface PatchableLitElement extends HTMLElement {\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any, @typescript-eslint/no-misused-new\n  new (...args: any[]): PatchableLitElement;\n  constructor: PatchableLitElementConstructor;\n  createRenderRoot(): Element | ShadowRoot;\n  renderOptions: RenderOptions;\n}\n\n// eslint-disable-next-line @typescript-eslint/no-explicit-any\n(globalThis as any)['litElementPlatformSupport'] ??= ({\n  LitElement,\n}: {\n  LitElement: PatchableLitElement;\n}) => {\n  // polyfill-support is only needed if ShadyCSS or the ApplyShim is in use\n  // We test at the point of patching, which makes it safe to load\n  // webcomponentsjs and polyfill-support in either order\n  if (\n    window.ShadyCSS === undefined ||\n    (window.ShadyCSS.nativeShadow && !window.ShadyCSS.ApplyShim)\n  ) {\n    return;\n  }\n\n  // console.log(\n  //   '%c Making LitElement compatible with ShadyDOM/CSS.',\n  //   'color: lightgreen; font-style: italic'\n  // );\n\n  ((LitElement as unknown) as PatchableLitElementConstructor)._$handlesPrepareStyles = true;\n\n  /**\n   * Patch to apply adoptedStyleSheets via ShadyCSS\n   */\n  const litElementProto = LitElement.prototype;\n  const createRenderRoot = litElementProto.createRenderRoot;\n  litElementProto.createRenderRoot = function (this: PatchableLitElement) {\n    // Pass the scope to render options so that it gets to lit-html for proper\n    // scoping via ShadyCSS. This is needed under Shady and also Shadow DOM,\n    // due to @apply.\n    this.renderOptions.scope = this.localName;\n    return createRenderRoot.call(this);\n  };\n};\n"],"names":["SCOPED","globalThis","reactiveElementPlatformSupport","_a","ReactiveElement","window","ShadyCSS","nativeShadow","ApplyShim","elementProto","prototype","ShadyDOM","inUse","noPatch","patchElementProto","createRenderRoot","name","this","localName","call","constructor","hasOwnProperty","css","elementStyles","map","v","CSSStyleSheet","Array","from","cssRules","reduce","a","r","cssText","ScopingShim","prepareAdoptedCssText","_$handlesPrepareStyles","prepareTemplateStyles","document","createElement","shadowRoot","attachShadow","shadowRootOptions","connectedCallback","hasUpdated","styleElement","didUpdate","_$didUpdate","changedProperties","isFirstUpdate","styledScopes","Set","scopeCssStore","Map","litHtmlPlatformSupport","Template","ChildPart","cssForScope","scopeCss","get","set","scopedTemplateCache","originalCreateElement","html","options","element","scope","prepareTemplateDom","styles","content","querySelectorAll","push","style","parentNode","removeChild","textContent","renderContainer","createDocumentFragment","renderContainerMarker","createComment","childPartProto","setValue","_$setValue","value","directiveParent","container","_$startNode","ShadowRoot","has","startNode","endNode","_$endNode","appendChild","template","_$litType$","_$committedValue","_$template","el","hasScopeCss","length","join","add","delete","querySelector","cloneNode","insertBefore","_$getTemplate","result","templateCache","strings","LitElement","undefined","litElementProto","renderOptions"],"mappings":"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"}