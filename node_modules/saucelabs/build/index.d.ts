import { ChildProcess } from "child_process";

export interface SauceLabsOptions {
  /**
   * Your Sauce Labs username.
   */
  user: string;
  /**
   * Your Sauce Labs access key.
   */
  key: string;
  /**
   * Your Sauce Labs datacenter region. The following regions are available:
   *
   * - us-west-1 (short 'us')
   * - eu-central-1 (short 'eu')
   * - us-east-1 (headless)
   */
  region?: "us" | "eu" | "us-west-1" | "us-east-1" | "eu-central-1" | "staging";
  /**
   * If set to true you are accessing the headless Sauce instances (this discards the region option).
   */
  headless?: boolean;
  /**
   * If you want to tunnel your API request through a proxy please provide your proxy URL.
   */
  proxy?: string;
  /**
   * If you want to set request headers, as example {'User-Agent': 'node-saucelabs'}
   */
  headers?: object;
}

export interface SauceConnectInstance {
  /**
   * Sauce Connect child process
   */
  cp: ChildProcess;
  /**
   * shutdown Sauce Connect
   */
  close: () => Promise<undefined>;
}

export interface SauceConnectOptions {
  /**
   * A function to optionally write sauce-connect-launcher log messages, e.g. console.log
   */
  logger?: (output: string) => void;

  /**
   * Specify the Sauce Connect version you want to use. (default: 4.6.4)
   */
  scVersion?: string;

  /**
   * Perform basic authentication when an URL on <host:port> asks for a username and password.
   */
  auth?: string;

  /**
   * CA certificate bundle to use for verifying REST connections. (default "/usr/local/etc/openssl/cert.pem")
   */
  cainfo?: string;

  /**
   * Directory of CA certs to use for verifying REST connections. (default "/etc/ssl/certs")
   */
  capath?: string;

  /**
   * Path to YAML config file. Please refer to https://wiki.saucelabs.com/display/DOCS/Sauce+Connect+Command+Line+Reference for a sample configuration file.
   */
  configFile?: string;

  /**
   * Comma-separated list of domains. Requests whose host matches one of these will be relayed directly through the internet, instead of through the tunnel.
   */
  directDomains?: string;

  /**
   * Use specified name server. To specify multiple servers, separate them with comma. Use IP addresses, optionally with a port number, the two separated by a colon. Example: --dns 8.8.8.8,8.8.4.4:53
   */
  dns?: string;

  /**
   * Perform checks to detect possible misconfiguration or problems.
   */
  doctor?: boolean;

  /**
   * Comma-separated list of regular expressions. Requests matching one of these will get dropped instantly and will not go through the tunnel.
   */
  fastFailRegexps?: string;

  /**
   * Log statistics about HTTP traffic every <seconds>.
   */
  logStats?: number;

  /**
   * Specify custom logfile.
   */
  logfile?: string;

  /**
   * Rotate logfile after reaching <bytes> size. Disabled by default.
   */
  maxLogsize?: number;

  /**
   * The maximum amount of keepalive acks that can be missed before the client will trigger a reconnect. (default 30) (default: 30)
   */
  maxMissedAcks?: number;

  /**
   * host:port for the internal web server used to expose client side metrics. (default "localhost:8888")
   */
  metricsAddress?: string;

  /**
   * Disable the autodetection of proxy settings.
   */
  noAutodetect?: boolean;

  /**
   * Disable caching in Sauce Connect. All requests will be sent through the tunnel.
   */
  noProxyCaching?: boolean;

  /**
   * Don't remove identified tunnels with the same name, or any other default tunnels if this is a default tunnel. Jobs will be distributed between these tunnels, enabling load balancing and high availability. By default, colliding tunnels will be removed when Sauce Connect is starting up.
   */
  noRemoveCollidingTunnels?: boolean;

  /**
   * Comma-separated list of domains. Requests whose host matches one of these will not be SSL re-encrypted.
   */
  noSslBumpDomains?: string;

  /**
   * Proxy autoconfiguration. Can be an http(s) or local file:// (absolute path only) URI.
   */
  pac?: string;

  /**
   * File that will be created with the pid of the process.
   */
  pidfile?: string;

  /**
   * Use the proxy configured with -p for the tunnel connection.
   */
  proxyTunnel?: boolean;

  /**
   * Username and password required to access the proxy configured with -p.
   */
  proxyUserpwd?: string;

  /**
   * File that will be touched to signal when tunnel is ready.
   */
  readyfile?: string;

  /**
   * Advanced feature: Connect to Sauce REST API at alternative URL. Use only if directed to do so by Sauce Labs support. (default "https://saucelabs.com/rest/v1")
   */
  restUrl?: string;

  /**
   * Port on which scproxy will be listening.
   */
  scproxyPort?: string;

  /**
   * Rate limit reads in scproxy to X bytes per second. This option can be used to adjust local network transfer rate in order not to overload the tunnel connection.
   */
  scproxyReadLimit?: string;

  /**
   * Rate limit writes in scproxy to X bytes per second. This option can be used to adjust local network transfer rate in order not to overload the tunnel connection.
   */
  scproxyWriteLimit?: string;

  /**
   * Port on which Sauce Connect's Selenium relay will listen for requests. Selenium commands reaching Connect on this port will be relayed to Sauce Labs securely and reliably through Connect's tunnel (default 4445) (default: 4445)
   */
  sePort?: number;

  /**
   * Let sub-accounts of the tunnel owner use the tunnel if requested.
   */
  sharedTunnel?: boolean;

  /**
   * CA certificate bundle to use for verifying tunnel connections. (default "/usr/local/etc/openssl/cert.pem")
   */
  tunnelCainfo?: string;

  /**
   * Directory of CA certs to use for verifying tunnel connections. (default "/etc/ssl/certs")
   */
  tunnelCapath?: string;

  /**
   * Specify certificate to use for the tunnel connection, either public or private. Default: private. (default "private")
   */
  tunnelCert?: string;

  /**
   * Inverse of '--direct-domains'. Only requests for domains in this list will be sent through the tunnel. Overrides '--direct-domains'.
   */
  tunnelDomains?: string;

  /**
   * Don't automatically assign jobs to this tunnel. Jobs will use it only by explicitly providing the right identifier.
   */
  tunnelIdentifier?: string;
}

export type PerformanceMetricsListView = {
  items?: Array<PerformanceMetricsListViewItems>;
} & {
  [key: string]: any;
};

export type PerformanceMetricsListViewItems = {
  job_id?: string;
  job_owner?: string;
  job_name_hash?: string;
  page_url?: string;
  order_index?: number;
  job_creation_time?: string;
  load_id?: string;
  loader_id?: string;
  error?: string;
  metric_data?: PerformanceMetricsDetails;
} & {
  [key: string]: any;
};

export type PerformanceMetricsHistoryView = {
  items?: Array<PerformanceMetricsListViewItems>;
} & {
  [key: string]: any;
};

export type PerformanceUserMetricsView = {
  items?: Array<PerformanceMetricsListViewItems>;
  next?: string;
  previous?: string;
} & {
  [key: string]: any;
};

export type PerformanceMetricsDetails = {
  rtt?: number;
  load?: number;
  score?: number;
  maxRtt?: number;
  numFonts?: number;
  numTasks?: number;
  font_size?: number;
  firstPaint?: number;
  font_count?: number;
  image_size?: number;
  numScripts?: number;
  other_size?: number;
  speedIndex?: number;
  throughput?: number;
  image_count?: number;
  numRequests?: number;
  other_count?: number;
  script_size?: number;
  firstCPUIdle?: number;
  requestsSize?: number;
  script_count?: number;
  document_size?: number;
  requestsCount?: number;
  totalTaskTime?: number;
  document_count?: number;
  numStylesheets?: number;
  stylesheet_size?: number;
  timeToFirstByte?: number;
  totalByteWeight?: number;
  domContentLoaded?: number;
  firstInteractive?: number;
  lastVisualChange?: number;
  maxServerLatency?: number;
  numTasksOver10ms?: number;
  numTasksOver25ms?: number;
  numTasksOver50ms?: number;
  stylesheet_count?: number;
  firstVisualChange?: number;
  numTasksOver100ms?: number;
  numTasksOver500ms?: number;
  firstContentfulPaint?: number;
  firstMeaningfulPaint?: number;
  estimatedInputLatency?: number;
  mainDocumentTransferSize?: number;
} & {
  [key: string]: any;
};

export type BaselineView = {
  metric_name?: BaselineDetails;
} & {
  [key: string]: any;
};

export type BaselineDetails = {
  baseline?: number;
  upper_boundary?: number;
  lower_boundary?: number;
  values?: Array<BaselineValues>;
} & {
  [key: string]: any;
};

export type BaselineValues = {
  real_value?: number;
  job_id?: string;
  datetime?: string;
} & {
  [key: string]: any;
};

export type OutlierDetails = {
  status?: boolean;
  reason?: "baseline" | "new_regime";
} & {
  [key: string]: any;
};

export type AssertView = {
  metric_name?: AssertDetails;
} & {
  [key: string]: any;
};

export type AssertDetails = {
  baseline?: number;
  upper_boundary?: number;
  lower_boundary?: number;
  real_value?: number;
  job_id?: string;
  datetime?: string;
  order_index?: number;
  outlier?: OutlierDetails;
} & {
  [key: string]: any;
};

export type RegimesView = {
  metric_name?: Array<
    {
      regime_start: number;
      regime_end: number;
      baseline_url: string;
      active: boolean;
      baseline?: {
        upper_boundary?: number;
        lower_boundary?: number;
      } & {
        [key: string]: any;
      };
    } & {
      [key: string]: any;
    }
  >;
} & {
  [key: string]: any;
};

export type DiscardedView = {
  job_ids?: Array<string>;
} & {
  [key: string]: any;
};

export type ErrorResponse = {
  status?: string;
  message?: string;
} & {
  [key: string]: any;
};

export type RegimeAcknowledge = {
  page_url: string;
  order_index: number;
  metric_names: Array<string>;
} & {
  [key: string]: any;
};

export type PaginationSettings = {
  offset?: number;
  limit?: number;
  searchTerm?: string;
  sortDirection?: "ASCENDING" | "DESCENDING";
} & {
  [key: string]: any;
};

export type ApiSuiteV2 = {
  id?: Id;
  title?: string;
  appVersionId?: Id;
  frameworkVersion?: string;
  deviceIds?: {} & {
    [key: string]: Array<Id>;
  };
} & {
  [key: string]: any;
};

export type Entity = {
  id?: string;
  url?: string;
} & {
  [key: string]: any;
};

export type ApiSuiteV1 = {
  id?: Id;
  title?: string;
  appVersionId?: Id;
  frameworkVersion?: string;
  deviceIds?: Array<Id>;
} & {
  [key: string]: any;
};

export type AppiumTestReport = {
  projectPath?: Path;
  id?: Id;
  uuid?: Uuid;
  batchId?: Id;
  batchName?: string;
  testId?: Id;
  testName?: string;
  appVersionId?: number;
  appVersionName?: string;
  startTime?: number;
  duration?: number;
  networkSpeed?: "FULL" | "GSM" | "HDCSD" | "GPRS" | "EDGE" | "UMTS" | "HSDPA";
  deviceDescriptor?: DeviceDescriptor;
  videoId?: Id;
  running?: boolean;
  systemError?: string;
  testResultStatus?:
    | "UNDEFINED"
    | "WARNING"
    | "OK"
    | "ERROR"
    | "FAILURE"
    | "SKIPPED"
    | "ABORTED"
    | "CANCELED";
  dataCenterId?: Id;
  tunnelIdentifier?: string;
  tunnelId?: string;
  remoteAppFileUrl?: string;
  phoneNumber?: PhoneNumber;
  sharedLinkCode?: string;
  systemErrorType?: string;
  automationBackend?: string;
  status?:
    | "UNKNOWN"
    | "SUCCESS"
    | "WARNING"
    | "FAILURE"
    | "SKIPPED"
    | "ABORTED"
    | "CANCELED";
  withSystemError?: boolean;
  type?: string;
  className?: string;
  sessionId?: string;
  vitalsLogRecordingEnabled?: boolean;
  optionalSharedId?: SharedLiveViewId;
  hasWdaLogs?: boolean;
} & {
  [key: string]: any;
};

export type ReportKey = {
  testId?: Id;
  deviceId?: Id;
} & {
  [key: string]: any;
};

export type StreamingOutput = {} & {
  [key: string]: any;
};

export type ApiTestReport = {
  id?: Id;
  test?: ApiTest;
} & {
  [key: string]: any;
};

export type PaginationResultSessionReport = {
  entities?: Array<SessionReport>;
  metaData?: PaginationSettings;
} & {
  [key: string]: any;
};

export type RobotiumTestReport = {
  projectPath?: Path;
  id?: Id;
  uuid?: Uuid;
  batchId?: Id;
  batchName?: string;
  testId?: Id;
  testName?: string;
  appVersionId?: number;
  appVersionName?: string;
  startTime?: number;
  duration?: number;
  networkSpeed?: "FULL" | "GSM" | "HDCSD" | "GPRS" | "EDGE" | "UMTS" | "HSDPA";
  deviceDescriptor?: DeviceDescriptor;
  videoId?: Id;
  running?: boolean;
  systemError?: string;
  testResultStatus?:
    | "UNDEFINED"
    | "WARNING"
    | "OK"
    | "ERROR"
    | "FAILURE"
    | "SKIPPED"
    | "ABORTED"
    | "CANCELED";
  dataCenterId?: Id;
  tunnelIdentifier?: string;
  tunnelId?: string;
  remoteAppFileUrl?: string;
  phoneNumber?: PhoneNumber;
  sharedLinkCode?: string;
  systemErrorType?: string;
  automationBackend?: string;
  status?:
    | "UNKNOWN"
    | "SUCCESS"
    | "WARNING"
    | "FAILURE"
    | "SKIPPED"
    | "ABORTED"
    | "CANCELED";
  withSystemError?: boolean;
  type?: string;
  screenshots?: Array<number>;
  stackTrace?: string;
  className?: string;
  errorMessage?: string;
} & {
  [key: string]: any;
};

export type TestReportWithArtifacts = {
  report?: TestReport;
  deviceContextId?: string;
  testResult?: string;
  screenshots?: Array<Entity>;
  video?: Entity;
  deviceLog?: string;
  frameworkLog?: string;
  vitalsLog?: string;
} & {
  [key: string]: any;
};

export type WebdriverBatchReport = {
  projectPath?: Path;
  id?: Id;
  batchId?: Id;
  name?: string;
  tests?: Array<TestView>;
  devices?: Array<DeviceView>;
  reports?: Array<ReportEntry>;
  notificationEnabled?: boolean;
  notificationEmails?: Array<string>;
  checkupType?: "STRESS_TEST" | "INSTALL_LAUNCH" | "SCREENSHOTS" | "NONE";
  duration?: number;
  startTime?: number;
  status?:
    | "UNKNOWN"
    | "SUCCESS"
    | "WARNING"
    | "FAILURE"
    | "SKIPPED"
    | "ABORTED"
    | "CANCELED";
  running?: boolean;
  secretLinkCode?: string;
  automationFramework?: "APPIUM" | "TENKOD" | "PIRANHA";
  appUnderTestId?: Id;
} & {
  [key: string]: any;
};

export type TestSuite = {
  name?: string;
  testsuiteStartedAt?: Instant;
  testsuiteFinishedAt?: Instant;
  runCount?: number;
  withFailures?: number;
  unexpected?: number;
  testDuration?: Duration;
  totalDuration?: Duration;
} & {
  [key: string]: any;
};

export type TestReportView = {
  reportId?: Id;
  status?:
    | "UNKNOWN"
    | "SUCCESS"
    | "WARNING"
    | "FAILURE"
    | "SKIPPED"
    | "ABORTED"
    | "CANCELED";
} & {
  [key: string]: any;
};

export type DeviceStatusInfo = {
  poolId?: Id;
  deviceId?: Id;
  status?:
    | "AVAILABLE"
    | "IN_USE"
    | "REBOOTING"
    | "BROKEN"
    | "OFFLINE"
    | "UNPLUGGED";
} & {
  [key: string]: any;
};

export type ApiSuiteReport = {
  id?: Id;
  testReports?: Array<ApiTestReport>;
} & {
  [key: string]: any;
};

export type ApiTestV2 = {
  className?: string;
  methodName?: string;
  deviceId?: Id;
  dataCenterId?: Id;
} & {
  [key: string]: any;
};

export type Instant = {
  epochSecond?: number;
  nano?: number;
} & {
  [key: string]: any;
};

export type ApiTestV1 = {
  className?: string;
  methodName?: string;
  deviceId?: Id;
} & {
  [key: string]: any;
};

export type Duration = {
  seconds?: number;
  zero?: boolean;
  negative?: boolean;
  units?: Array<TemporalUnit>;
  nano?: number;
} & {
  [key: string]: any;
};

export type TestCaseGroup = {
  className?: string;
  testCases?: Array<TestCase>;
} & {
  [key: string]: any;
};

export type PiranhaTestReport = {
  projectPath?: Path;
  id?: Id;
  uuid?: Uuid;
  batchId?: Id;
  batchName?: string;
  testId?: Id;
  testName?: string;
  appVersionId?: number;
  appVersionName?: string;
  startTime?: number;
  duration?: number;
  networkSpeed?: "FULL" | "GSM" | "HDCSD" | "GPRS" | "EDGE" | "UMTS" | "HSDPA";
  deviceDescriptor?: DeviceDescriptor;
  videoId?: Id;
  running?: boolean;
  systemError?: string;
  testResultStatus?:
    | "UNDEFINED"
    | "WARNING"
    | "OK"
    | "ERROR"
    | "FAILURE"
    | "SKIPPED"
    | "ABORTED"
    | "CANCELED";
  dataCenterId?: Id;
  tunnelIdentifier?: string;
  tunnelId?: string;
  remoteAppFileUrl?: string;
  phoneNumber?: PhoneNumber;
  sharedLinkCode?: string;
  systemErrorType?: string;
  automationBackend?: string;
  status?:
    | "UNKNOWN"
    | "SUCCESS"
    | "WARNING"
    | "FAILURE"
    | "SKIPPED"
    | "ABORTED"
    | "CANCELED";
  withSystemError?: boolean;
  type?: string;
  className?: string;
  optionalSharedId?: SharedLiveViewId;
} & {
  [key: string]: any;
};

export type ApiTest = {
  deviceId?: Id;
  dataCenterId?: Id;
  className?: string;
  methodName?: string;
} & {
  [key: string]: any;
};

export type ApiTestStatus = {
  passed?: boolean;
} & {
  [key: string]: any;
};

export type ReportEntry = {
  key?: ReportKey;
  view?: TestReportView;
} & {
  [key: string]: any;
};

export type Id = {} & {
  [key: string]: any;
};

export type TestReport = {
  projectPath?: Path;
  id?: Id;
  uuid?: Uuid;
  batchId?: Id;
  batchName?: string;
  testId?: Id;
  testName?: string;
  appVersionId?: number;
  appVersionName?: string;
  startTime?: number;
  duration?: number;
  networkSpeed?: "FULL" | "GSM" | "HDCSD" | "GPRS" | "EDGE" | "UMTS" | "HSDPA";
  deviceDescriptor?: DeviceDescriptor;
  videoId?: Id;
  running?: boolean;
  systemError?: string;
  testResultStatus?:
    | "UNDEFINED"
    | "WARNING"
    | "OK"
    | "ERROR"
    | "FAILURE"
    | "SKIPPED"
    | "ABORTED"
    | "CANCELED";
  dataCenterId?: Id;
  tunnelIdentifier?: string;
  tunnelId?: string;
  remoteAppFileUrl?: string;
  phoneNumber?: PhoneNumber;
  sharedLinkCode?: string;
  systemErrorType?: string;
  automationBackend?: string;
  status?:
    | "UNKNOWN"
    | "SUCCESS"
    | "WARNING"
    | "FAILURE"
    | "SKIPPED"
    | "ABORTED"
    | "CANCELED";
  withSystemError?: boolean;
  type?: string;
} & {
  [key: string]: any;
};

export type ApiSuite = {
  frameworkVersion?: string;
  deviceIds?: {} & {
    [key: string]: Array<Id>;
  };
  appVersionId?: Id;
  title?: string;
  id?: Id;
} & {
  [key: string]: any;
};

export type Step = {
  id?: Id;
  line?: number;
  method?: string;
  hasReplayImage?: boolean;
  recordedImage?: Id;
  resolvedPosition?: Point;
  orientation?: "PORTRAIT" | "LANDSCAPE";
  warning?: ScriptWarning;
  error?: ScriptError;
  status?:
    | "UNKNOWN"
    | "SUCCESS"
    | "WARNING"
    | "FAILURE"
    | "SKIPPED"
    | "ABORTED"
    | "CANCELED";
} & {
  [key: string]: any;
};

export type QualityReportTestReport = {
  projectPath?: Path;
  id?: Id;
  uuid?: Uuid;
  batchId?: Id;
  batchName?: string;
  testId?: Id;
  testName?: string;
  appVersionId?: number;
  appVersionName?: string;
  startTime?: number;
  duration?: number;
  networkSpeed?: "FULL" | "GSM" | "HDCSD" | "GPRS" | "EDGE" | "UMTS" | "HSDPA";
  deviceDescriptor?: DeviceDescriptor;
  videoId?: Id;
  running?: boolean;
  systemError?: string;
  testResultStatus?:
    | "UNDEFINED"
    | "WARNING"
    | "OK"
    | "ERROR"
    | "FAILURE"
    | "SKIPPED"
    | "ABORTED"
    | "CANCELED";
  dataCenterId?: Id;
  tunnelIdentifier?: string;
  tunnelId?: string;
  remoteAppFileUrl?: string;
  phoneNumber?: PhoneNumber;
  sharedLinkCode?: string;
  systemErrorType?: string;
  automationBackend?: string;
  status?:
    | "UNKNOWN"
    | "SUCCESS"
    | "WARNING"
    | "FAILURE"
    | "SKIPPED"
    | "ABORTED"
    | "CANCELED";
  withSystemError?: boolean;
  type?: string;
  steps?: Array<Step>;
} & {
  [key: string]: any;
};

export type JunitXMLReport = {
  name?: string;
} & {
  [key: string]: any;
};

export type ScriptError = {
  message?: string;
  reason?: string;
  info?: {} & {
    [key: string]: string;
  };
} & {
  [key: string]: any;
};

export type SessionReport = {
  id?: Id;
  projectId?: Id;
  userId?: Id;
  deviceDescriptorId?: Id;
  usage?:
    | "MANUAL"
    | "BATCH"
    | "APPIUM"
    | "PIRANHA"
    | "XCUITEST"
    | "ANDROID_INSTRUMENTATION";
  appId?: Id;
  frameworkAppId?: Id;
  testFrameworkType?: string;
  testFrameworkVersion?: string;
  testReportIds?: Array<Id>;
  testIds?: Array<Id>;
  batchId?: number;
  startDateTime?: string;
  endDateTime?: string;
  durationInSeconds?: number;
} & {
  [key: string]: any;
};

export type DeviceView = {
  dataCenterId?: Id;
  deviceDescriptor?: DeviceDescriptor;
} & {
  [key: string]: any;
};

export type TestError = {
  file?: string;
  lineNumber?: number;
  error?: string;
} & {
  [key: string]: any;
};

export type EspressoTestReport = {
  projectPath?: Path;
  id?: Id;
  uuid?: Uuid;
  batchId?: Id;
  batchName?: string;
  testId?: Id;
  testName?: string;
  appVersionId?: number;
  appVersionName?: string;
  startTime?: number;
  duration?: number;
  networkSpeed?: "FULL" | "GSM" | "HDCSD" | "GPRS" | "EDGE" | "UMTS" | "HSDPA";
  deviceDescriptor?: DeviceDescriptor;
  videoId?: Id;
  running?: boolean;
  systemError?: string;
  testResultStatus?:
    | "UNDEFINED"
    | "WARNING"
    | "OK"
    | "ERROR"
    | "FAILURE"
    | "SKIPPED"
    | "ABORTED"
    | "CANCELED";
  dataCenterId?: Id;
  tunnelIdentifier?: string;
  tunnelId?: string;
  remoteAppFileUrl?: string;
  phoneNumber?: PhoneNumber;
  sharedLinkCode?: string;
  systemErrorType?: string;
  automationBackend?: string;
  status?:
    | "UNKNOWN"
    | "SUCCESS"
    | "WARNING"
    | "FAILURE"
    | "SKIPPED"
    | "ABORTED"
    | "CANCELED";
  withSystemError?: boolean;
  type?: string;
  screenshots?: Array<number>;
  stackTrace?: string;
  className?: string;
  errorMessage?: string;
} & {
  [key: string]: any;
};

export type Path = {
  first?: Id;
  second?: Id;
} & {
  [key: string]: any;
};

export type SharedLiveViewId = {} & {
  [key: string]: any;
};

export type TemporalUnit = {
  dateBased?: boolean;
  durationEstimated?: boolean;
  duration?: Duration;
  timeBased?: boolean;
} & {
  [key: string]: any;
};

export type InputStream = {} & {
  [key: string]: any;
};

export type DeviceDescriptor = {
  id?: Id;
  name?: string;
  modelNumber?: string;
  manufacturer?: Array<string>;
  isArm?: boolean;
  hasOnScreenButtons?: boolean;
  abiType?: string;
  os?: "ANDROID" | "IOS";
  osVersion?: string;
  apiLevel?: number;
  screenSize?: number;
  resolutionWidth?: number;
  resolutionHeight?: number;
  dpi?: number;
  pixelsPerPoint?: number;
  isTablet?: boolean;
  internalOrientation?: "PORTRAIT" | "LANDSCAPE";
  defaultOrientation?: "PORTRAIT" | "LANDSCAPE";
  ramSize?: number;
  internalStorageSize?: number;
  sdCardSize?: number;
  cpuCores?: number;
  cpuFrequency?: number;
  supportsMockLocations?: boolean;
  supportsAppiumWebAppTesting?: boolean;
  isKeyGuardDisabled?: boolean;
  isRooted?: boolean;
  isPrivate?: boolean;
  supportsGlobalProxy?: boolean;
  supportsMinicapSocketConnection?: boolean;
  disableMtp?: boolean;
  deviceFamily?: "ANY" | "IPHONE" | "IPAD";
  cpuType?: "ARM" | "X86";
  dpiName?: string;
  supportsManualWebTesting?: boolean;
  supportsXcuiTest?: boolean;
  supportsMultiTouch?: boolean;
  isAlternativeIoEnabled?: boolean;
  supportsQualityReport?: boolean;
} & {
  [key: string]: any;
};

export type Point = {
  x?: number;
  y?: number;
} & {
  [key: string]: any;
};

export type InstrumentationBatchReport = {
  projectPath?: Path;
  id?: Id;
  batchId?: Id;
  name?: string;
  tests?: Array<TestView>;
  devices?: Array<DeviceView>;
  reports?: Array<ReportEntry>;
  notificationEnabled?: boolean;
  notificationEmails?: Array<string>;
  checkupType?: "STRESS_TEST" | "INSTALL_LAUNCH" | "SCREENSHOTS" | "NONE";
  duration?: number;
  startTime?: number;
  status?:
    | "UNKNOWN"
    | "SUCCESS"
    | "WARNING"
    | "FAILURE"
    | "SKIPPED"
    | "ABORTED"
    | "CANCELED";
  running?: boolean;
  secretLinkCode?: string;
  testSpecAppId?: Id;
  automationFramework?: "ROBOTIUM" | "ESPRESSO" | "XCUITEST";
  appUnderTestId?: Id;
  tunnelIdentifier?: string;
} & {
  [key: string]: any;
};

export type ScriptWarning = {
  message?: string;
  reason?: string;
  info?: {} & {
    [key: string]: string;
  };
} & {
  [key: string]: any;
};

export type QualityReportBatchReport = {
  projectPath?: Path;
  id?: Id;
  batchId?: Id;
  name?: string;
  tests?: Array<TestView>;
  devices?: Array<DeviceView>;
  reports?: Array<ReportEntry>;
  notificationEnabled?: boolean;
  notificationEmails?: Array<string>;
  checkupType?: "STRESS_TEST" | "INSTALL_LAUNCH" | "SCREENSHOTS" | "NONE";
  duration?: number;
  startTime?: number;
  status?:
    | "UNKNOWN"
    | "SUCCESS"
    | "WARNING"
    | "FAILURE"
    | "SKIPPED"
    | "ABORTED"
    | "CANCELED";
  running?: boolean;
  secretLinkCode?: string;
} & {
  [key: string]: any;
};

export type Uuid = {} & {
  [key: string]: any;
};

export type TestCase = {
  methodName?: string;
  className?: string;
  startTime?: number;
  duration?: number;
  status?:
    | "UNKNOWN"
    | "SUCCESS"
    | "WARNING"
    | "FAILURE"
    | "SKIPPED"
    | "ABORTED"
    | "CANCELED";
  testError?: TestError;
} & {
  [key: string]: any;
};

export type BatchReport = {
  projectPath?: Path;
  id?: Id;
  batchId?: Id;
  name?: string;
  tests?: Array<TestView>;
  devices?: Array<DeviceView>;
  reports?: Array<ReportEntry>;
  notificationEnabled?: boolean;
  notificationEmails?: Array<string>;
  checkupType?: "STRESS_TEST" | "INSTALL_LAUNCH" | "SCREENSHOTS" | "NONE";
  duration?: number;
  startTime?: number;
  status?:
    | "UNKNOWN"
    | "SUCCESS"
    | "WARNING"
    | "FAILURE"
    | "SKIPPED"
    | "ABORTED"
    | "CANCELED";
  running?: boolean;
  secretLinkCode?: string;
} & {
  [key: string]: any;
};

export type TestView = {
  testId?: Id;
  name?: string;
  className?: string;
} & {
  [key: string]: any;
};

export type PhoneNumber = {} & {
  [key: string]: any;
};

export type XCUITestReport = {
  projectPath?: Path;
  id?: Id;
  uuid?: Uuid;
  batchId?: Id;
  batchName?: string;
  testId?: Id;
  testName?: string;
  appVersionId?: number;
  appVersionName?: string;
  startTime?: number;
  duration?: number;
  networkSpeed?: "FULL" | "GSM" | "HDCSD" | "GPRS" | "EDGE" | "UMTS" | "HSDPA";
  deviceDescriptor?: DeviceDescriptor;
  videoId?: Id;
  running?: boolean;
  systemError?: string;
  testResultStatus?:
    | "UNDEFINED"
    | "WARNING"
    | "OK"
    | "ERROR"
    | "FAILURE"
    | "SKIPPED"
    | "ABORTED"
    | "CANCELED";
  dataCenterId?: Id;
  tunnelIdentifier?: string;
  tunnelId?: string;
  remoteAppFileUrl?: string;
  phoneNumber?: PhoneNumber;
  sharedLinkCode?: string;
  systemErrorType?: string;
  automationBackend?: string;
  status?:
    | "UNKNOWN"
    | "SUCCESS"
    | "WARNING"
    | "FAILURE"
    | "SKIPPED"
    | "ABORTED"
    | "CANCELED";
  withSystemError?: boolean;
  type?: string;
  screenshots?: Array<number>;
  stackTrace?: string;
  className?: string;
  testCaseGroups?: Array<TestCaseGroup>;
  errorMessage?: string;
} & {
  [key: string]: any;
};

export type AndroidInstrumentationTestReport = {
  projectPath?: Path;
  id?: Id;
  uuid?: Uuid;
  batchId?: Id;
  batchName?: string;
  testId?: Id;
  testName?: string;
  appVersionId?: number;
  appVersionName?: string;
  startTime?: number;
  duration?: number;
  networkSpeed?: "FULL" | "GSM" | "HDCSD" | "GPRS" | "EDGE" | "UMTS" | "HSDPA";
  deviceDescriptor?: DeviceDescriptor;
  videoId?: Id;
  running?: boolean;
  systemError?: string;
  testResultStatus?:
    | "UNDEFINED"
    | "WARNING"
    | "OK"
    | "ERROR"
    | "FAILURE"
    | "SKIPPED"
    | "ABORTED"
    | "CANCELED";
  dataCenterId?: Id;
  tunnelIdentifier?: string;
  tunnelId?: string;
  remoteAppFileUrl?: string;
  phoneNumber?: PhoneNumber;
  sharedLinkCode?: string;
  systemErrorType?: string;
  automationBackend?: string;
  status?:
    | "UNKNOWN"
    | "SUCCESS"
    | "WARNING"
    | "FAILURE"
    | "SKIPPED"
    | "ABORTED"
    | "CANCELED";
  withSystemError?: boolean;
  type?: string;
  screenshots?: Array<number>;
  stackTrace?: string;
  className?: string;
  testSuites?: Array<TestSuite>;
  sessionId?: string;
  testCaseGroups?: Array<TestCaseGroup>;
  errorMessage?: string;
} & {
  [key: string]: any;
};

export type Response_uploadApp_200 = string;

export type Response_readDeviceIds_200 = Array<Id>;

export type Response_getDescriptors_200 = {} & {
  [key: string]: Array<DeviceDescriptor>;
};

export type Response_getDescriptorsApi_200 = Array<DeviceDescriptor>;

export type Response_getAvailableDescriptorIdsApi_200 = Array<Id>;

export type Response_getAvailableDescriptorIds_200 = {} & {
  [key: string]: Array<Id>;
};

export type Response_getDeviceStatusInfos_200 = Array<DeviceStatusInfo>;

export type Response_getDescriptor_200 = {} & {
  [key: string]: DeviceDescriptor;
};

export type Activity = {
  ccy_exec_peak: Array<number>;
  datestamp: Array<string>;
  jobs: Array<number>;
  minutes: Array<number>;
} & {
  [key: string]: any;
};

export type BaseConfig = {
  browserName?: string;
  name?: string;
  platform?: string;
  status?: string;
  version?: number;
} & {
  [key: string]: any;
};

export type Build = {
  creation_time?: number;
  deletion_time?: number;
  end_time?: number;
  id?: string;
  jobs?: {
    completed?: number;
    errored?: number;
    failed?: number;
    finished?: number;
    passed?: number;
    public?: number;
    queued?: number;
    running?: number;
  } & {
    [key: string]: any;
  };
  modification_time?: number;
  name?: string;
  number?: number;
  owner?: string;
  passed?: boolean;
  prefix?: string;
  public?: boolean;
  run?: number;
  start_time?: number;
  status?: string;
} & {
  [key: string]: any;
};

export type CIStat = {
  platform: string;
  platform_version?: string;
} & {
  [key: string]: any;
};

export type CommandCountStats = {
  all?: number;
  error?: number;
} & {
  [key: string]: any;
};

export type Concurrency = {
  concurrency: {} & {
    [key: string]: OrgTeamConcurrencyValues;
  };
  timestamp: number;
} & {
  [key: string]: any;
};

export type ConcurrencyLimit = {
  mac?: number;
  overall?: number;
  real_device?: number;
  scout?: number;
} & {
  [key: string]: any;
};

export type ConcurrencyValues = {
  mac_vms?: number;
  rds?: number;
  vms?: number;
  id?: string;
} & {
  [key: string]: any;
};

export type Error = {
  code?: number;
  fields?: string;
  message?: string;
} & {
  [key: string]: any;
};

export type File = {
  md5: string;
  mtime: string;
  name: string;
  size: number;
} & {
  [key: string]: any;
};

export type Job = {
  assigned_tunnel_id?: string;
  automation_backend?: string;
  base_config?: BaseConfig;
  breakpointed?: string;
  browser?: string;
  browser_short_version?: string;
  browser_version?: string;
  build?: string;
  collects_automator_log?: boolean;
  command_counts?: CommandCountStats;
  commands_not_successful?: number;
  consolidated_status?: "error" | "passed" | "failed" | "complete";
  creation_time?: string;
  "custom-data"?: string;
  deletion_time?: string;
  end_time?: string;
  id: string;
  log_url?: string;
  manual?: boolean;
  modification_time?: string;
  name?: string;
  os?: string;
  owner?: string;
  passed?: boolean;
  proxied?: boolean;
  proxy_host?: boolean;
  public?: "public" | "public restricted" | "share" | "team";
  record_screenshots?: boolean;
  record_video?: boolean;
  selenium_version?: string;
  start_time?: string;
  status?: string;
  tags?: Array<string>;
  video_secret?: string;
  video_url?: string;
} & {
  [key: string]: any;
};

export type Platform = {
  api_name?: string;
  automation_backend?: string;
  deprecated_backend_versions?: Array<string>;
  device?: string;
  latest_stable_version?: string;
  long_name?: string;
  long_version?: string;
  os?: string;
  recommended_backend_version?: string;
  short_version?: string;
  supported_backend_versions?: Array<string>;
} & {
  [key: string]: any;
};

export type SauceStatus = {
  service_operational?: boolean;
  status_message?: string;
  wait_time?: number;
} & {
  [key: string]: any;
};

export type OrgTeamConcurrencyValues = {
  current?: ConcurrencyValues;
  allowed?: ConcurrencyValues;
} & {
  [key: string]: any;
};

export type Tunnel = {
  creation_time?: number;
  direct_domains?: Array<string>;
  domain_names?: Array<string>;
  host?: string;
  id: string;
  last_connected?: number;
  launch_time?: number;
  metadata?: TunnelMetaData;
  no_proxy_caching?: boolean;
  no_ssl_bump_domains?: Array<string>;
  owner?: string;
  shared_tunnel?: boolean;
  shutdown_time?: number;
  ssh_port?: number;
  status?: string;
  tunnel_identifier?: string;
  use_caching_proxy?: boolean;
  use_kgp?: boolean;
  user_shutdown?: boolean;
  vm_version?: string;
} & {
  [key: string]: any;
};

export type TunnelMetaData = {
  build?: string;
  command?: string;
  git_version?: string;
  hostname?: string;
  nofile_limit?: number;
  platform?: string;
  release?: string;
} & {
  [key: string]: any;
};

export type User = {
  access_key?: string;
  ancestor_allows_subaccounts?: boolean;
  ancestor_concurrency_limit?: ConcurrencyLimit;
  can_run_manual?: boolean;
  concurrency_limit?: ConcurrencyLimit;
  creation_time?: string;
  domain?: string;
  email?: string;
  entity_type?: string;
  first_name?: string;
  id?: string;
  is_admin?: string;
  is_sso?: boolean;
  last_name?: string;
  manual_minutes?: number;
  minutes?: number;
  name?: string;
  parent?: string;
  prevent_emails?: Array<"marketing">;
  subscribed?: boolean;
  title?: string;
  user_type?: string;
  username?: string;
  verified?: boolean;
  vm_lockdown?: boolean;
} & {
  [key: string]: any;
};

export type WhoamiUser = {
  access_key?: string;
  ancestor_concurrency_limit?: ConcurrencyLimit;
  can_run_manual?: boolean;
  concurrency_limit?: ConcurrencyLimit;
  email?: string;
  first_name?: string;
  id?: string;
  last_name?: string;
  manual_minutes?: number;
  minutes?: number;
  name?: string;
  parent?: {};
  subscribed?: boolean;
  user_type?: string;
  username?: string;
  verified?: boolean;
} & {
  [key: string]: any;
};

export type Response_list_user_organization_200 = {
  count?: number;
  is_ancestor?: boolean;
  users?: Array<string>;
} & {
  [key: string]: any;
};

export type Response_list_available_tunnels_200 = {} & {
  [key: string]: Array<Tunnel>;
};

export type Response_list_builds_200 = Array<Build>;

export type Response_list_jobs_200 = {
  jobs?: Array<Job>;
} & {
  [key: string]: any;
};

export type Response_get_dashboard_message_for_user_200 = {
  response?: {
    cta?: string;
    id?: string;
    message?: string;
  } & {
    [key: string]: any;
  };
  status?: boolean;
} & {
  [key: string]: any;
};

export type Response_list_platforms_200 = Array<Platform>;

export type Response_delete_manual_job_200 = {};

export type Response_create_manual_job_200 = {
  error?: boolean;
  job_id?: void;
  metadata: {
    browser: string;
    os: string;
    resolution: string;
    tunnel?: void;
    url: string;
    version: string;
  } & {
    [key: string]: any;
  };
  task_id: string;
} & {
  [key: string]: any;
};

export type Response_list_manual_platforms_200 = {} & {
  [key: string]: {} & {
    [key: string]: {
      browser?: string;
      platform?: string;
      resolutions?: Array<string>;
      version?: string;
    } & {
      [key: string]: any;
    };
  };
};

export type Response_get_manual_job_200 = {
  browser: string;
  members: Array<string>;
  os: string;
  owner: string;
  resolution: string;
  tunnel?: void;
  url: string;
  version: string;
} & {
  [key: string]: any;
};

export type Response_create_manual_job_screenshot_201 = {};

export type Response_get_current_user_200 = {
  exp?: number;
  iat?: number;
  username?: string;
} & {
  [key: string]: any;
};

export type Response_delete_manual_job_legacy_200 = {};

export type Response_create_manual_job_legacy_200 = {
  error?: boolean;
  job_id?: void;
  metadata: {
    browser: string;
    os: string;
    resolution: string;
    tunnel?: void;
    url: string;
    version: string;
  } & {
    [key: string]: any;
  };
  task_id: string;
} & {
  [key: string]: any;
};

export type Response_get_user_minutes_200 = {
  automated?: string;
  manual?: string;
} & {
  [key: string]: any;
};

export type Response_get_users_activity_200 = {} & {
  [key: string]: any;
};

export type Response_users_last_job_200 = {} & {
  [key: string]: any;
};

export type Response_list_all_tunnels_200 = {
  tunnels?: Array<Tunnel>;
} & {
  [key: string]: any;
};

export type Response_list_build_failed_jobs_200 = Array<Job>;

export type Response_list_build_jobs_200 = Array<Job>;

export type Response_list_tunnels_200 = Array<string>;

declare class SauceLabs {
  constructor(options: SauceLabsOptions);

  username: string;
  region: string;
  tld: string;
  headless: boolean;
  webdriverEndpoint: string;

  /**
   * Start Sauce Connect
   * @method
   * @name SauceLabs#startSauceConnect
   * @param {string} id - job id
   */
  startSauceConnect(params: SauceConnectOptions): Promise<SauceConnectInstance>;

  /**
   * Provides a list of paginated raw performance metrics for the logged user
   * @method
   * @name SauceLabs#getPerformanceMetrics
   * @param {string} pageUrl - Performance API provides essential information about performance of tested web application.Option
   */
  getPerformanceMetrics(options?: {
    pageUrl?: string;
  }): Promise<PerformanceUserMetricsView>;

  /**
   * Provides performance metrics and job basic data for a given job_id
   * @method
   * @name SauceLabs#getPerformanceMetricsByJobId
   * @param {string} jobId - Performance API provides essential information about performance of tested web application.
   * @param {boolean} full - When set to false, basic job data will be returned, excluding performance metricsOption
   */
  getPerformanceMetricsByJobId(
    jobId: string,
    options?: {
      full?: boolean;
    }
  ): Promise<PerformanceMetricsListView>;

  /**
   * Provides information if there is an outlier for the given job_id and metric
   * @method
   * @name SauceLabs#assertPerformance
   * @param {string} jobId - Performance API provides essential information about performance of tested web application.
   * @param {array} metricNames - Performance API provides essential information about performance of tested web application.Option
   * @param {integer} orderIndex - Performance API provides essential information about performance of tested web application.Option
   */
  assertPerformance(
    jobId: string,
    options?: {
      metricNames: Array<string>;
      orderIndex: number;
    }
  ): Promise<AssertView>;

  /**
   * Provides baseline based on metrics history, where the reference point is a given job_id
   * @method
   * @name SauceLabs#getBaseline
   * @param {string} jobId - Performance API provides essential information about performance of tested web application.
   * @param {array} metricNames - Performance API provides essential information about performance of tested web application.Option
   * @param {integer} orderIndex - Performance API provides essential information about performance of tested web application.Option
   * @param {integer} regimeStart - Performance API provides essential information about performance of tested web application.Option
   * @param {integer} regimeEnd - Performance API provides essential information about performance of tested web application.Option
   */
  getBaseline(
    jobId: string,
    options?: {
      metricNames: Array<string>;
      orderIndex: number;
      regimeStart?: number;
      regimeEnd?: number;
    }
  ): Promise<BaselineView>;

  /**
   * Returns true if a baseline was resetted for a give job_id
   * @method
   * @name SauceLabs#hasBaselineReset
   * @param {string} jobId - Performance API provides essential information about performance of tested web application.
   */
  hasBaselineReset(jobId: string): Promise<ErrorResponse>;

  /**
   * Sets a reset point market at job_id, previous jobs will not be taken into account in calculating baseline
   * @method
   * @name SauceLabs#acknowledgeBaseline
   * @param {string} jobId - Performance API provides essential information about performance of tested web application.
   */
  acknowledgeBaseline(jobId: string): Promise<void>;

  /**
   * Provides lists outliers marked as discarded
   * @method
   * @name SauceLabs#getDiscardedOutliers
   * @param {string} jobId - Performance API provides essential information about performance of tested web application.
   * @param {integer} orderIndex - Performance API provides essential information about performance of tested web application.Option
   */
  getDiscardedOutliers(
    jobId: string,
    options?: {
      orderIndex: number;
    }
  ): Promise<DiscardedView>;

  /**
   * Marks outlier for a given {job_id} as not relevant/flaky
   * @method
   * @name SauceLabs#discardOutliers
   * @param {string} jobId - Performance API provides essential information about performance of tested web application.
   * @param {integer} orderIndex - Performance API provides essential information about performance of tested web application.Option
   */
  discardOutliers(
    jobId: string,
    options?: {
      orderIndex: number;
    }
  ): Promise<void>;

  /**
   * Provides a list of raw performance metrics up to point where the reference is a given job_id and order_index
   * @method
   * @name SauceLabs#getBaselineHistory
   * @param {string} jobId - Performance API provides essential information about performance of tested web application.
   * @param {integer} orderIndex - Performance API provides essential information about performance of tested web application.Option
   * @param {integer} limit - Performance API provides essential information about performance of tested web application.Option
   */
  getBaselineHistory(
    jobId: string,
    options?: {
      orderIndex: number;
      limit?: number;
    }
  ): Promise<PerformanceMetricsHistoryView>;

  /**
   * Provides regimes per metric calculated for a set of jobs, where the reference point is a given job_id
   * @method
   * @name SauceLabs#getRegimes
   * @param {string} jobId - Performance API provides essential information about performance of tested web application.
   * @param {array} metricNames - Performance API provides essential information about performance of tested web application.Option
   * @param {integer} orderIndex - Performance API provides essential information about performance of tested web application.Option
   * @param {boolean} includeBaseline - Performance API provides essential information about performance of tested web application.Option
   */
  getRegimes(
    jobId: string,
    options?: {
      metricNames: Array<string>;
      orderIndex: number;
      includeBaseline?: boolean;
    }
  ): Promise<RegimesView>;

  /**
   * Acknowledge regime. Confirm values in new regime are acceptable.
   * @method
   * @name SauceLabs#acknowledgeRegime
   * @param {string} jobId - Performance API provides essential information about performance of tested web application.
   * @param {integer} orderIndex - Performance API provides essential information about performance of tested web application.Option
   */
  acknowledgeRegime(
    jobId: string,
    options?: {
      orderIndex: number;
    }
  ): Promise<void>;

  /**
   * Provides json documentation for the performance API
   * @method
   * @name SauceLabs#getApiDefinition
   */
  getApiDefinition(): Promise<void>;

  /**
   * Returns new application id after the upload.
   * @method
   * @name SauceLabs#uploadApp
   * @param {string} appType - Application type
   * @param {string} appIdentifier - Your custom unique identifier for your app
   * @param {string} appDisplayName - Your custom display name
   * @param {boolean} appActive - If true makes uploaded application active one
   * @param {} body - TestObject provides access to devices, Appium, storage and your session history via REST API.</br></br>API endpoints requiring authentication use basic authentication. For endpoints requiring "API Key" authentication, the basic authentication should contain your username and have your project's API key as the password. For endpoints requiring "Password" authentication, the basic authentication should contain your username and password. All endpoints in Appium Suites API require basic authentication with the API Key as the username and the password left blank. Please note that the Appium Watcher API does not require basic authentication.</br></br>The base URL for the API is https://app.testobject.com/api/rest/
   */
  uploadApp(
    appType?: string,
    appIdentifier?: string,
    appDisplayName?: string,
    appActive?: boolean,
    body?: InputStream
  ): Promise<Response_uploadApp_200>;

  /**
    * The session history reports provide information about user sessions. This includes device usage and test reports. By default reports of the last 30 days will be retrieved - limited to a maximum of 50 reports.
    If the authenticated user is the owner of the account, session reports of the entire team will be retrieved. Team members can only retrieve their own session history. This endpoint requires Password authentication.
    * @method
    * @name SauceLabs#getSessionReports
         * @param {string} userId - Your username.Option
         * @param {integer} lastDays - Number of days to reportOption
         * @param {integer} offset - Offset for paginationOption
         * @param {integer} limit - Max number of results per pageOption
    */
  getSessionReports(options?: {
    userId?: string;
    lastDays?: number;
    offset?: number;
    limit?: number;
  }): Promise<PaginationResultSessionReport>;

  /**
   * Report the result of a test as skipped.
   * @method
   * @name SauceLabs#markTestAsSkipped
   * @param {string} sessionId - The Appium session ID of your test
   */
  markTestAsSkipped(sessionId: string): Promise<void>;

  /**
   * Report the result of a test.
   * @method
   * @name SauceLabs#updateTest
   * @param {string} sessionId - The Appium session ID of your test
   * @param {} body - TestObject provides access to devices, Appium, storage and your session history via REST API.</br></br>API endpoints requiring authentication use basic authentication. For endpoints requiring "API Key" authentication, the basic authentication should contain your username and have your project's API key as the password. For endpoints requiring "Password" authentication, the basic authentication should contain your username and password. All endpoints in Appium Suites API require basic authentication with the API Key as the username and the password left blank. Please note that the Appium Watcher API does not require basic authentication.</br></br>The base URL for the API is https://app.testobject.com/api/rest/
   */
  updateTest(sessionId: string, body?: ApiTestStatus): Promise<void>;

  /**
   * Updates the properties of a suite.
   * @method
   * @name SauceLabs#updateSuite
   * @param {integer} suiteId - The ID of the suite
   * @param {} body - TestObject provides access to devices, Appium, storage and your session history via REST API.</br></br>API endpoints requiring authentication use basic authentication. For endpoints requiring "API Key" authentication, the basic authentication should contain your username and have your project's API key as the password. For endpoints requiring "Password" authentication, the basic authentication should contain your username and password. All endpoints in Appium Suites API require basic authentication with the API Key as the username and the password left blank. Please note that the Appium Watcher API does not require basic authentication.</br></br>The base URL for the API is https://app.testobject.com/api/rest/
   */
  updateSuite(suiteId: number, body?: ApiSuiteV2): Promise<ApiSuite>;

  /**
   * Returns the IDs of the devices which you had selected for the specified suite.
   * @method
   * @name SauceLabs#readDeviceIds
   * @param {integer} suiteId - The ID of the suite
   */
  readDeviceIds(suiteId: number): Promise<Response_readDeviceIds_200>;

  /**
   * Start a new suite execution including its test executions.
   * @method
   * @name SauceLabs#startSuite
   * @param {integer} suiteId - The ID of the suite
   * @param {integer} appId - The ID of the app version you wish to testOption
   * @param {} body - TestObject provides access to devices, Appium, storage and your session history via REST API.</br></br>API endpoints requiring authentication use basic authentication. For endpoints requiring "API Key" authentication, the basic authentication should contain your username and have your project's API key as the password. For endpoints requiring "Password" authentication, the basic authentication should contain your username and password. All endpoints in Appium Suites API require basic authentication with the API Key as the username and the password left blank. Please note that the Appium Watcher API does not require basic authentication.</br></br>The base URL for the API is https://app.testobject.com/api/rest/
   */
  startSuite(
    suiteId: number,
    options?: {
      appId?: number;
    },
    body?: Array<ApiTestV2>
  ): Promise<ApiSuiteReport>;

  /**
   * Marks all test executions contained in the specified suite execution as finished.
   * @method
   * @name SauceLabs#finishSuite
   * @param {integer} suiteId - The ID of the suite
   * @param {integer} batchReportId - The ID of this suite execution
   */
  finishSuite(suiteId: number, batchReportId: number): Promise<ApiSuiteReport>;

  /**
   * Sets the status of the specific test execution and marks it as finished.
   * @method
   * @name SauceLabs#finishTestReport
   * @param {integer} suiteId - The ID of the suite
   * @param {integer} suiteReportId - The ID of this suite execution
   * @param {integer} testReportId - The ID of this test execution
   * @param {} body - TestObject provides access to devices, Appium, storage and your session history via REST API.</br></br>API endpoints requiring authentication use basic authentication. For endpoints requiring "API Key" authentication, the basic authentication should contain your username and have your project's API key as the password. For endpoints requiring "Password" authentication, the basic authentication should contain your username and password. All endpoints in Appium Suites API require basic authentication with the API Key as the username and the password left blank. Please note that the Appium Watcher API does not require basic authentication.</br></br>The base URL for the API is https://app.testobject.com/api/rest/
   */
  finishTestReport(
    suiteId: number,
    suiteReportId: number,
    testReportId: number,
    body?: ApiTestStatus
  ): Promise<ApiTestReport>;

  /**
   * Mark test execution as skipped
   * @method
   * @name SauceLabs#skipTestReport
   * @param {integer} suiteId - The ID of the suite
   * @param {integer} suiteReportId - The ID of this suite execution
   * @param {integer} testReportId - The ID of this test execution
   */
  skipTestReport(
    suiteId: number,
    suiteReportId: number,
    testReportId: number
  ): Promise<ApiTestReport>;

  /**
   * Returns the test report of a suite
   * @method
   * @name SauceLabs#readBatchReport
   * @param {} body - TestObject provides access to devices, Appium, storage and your session history via REST API.</br></br>API endpoints requiring authentication use basic authentication. For endpoints requiring "API Key" authentication, the basic authentication should contain your username and have your project's API key as the password. For endpoints requiring "Password" authentication, the basic authentication should contain your username and password. All endpoints in Appium Suites API require basic authentication with the API Key as the username and the password left blank. Please note that the Appium Watcher API does not require basic authentication.</br></br>The base URL for the API is https://app.testobject.com/api/rest/
   * @param {} body - TestObject provides access to devices, Appium, storage and your session history via REST API.</br></br>API endpoints requiring authentication use basic authentication. For endpoints requiring "API Key" authentication, the basic authentication should contain your username and have your project's API key as the password. For endpoints requiring "Password" authentication, the basic authentication should contain your username and password. All endpoints in Appium Suites API require basic authentication with the API Key as the username and the password left blank. Please note that the Appium Watcher API does not require basic authentication.</br></br>The base URL for the API is https://app.testobject.com/api/rest/
   */
  readBatchReport(body?: number | string): Promise<BatchReport>;

  /**
   * Returns the test report of a suite as XML
   * @method
   * @name SauceLabs#junitStyleXmlReport
   * @param {} body - TestObject provides access to devices, Appium, storage and your session history via REST API.</br></br>API endpoints requiring authentication use basic authentication. For endpoints requiring "API Key" authentication, the basic authentication should contain your username and have your project's API key as the password. For endpoints requiring "Password" authentication, the basic authentication should contain your username and password. All endpoints in Appium Suites API require basic authentication with the API Key as the username and the password left blank. Please note that the Appium Watcher API does not require basic authentication.</br></br>The base URL for the API is https://app.testobject.com/api/rest/
   * @param {} body - TestObject provides access to devices, Appium, storage and your session history via REST API.</br></br>API endpoints requiring authentication use basic authentication. For endpoints requiring "API Key" authentication, the basic authentication should contain your username and have your project's API key as the password. For endpoints requiring "Password" authentication, the basic authentication should contain your username and password. All endpoints in Appium Suites API require basic authentication with the API Key as the username and the password left blank. Please note that the Appium Watcher API does not require basic authentication.</br></br>The base URL for the API is https://app.testobject.com/api/rest/
   */
  junitStyleXmlReport(body?: number | string): Promise<JunitXMLReport>;

  /**
   * Returns a list per data center containing all devices, including private devices and those not currently available for testing. This endpoint requires API Key authentication.
   * @method
   * @name SauceLabs#getDescriptors
   */
  getDescriptors(): Promise<Response_getDescriptors_200>;

  /**
   * Returns a list per data center containing the IDs of all devices currently available for testing, including private devices. This endpoint requires API Key authentication.
   * @method
   * @name SauceLabs#getAvailableDescriptorIds
   */
  getAvailableDescriptorIds(): Promise<Response_getAvailableDescriptorIds_200>;

  /**
   * Returns information for a particular device per data center. This endpoint requires API Key authentication.
   * @method
   * @name SauceLabs#getDescriptor
   * @param {string} deviceId - The ID of the device
   */
  getDescriptor(deviceId: string): Promise<Response_getDescriptor_200>;

  /**
   * Returns Appium log for the specified test report
   * @method
   * @name SauceLabs#readAppiumLog
   * @param {integer} testReportId - The ID of the test report
   */
  readAppiumLog(testReportId: number): Promise<StreamingOutput>;

  /**
   * Returns device log for the specified test report
   * @method
   * @name SauceLabs#readDeviceLog
   * @param {integer} testReportId - The ID of the test report
   */
  readDeviceLog(testReportId: number): Promise<StreamingOutput>;

  /**
   * Returns device vitals of a test session after completion
   * @method
   * @name SauceLabs#readVitalsLog
   * @param {integer} testReportId - The ID of the test report
   */
  readVitalsLog(testReportId: number): Promise<StreamingOutput>;

  /**
   * Returns XCUITest log for the specified test report
   * @method
   * @name SauceLabs#readXcuiTestLog
   * @param {integer} testReportId - The ID of the test report
   */
  readXcuiTestLog(testReportId: number): Promise<StreamingOutput>;

  /**
   * Returns test report and artifacts for a test session after completion
   * @method
   * @name SauceLabs#readReport
   * @param {integer} testReportId - The test report ID from the test session
   */
  readReport(testReportId: number): Promise<TestReportWithArtifacts>;

  /**
   * Returns a PNG screenshot from a test
   * @method
   * @name SauceLabs#getScreenshot
   * @param {integer} testReportId - TestObject provides access to devices, Appium, storage and your session history via REST API.</br></br>API endpoints requiring authentication use basic authentication. For endpoints requiring "API Key" authentication, the basic authentication should contain your username and have your project's API key as the password. For endpoints requiring "Password" authentication, the basic authentication should contain your username and password. All endpoints in Appium Suites API require basic authentication with the API Key as the username and the password left blank. Please note that the Appium Watcher API does not require basic authentication.</br></br>The base URL for the API is https://app.testobject.com/api/rest/
   * @param {integer} screenshotId - TestObject provides access to devices, Appium, storage and your session history via REST API.</br></br>API endpoints requiring authentication use basic authentication. For endpoints requiring "API Key" authentication, the basic authentication should contain your username and have your project's API key as the password. For endpoints requiring "Password" authentication, the basic authentication should contain your username and password. All endpoints in Appium Suites API require basic authentication with the API Key as the username and the password left blank. Please note that the Appium Watcher API does not require basic authentication.</br></br>The base URL for the API is https://app.testobject.com/api/rest/
   */
  getScreenshot(testReportId: number, screenshotId: number): Promise<void>;

  /**
   * Returns screen recording of a test session after completion
   * @method
   * @name SauceLabs#getScreenRecording
   * @param {string} videoId - The video ID of the recording from the test report
   * @param {string} range - TestObject provides access to devices, Appium, storage and your session history via REST API.</br></br>API endpoints requiring authentication use basic authentication. For endpoints requiring "API Key" authentication, the basic authentication should contain your username and have your project's API key as the password. For endpoints requiring "Password" authentication, the basic authentication should contain your username and password. All endpoints in Appium Suites API require basic authentication with the API Key as the username and the password left blank. Please note that the Appium Watcher API does not require basic authentication.</br></br>The base URL for the API is https://app.testobject.com/api/rest/
   */
  getScreenRecording(videoId: string, range?: string): Promise<void>;

  /**
   * Get Job Information
   * @method
   * @name SauceLabs#getJobV1_1
   * @param {string} id - job id
   */
  getJobV1_1(id: string): Promise<Job>;

  /**
   * User concurrency
   * @method
   * @name SauceLabs#getUserConcurrency
   * @param {string} username - username
   */
  getUserConcurrency(username: string): Promise<Concurrency>;

  /**
   * Org information
   * @method
   * @name SauceLabs#listUserOrganization
   * @param {string} username - username
   */
  listUserOrganization(
    username: string
  ): Promise<Response_list_user_organization_200>;

  /**
   * Get Tunnels
   * @method
   * @name SauceLabs#listAvailableTunnels
   * @param {string} username - username
   */
  listAvailableTunnels(
    username: string
  ): Promise<Response_list_available_tunnels_200>;

  /**
   * Get all of a users builds
   * @method
   * @name SauceLabs#listBuilds
   * @param {string} username - username
   * @param {number} limit - Number of results to returnOption
   * @param {boolean} subaccounts - Include subaccounts in list of jobsOption
   */
  listBuilds(
    username: string,
    options?: {
      limit?: number;
      subaccounts?: boolean;
    }
  ): Promise<Response_list_builds_200>;

  /**
   * Get all of a users jobs
   * @method
   * @name SauceLabs#listJobs
   * @param {string} username - username
   * @param {number} limit - Number of results to returnOption
   * @param {boolean} subaccounts - Include subaccounts in list of jobsOption
   * @param {boolean} full - Should the return result contain everything or just the basicsOption
   * @param {boolean} manualOnly - Only return manual jobsOption
   * @param {boolean} autoOnly - This is a REST API documentation provided by Sauce LabsOption
   * @param {string} name - name of the jobOption
   * @param {string} ownerType - owner type for jobsOption
   * @param {string} owner - username of owner of the jobsOption
   * @param {number} from - receive jobs beginning of a specific timestampOption
   * @param {number} to - receive jobs until specific timestampOption
   */
  listJobs(
    username: string,
    options?: {
      limit?: number;
      subaccounts?: boolean;
      full?: boolean;
      manualOnly?: boolean;
      autoOnly?: boolean;
      name?: string;
      ownerType?: string;
      owner?: string;
      from?: number;
      to?: number;
    }
  ): Promise<Response_list_jobs_200>;

  /**
   * Dashboard messages from Django
   * @method
   * @name SauceLabs#getDashboardMessageForUser
   * @param {string} username - username
   */
  getDashboardMessageForUser(
    username: string
  ): Promise<Response_get_dashboard_message_for_user_200>;

  /**
   * returns a list of supported platforms in the Sauce cloud
   * @method
   * @name SauceLabs#listPlatforms
   * @param {string} platform - username
   */
  listPlatforms(
    platform: "appium" | "webdriver" | "all"
  ): Promise<Response_list_platforms_200>;

  /**
   * Sauce Labs Status
   * @method
   * @name SauceLabs#getStatus
   */
  getStatus(): Promise<SauceStatus>;

  /**
   * complete manual task
   * @method
   * @name SauceLabs#deleteManualJob
   * @param {} ids - list of task ids that to complete
   */
  deleteManualJob(ids: Array<string>): Promise<Response_delete_manual_job_200>;

  /**
   * Creates a manual job
   * @method
   * @name SauceLabs#createManualJob
   * @param {} capabilities - desired capabilities to start the session
   */
  createManualJob(
    capabilities: {
      assets: boolean;
      browser: string;
      browserDisplay: string;
      browserVersionDisplay: string;
      device?: string;
      os: string;
      osDisplay: string;
      res: string;
      tunnel?: string;
      url: string;
      version: string;
    } & {
      [key: string]: any;
    }
  ): Promise<Response_create_manual_job_200>;

  /**
   * returns a list of supported platforms in the Sauce cloud
   * @method
   * @name SauceLabs#listManualPlatforms
   */
  listManualPlatforms(): Promise<Response_list_manual_platforms_200>;

  /**
   * get manual task
   * @method
   * @name SauceLabs#getManualJob
   * @param {string} taskId - task id of manual task
   */
  getManualJob(taskId: string): Promise<Response_get_manual_job_200>;

  /**
   * Take screenshot in manual session
   * @method
   * @name SauceLabs#createManualJobScreenshot
   * @param {string} taskId - task id of manual task
   */
  createManualJobScreenshot(
    taskId: string
  ): Promise<Response_create_manual_job_screenshot_201>;

  /**
   * Authenticated user cookie information
   * @method
   * @name SauceLabs#getCurrentUser
   */
  getCurrentUser(): Promise<Response_get_current_user_200>;

  /**
   * complete manual task
   * @method
   * @name SauceLabs#deleteManualJobLegacy
   * @param {} ids - list of task ids that to complete
   */
  deleteManualJobLegacy(
    ids: Array<string>
  ): Promise<Response_delete_manual_job_legacy_200>;

  /**
   * Creates a manual job
   * @method
   * @name SauceLabs#createManualJobLegacy
   * @param {} capabilities - desired capabilities to start the session
   */
  createManualJobLegacy(
    capabilities: {
      assets: boolean;
      browser: string;
      browserDisplay: string;
      browserVersionDisplay: string;
      device?: string;
      os: string;
      osDisplay: string;
      res: string;
      tunnel?: string;
      url: string;
      version: string;
    } & {
      [key: string]: any;
    }
  ): Promise<Response_create_manual_job_legacy_200>;

  /**
   * User information
   * @method
   * @name SauceLabs#getUser
   * @param {string} username - username
   */
  getUser(username: string): Promise<User>;

  /**
   * User information
   * @method
   * @name SauceLabs#getSubaccounts
   * @param {string} username - username
   */
  getSubaccounts(username: string): Promise<User>;

  /**
   * Get currently running job counts broken down by account and job status
   * @method
   * @name SauceLabs#getUserActivity
   * @param {string} username - username
   */
  getUserActivity(username: string): Promise<Activity>;

  /**
   * User's monthly-minutes
   * @method
   * @name SauceLabs#getUserMinutes
   * @param {string} username - username
   */
  getUserMinutes(username: string): Promise<Response_get_user_minutes_200>;

  /**
   * Get job statistics for usernames
   * @method
   * @name SauceLabs#getUsersActivity
   */
  getUsersActivity(): Promise<Response_get_users_activity_200>;

  /**
   * The result returns dict of usersnames and time when they started last job.
   * @method
   * @name SauceLabs#usersLastJob
   */
  usersLastJob(): Promise<Response_users_last_job_200>;

  /**
   * Authenticated user information
   * @method
   * @name SauceLabs#getCurrentUserFull
   */
  getCurrentUserFull(): Promise<WhoamiUser>;

  /**
   * Get all Tunnels
   * @method
   * @name SauceLabs#listAllTunnels
   * @param {string} username - username
   */
  listAllTunnels(username: string): Promise<Response_list_all_tunnels_200>;

  /**
   * Get all of the jobs associated with a build that have failed
   * @method
   * @name SauceLabs#listBuildFailedJobs
   * @param {string} username - username
   * @param {string} id - job id
   */
  listBuildFailedJobs(
    username: string,
    id: string
  ): Promise<Response_list_build_failed_jobs_200>;

  /**
   * Get all of the jobs associated with a build
   * @method
   * @name SauceLabs#listBuildJobs
   * @param {string} id - job id
   * @param {boolean} full - Should the return result contain everything or just the basicsOption
   */
  listBuildJobs(
    id: string,
    options?: {
      full?: boolean;
    }
  ): Promise<Response_list_build_jobs_200>;

  /**
   * Get Job Information
   * @method
   * @name SauceLabs#getJob
   * @param {string} username - username
   * @param {string} id - job id
   */
  getJob(username: string, id: string): Promise<Job>;

  /**
   * Update Job Information
   * @method
   * @name SauceLabs#updateJob
   * @param {string} username - username
   * @param {string} id - job id
   * @param {} body - This is a REST API documentation provided by Sauce Labs
   */
  updateJob(username: string, id: string, body: Job): Promise<Job>;

  /**
   * Stop Job Information
   * @method
   * @name SauceLabs#stopJob
   * @param {string} username - username
   * @param {string} id - job id
   */
  stopJob(username: string, id: string): Promise<void>;

  /**
   * Get Tunnels
   * @method
   * @name SauceLabs#listTunnels
   * @param {string} username - username
   * @param {boolean} full - Should the return result contain everything or just the basicsOption
   */
  listTunnels(
    username: string,
    options?: {
      full?: boolean;
    }
  ): Promise<Response_list_tunnels_200>;

  /**
   * Delete a Tunnel
   * @method
   * @name SauceLabs#deleteTunnel
   * @param {string} username - username
   * @param {string} id - job id
   */
  deleteTunnel(username: string, id: string): Promise<void>;

  /**
   * Get Tunnels
   * @method
   * @name SauceLabs#getTunnel
   * @param {string} username - username
   * @param {string} id - job id
   */
  getTunnel(username: string, id: string): Promise<Tunnel>;

  /**
   * Get job asset
   * @method
   * @name SauceLabs#downloadJobAsset
   * @param {string} id - job id
   * @param {string} filename - filename
   * @param {string} filepath - file path to store the asset at
   */
  downloadJobAsset(
    id: string,
    filename: string,
    filepath?: string
  ): Promise<File>;

  /**
   * Upload job assets
   * @method
   * @see {@link https://wiki.saucelabs.com|TBD}
   * @name SauceLabs#uploadJobAssets
   * @param {} jobId - id of the job that was run on Sauce Labs
   * @param {} files - asset to upload and attach to your job
   */
  uploadJobAssets(
    jobId: string,
    files?: {
      files?: Array<string>;
    } & {
      [key: string]: any;
    }
  ): Promise<void>;

  /**
   *
   * @method
   * @see {@link https://wiki.saucelabs.com|TBD}
   * @name SauceLabs#createJob
   * @param {} parameters - create result job request body
   */
  createJob(parameters: string): Promise<void>;
}

export default SauceLabs;
