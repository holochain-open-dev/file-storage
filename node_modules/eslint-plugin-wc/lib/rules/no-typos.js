"use strict";
/**
 * @fileoverview Prevents common typos
 * @author James Garbutt <https://github.com/43081j>
 */
Object.defineProperty(exports, "__esModule", { value: true });
const util_1 = require("../util");
const js_levenshtein_esm_1 = require("js-levenshtein-esm");
//------------------------------------------------------------------------------
// Rule Definition
//------------------------------------------------------------------------------
const rule = {
    meta: {
        docs: {
            description: 'Detects misspellings of common features',
            url: 'https://github.com/43081j/eslint-plugin-lit/blob/master/docs/rules/no-typos.md'
        },
        messages: {
            method: 'Method name is likely a misspelling, did you mean "{{replacement}}"?',
            member: 'Member name is likely a misspelling, did you mean "{{replacement}}"?'
        }
    },
    create(context) {
        // variables should be defined here
        let insideElement = false;
        const source = context.getSourceCode();
        const lifecycleMethods = [
            'connectedCallback',
            'disconnectedCallback',
            'adoptedCallback',
            'attributeChangedCallback'
        ];
        //----------------------------------------------------------------------
        // Helpers
        //----------------------------------------------------------------------
        //----------------------------------------------------------------------
        // Public
        //----------------------------------------------------------------------
        return {
            'ClassDeclaration,ClassExpression': (node) => {
                if ((node.type === 'ClassExpression' ||
                    node.type === 'ClassDeclaration') &&
                    util_1.isCustomElement(context, node, source.getJSDocComment(node))) {
                    insideElement = true;
                }
            },
            'ClassDeclaration,ClassExpression:exit': () => {
                insideElement = false;
            },
            MethodDefinition: (node) => {
                if (insideElement && node.type === 'MethodDefinition') {
                    if (node.kind === 'method' &&
                        !node.static &&
                        node.key.type === 'Identifier') {
                        const name = node.key.name;
                        const match = lifecycleMethods
                            .map((m) => {
                            const result = js_levenshtein_esm_1.default(m, name);
                            return [m, result];
                        })
                            .filter((pair) => pair[1] !== 0 && pair[1] < 3)
                            .sort((a, b) => a[1] - b[1]);
                        if (match.length > 0) {
                            context.report({
                                node: node.key,
                                messageId: 'method',
                                data: {
                                    replacement: match[0][0]
                                }
                            });
                        }
                    }
                    else if (node.kind === 'get' &&
                        node.static &&
                        node.key.type === 'Identifier') {
                        const result = js_levenshtein_esm_1.default(node.key.name, 'observedAttributes');
                        if (result !== 0 && result < 3) {
                            context.report({
                                node: node.key,
                                messageId: 'member',
                                data: {
                                    replacement: 'observedAttributes'
                                }
                            });
                        }
                    }
                }
            }
        };
    }
};
exports.default = rule;
