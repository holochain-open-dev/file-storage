{"version":3,"sources":[" [synthetic:es6/util/arrayiterator] ","src/scoped-custom-element-registry.js"," [synthetic:es6/util/makeiterator] "],"names":["NativeHTMLElement","window","HTMLElement","nativeDefine","customElements","define","nativeGet","get","nativeRegistry","definitionForElement","WeakMap","pendingRegistryForElement","globalDefinitionForConstructor","scopeForElement","CustomElementRegistry","constructor","_definitionsByTag","Map","_definitionsByClass","_definedPromises","_definedResolvers","_awaitingUpgrade","tagName","elementClass","toLowerCase","undefined","_getDefinition","DOMException","attributeChangedCallback","prototype","observedAttributes","Set","patchAttributes","definition","connectedCallback","disconnectedCallback","adoptedCallback","set","standInClass","call","createStandInElement","awaiting","delete","$jscomp.arrayIteratorImpl","element","upgrade","resolver","creationContext","push","apply","arguments","pop","whenDefined","promise","resolve","Promise","r","_upgradeWhenDefined","shouldUpgrade","add","upgradingInstance","window.HTMLElement","instance","TypeError","Reflect","construct","Object","setPrototypeOf","scope","getRootNode","document","ShadowRoot","context","length","registry","size","setAttribute","elementClass.prototype.setAttribute","name","value","has","old","getAttribute","removeAttribute","elementClass.prototype.removeAttribute","forEach","attr","hasAttribute","nativeAttachShadow","Element","attachShadow","Element.prototype.attachShadow","init","shadowRoot","installScopedCreationMethod","ctor","method","from","native","getPrototypeOf","ret","installScopedCreationSetter","descriptor","getOwnPropertyDescriptor","defineProperty","configurable","writable"],"mappings":"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","file":"scoped-custom-element-registry.min.js","sourcesContent":[null,"/**\n * @license\n * Copyright (c) 2020 The Polymer Project Authors. All rights reserved.\n * This code may only be used under the BSD style license found at\n * http://polymer.github.io/LICENSE.txt\n * The complete set of authors may be found at\n * http://polymer.github.io/AUTHORS.txt\n * The complete set of contributors may be found at\n * http://polymer.github.io/CONTRIBUTORS.txt\n * Code distributed by Google as part of the polymer project is also\n * subject to an additional IP rights grant found at\n * http://polymer.github.io/PATENTS.txt\n */\n\nconst NativeHTMLElement = window.HTMLElement;\nconst nativeDefine = window.customElements.define;\nconst nativeGet = window.customElements.get;\nconst nativeRegistry = window.customElements;\n\nconst definitionForElement = new WeakMap();\nconst pendingRegistryForElement = new WeakMap();\nconst globalDefinitionForConstructor = new WeakMap();\n// TBD: This part of the spec proposal is unclear:\n// > Another option for looking up registries is to store an element's\n// > originating registry with the element. The Chrome DOM team was concerned\n// > about the small additional memory overhead on all elements. Looking up the\n// > root avoids this.\nconst scopeForElement = new WeakMap();\n\n// Constructable CE registry class, which uses the native CE registry to\n// register stand-in elements that can delegate out to CE classes registered\n// in scoped registries\nwindow.CustomElementRegistry = class {\n  constructor() {\n    this._definitionsByTag = new Map();\n    this._definitionsByClass = new Map();\n    this._definedPromises = new Map();\n    this._definedResolvers = new Map();\n    this._awaitingUpgrade = new Map();\n  }\n  define(tagName, elementClass) {\n    tagName = tagName.toLowerCase();\n    if (this._getDefinition(tagName) !== undefined) {\n      throw new DOMException(\n        `Failed to execute 'define' on 'CustomElementRegistry': the name \"${tagName}\" has already been used with this registry`\n      );\n    }\n    if (this._definitionsByClass.get(elementClass) !== undefined) {\n      throw new DOMException(\n        `Failed to execute 'define' on 'CustomElementRegistry': this constructor has already been used with this registry`\n      );\n    }\n    // Since observedAttributes can't change, we approximate it by patching\n    // set/removeAttribute on the user's class\n    const attributeChangedCallback =\n      elementClass.prototype.attributeChangedCallback;\n    const observedAttributes = new Set(elementClass.observedAttributes || []);\n    patchAttributes(elementClass, observedAttributes, attributeChangedCallback);\n    // Register the definition\n    const definition = {\n      elementClass,\n      connectedCallback: elementClass.prototype.connectedCallback,\n      disconnectedCallback: elementClass.prototype.disconnectedCallback,\n      adoptedCallback: elementClass.prototype.adoptedCallback,\n      attributeChangedCallback,\n      observedAttributes,\n    };\n    this._definitionsByTag.set(tagName, definition);\n    this._definitionsByClass.set(elementClass, definition);\n    // Register a stand-in class which will handle the registry lookup & delegation\n    let standInClass = nativeGet.call(nativeRegistry, tagName);\n    if (!standInClass) {\n      standInClass = createStandInElement(tagName);\n      nativeDefine.call(nativeRegistry, tagName, standInClass);\n    }\n    if (this === window.customElements) {\n      globalDefinitionForConstructor.set(elementClass, definition);\n      definition.standInClass = standInClass;\n    }\n    // Upgrade any elements created in this scope before define was called\n    const awaiting = this._awaitingUpgrade.get(tagName);\n    if (awaiting) {\n      this._awaitingUpgrade.delete(tagName);\n      for (const element of awaiting) {\n        pendingRegistryForElement.delete(element);\n        upgrade(element, definition);\n      }\n    }\n    // Flush whenDefined callbacks\n    const resolver = this._definedResolvers.get(tagName);\n    if (resolver) {\n      resolver();\n    }\n    return elementClass;\n  }\n  upgrade() {\n    creationContext.push(this);\n    nativeRegistry.upgrade.apply(nativeRegistry, arguments);\n    creationContext.pop();\n  }\n  get(tagName) {\n    const definition = this._definitionsByTag.get(tagName);\n    return definition?.elementClass;\n  }\n  _getDefinition(tagName) {\n    return this._definitionsByTag.get(tagName);\n  }\n  whenDefined(tagName) {\n    let promise = this._definedPromises.get(tagName);\n    if (!promise) {\n      let resolve;\n      promise = new Promise((r) => (resolve = r));\n      this._definedPromises.set(tagName, promise);\n      this._definedResolvers.set(tagName, resolve);\n    }\n    return promise;\n  }\n  _upgradeWhenDefined(element, tagName, shouldUpgrade) {\n    let awaiting = this._awaitingUpgrade.get(tagName);\n    if (!awaiting) {\n      this._awaitingUpgrade.set(tagName, (awaiting = new Set()));\n    }\n    if (shouldUpgrade) {\n      awaiting.add(element);\n    } else {\n      awaiting.delete(element);\n    }\n  }\n};\n\n// User extends this HTMLElement, which returns the CE being upgraded\nlet upgradingInstance;\nwindow.HTMLElement = function HTMLElement() {\n  // Upgrading case: the StandInElement constructor was run by the browser's\n  // native custom elements and we're in the process of running the\n  // \"constructor-call trick\" on the natively constructed instance, so just\n  // return that here\n  let instance = upgradingInstance;\n  if (instance) {\n    upgradingInstance = undefined;\n    return instance;\n  }\n  // Construction case: we need to construct the StandInElement and return\n  // it; note the current spec proposal only allows new'ing the constructor\n  // of elements registered with the global registry\n  const definition = globalDefinitionForConstructor.get(this.constructor);\n  if (!definition) {\n    throw new TypeError(\n      'Illegal constructor (custom element class must be registered with global customElements registry to be newable)'\n    );\n  }\n  instance = Reflect.construct(NativeHTMLElement, [], definition.standInClass);\n  Object.setPrototypeOf(instance, this.constructor.prototype);\n  definitionForElement.set(instance, definition);\n  return instance;\n};\nwindow.HTMLElement.prototype = NativeHTMLElement.prototype;\n\n// Helpers to return the scope for a node where its registry would be located\nconst isValidScope = (node) => node === document || node instanceof ShadowRoot;\nconst registryForNode = (node) => {\n  // TODO: the algorithm for finding the scope is a bit up in the air; assigning\n  // a one-time scope at creation time would require walking every tree ever\n  // created, which is avoided for now\n  let scope = node.getRootNode();\n  // If we're not attached to the document (i.e. in a disconnected tree or\n  // fragment), we need to get the scope from the creation context; that should\n  // be a Document or ShadowRoot, unless it was created via innerHTML\n  if (!isValidScope(scope)) {\n    const context = creationContext[creationContext.length - 1];\n    // When upgrading via registry.upgrade(), the registry itself is put on the\n    // creationContext stack\n    if (context instanceof CustomElementRegistry) {\n      return context;\n    }\n    // Otherwise, get the root node of the element this was created from\n    scope = context.getRootNode();\n    // The creation context wasn't a Document or ShadowRoot or in one; this\n    // means we're being innerHTML'ed into a disconnected element; for now, we\n    // hope that root node was created imperatively, where we stash _its_\n    // scopeForElement. Beyond that, we'd need more costly tracking.\n    if (!isValidScope(scope)) {\n      scope = scopeForElement.get(scope)?.getRootNode() || document;\n    }\n  }\n  return scope.customElements;\n};\n\n// Helper to create stand-in element for each tagName registered that delegates\n// out to the registry for the given element\nconst createStandInElement = (tagName) => {\n  return class ScopedCustomElementBase {\n    constructor() {\n      // Create a raw HTMLElement first\n      const instance = Reflect.construct(\n        NativeHTMLElement,\n        [],\n        this.constructor\n      );\n      // We need to install the minimum HTMLElement prototype so that\n      // scopeForNode can use DOM API to determine our construction scope;\n      // upgrade will eventually install the full CE prototype\n      Object.setPrototypeOf(instance, HTMLElement.prototype);\n      // Get the node's scope, and its registry (falls back to global registry)\n      const registry = registryForNode(instance) || window.customElements;\n      const definition = registry._getDefinition(tagName);\n      if (definition) {\n        upgrade(instance, definition);\n      } else {\n        pendingRegistryForElement.set(instance, registry);\n      }\n      return instance;\n    }\n    connectedCallback() {\n      const definition = definitionForElement.get(this);\n      if (definition) {\n        // Delegate out to user callback\n        definition.connectedCallback &&\n          definition.connectedCallback.apply(this, arguments);\n      } else {\n        // Register for upgrade when defined (only when connected, so we don't leak)\n        pendingRegistryForElement\n          .get(this)\n          ._upgradeWhenDefined(this, tagName, true);\n      }\n    }\n    disconnectedCallback() {\n      const definition = definitionForElement.get(this);\n      if (definition) {\n        // Delegate out to user callback\n        definition.disconnectedCallback &&\n          definition.disconnectedCallback.apply(this, arguments);\n      } else {\n        // Un-register for upgrade when defined (so we don't leak)\n        pendingRegistryForElement\n          .get(this)\n          ._upgradeWhenDefined(this, tagName, false);\n      }\n    }\n    adoptedCallback() {\n      const definition = definitionForElement.get(this);\n      definition?.adoptedCallback?.apply(this, arguments);\n    }\n    // no attributeChangedCallback or observedAttributes since these\n    // are simulated via setAttribute/removeAttribute patches\n  };\n};\n\n// Helper to patch CE class setAttribute/getAttribute to implement\n// attributeChangedCallback\nconst patchAttributes = (\n  elementClass,\n  observedAttributes,\n  attributeChangedCallback\n) => {\n  if (observedAttributes.size === 0 || attributeChangedCallback === undefined) {\n    return;\n  }\n  const setAttribute = elementClass.prototype.setAttribute;\n  if (setAttribute) {\n    elementClass.prototype.setAttribute = function (name, value) {\n      if (observedAttributes.has(name)) {\n        const old = this.getAttribute(name);\n        setAttribute.call(this, name, value);\n        attributeChangedCallback.call(this, name, old, value);\n      } else {\n        setAttribute.call(this, name, value);\n      }\n    };\n  }\n  const removeAttribute = elementClass.prototype.removeAttribute;\n  if (removeAttribute) {\n    elementClass.prototype.removeAttribute = function (name) {\n      if (observedAttributes.has(name)) {\n        const old = this.getAttribute(name);\n        removeAttribute.call(this, name);\n        attributeChangedCallback.call(this, name, old, null);\n      } else {\n        removeAttribute.call(this, name);\n      }\n    };\n  }\n};\n\n// Helper to upgrade an instance with a CE definition using \"constructor call trick\"\nconst upgrade = (instance, definition) => {\n  Object.setPrototypeOf(instance, definition.elementClass.prototype);\n  definitionForElement.set(instance, definition);\n  upgradingInstance = instance;\n  new definition.elementClass();\n  // Approximate observedAttributes from the user class, since the stand-in element had none\n  definition.observedAttributes.forEach((attr) => {\n    if (instance.hasAttribute(attr)) {\n      definition.attributeChangedCallback.call(\n        instance,\n        attr,\n        null,\n        instance.getAttribute(attr)\n      );\n    }\n  });\n};\n\n// Patch attachShadow to set customElements on shadowRoot when provided\nconst nativeAttachShadow = Element.prototype.attachShadow;\nElement.prototype.attachShadow = function (init) {\n  const shadowRoot = nativeAttachShadow.apply(this, arguments);\n  if (init.customElements) {\n    shadowRoot.customElements = init.customElements;\n  }\n  return shadowRoot;\n};\n\n// Install scoped creation API on Element & ShadowRoot\nlet creationContext = [document];\nconst installScopedCreationMethod = (ctor, method, from) => {\n  const native = (from ? Object.getPrototypeOf(from) : ctor.prototype)[method];\n  ctor.prototype[method] = function () {\n    creationContext.push(this);\n    const ret = native.apply(from || this, arguments);\n    scopeForElement.set(ret, this);\n    creationContext.pop();\n    return ret;\n  };\n};\ninstallScopedCreationMethod(ShadowRoot, 'createElement', document);\ninstallScopedCreationMethod(ShadowRoot, 'importNode', document);\ninstallScopedCreationMethod(Element, 'insertAdjacentHTML');\n\n// Install scoped innerHTML on Element & ShadowRoot\nconst installScopedCreationSetter = (ctor, name) => {\n  const descriptor = Object.getOwnPropertyDescriptor(ctor.prototype, name);\n  Object.defineProperty(ctor.prototype, name, {\n    ...descriptor,\n    set(value) {\n      creationContext.push(this);\n      descriptor.set.call(this, value);\n      creationContext.pop();\n    },\n  });\n};\ninstallScopedCreationSetter(Element, 'innerHTML');\ninstallScopedCreationSetter(ShadowRoot, 'innerHTML');\n\n// Install global registry\nObject.defineProperty(window, 'customElements', {\n  value: new CustomElementRegistry(),\n  configurable: true,\n  writable: true,\n});\n"]}