{"version":3,"file":"addon-web-components-knobs.js","sources":["node_modules/lit-html/lib/template.js","node_modules/lit-html/lib/parts.js","node_modules/@open-wc/testing-helpers/src/helpers.js","node_modules/lit-html/lit-html.js","node_modules/@open-wc/testing-helpers/src/elementUpdated.js","node_modules/@open-wc/testing-helpers/src/lib.js","node_modules/storybook-addon-web-components-knobs/src/withWebComponentsKnobs.js"],"sourcesContent":["/**\n * @license\n * Copyright (c) 2017 The Polymer Project Authors. All rights reserved.\n * This code may only be used under the BSD style license found at\n * http://polymer.github.io/LICENSE.txt\n * The complete set of authors may be found at\n * http://polymer.github.io/AUTHORS.txt\n * The complete set of contributors may be found at\n * http://polymer.github.io/CONTRIBUTORS.txt\n * Code distributed by Google as part of the polymer project is also\n * subject to an additional IP rights grant found at\n * http://polymer.github.io/PATENTS.txt\n */\n/**\n * An expression marker with embedded unique key to avoid collision with\n * possible text in templates.\n */\nexport const marker = `{{lit-${String(Math.random()).slice(2)}}}`;\n/**\n * An expression marker used text-positions, multi-binding attributes, and\n * attributes with markup-like text values.\n */\nexport const nodeMarker = `<!--${marker}-->`;\nexport const markerRegex = new RegExp(`${marker}|${nodeMarker}`);\n/**\n * Suffix appended to all bound attribute names.\n */\nexport const boundAttributeSuffix = '$lit$';\n/**\n * An updateable Template that tracks the location of dynamic parts.\n */\nexport class Template {\n    constructor(result, element) {\n        this.parts = [];\n        this.element = element;\n        const nodesToRemove = [];\n        const stack = [];\n        // Edge needs all 4 parameters present; IE11 needs 3rd parameter to be null\n        const walker = document.createTreeWalker(element.content, 133 /* NodeFilter.SHOW_{ELEMENT|COMMENT|TEXT} */, null, false);\n        // Keeps track of the last index associated with a part. We try to delete\n        // unnecessary nodes, but we never want to associate two different parts\n        // to the same index. They must have a constant node between.\n        let lastPartIndex = 0;\n        let index = -1;\n        let partIndex = 0;\n        const { strings, values: { length } } = result;\n        while (partIndex < length) {\n            const node = walker.nextNode();\n            if (node === null) {\n                // We've exhausted the content inside a nested template element.\n                // Because we still have parts (the outer for-loop), we know:\n                // - There is a template in the stack\n                // - The walker will find a nextNode outside the template\n                walker.currentNode = stack.pop();\n                continue;\n            }\n            index++;\n            if (node.nodeType === 1 /* Node.ELEMENT_NODE */) {\n                if (node.hasAttributes()) {\n                    const attributes = node.attributes;\n                    const { length } = attributes;\n                    // Per\n                    // https://developer.mozilla.org/en-US/docs/Web/API/NamedNodeMap,\n                    // attributes are not guaranteed to be returned in document order.\n                    // In particular, Edge/IE can return them out of order, so we cannot\n                    // assume a correspondence between part index and attribute index.\n                    let count = 0;\n                    for (let i = 0; i < length; i++) {\n                        if (endsWith(attributes[i].name, boundAttributeSuffix)) {\n                            count++;\n                        }\n                    }\n                    while (count-- > 0) {\n                        // Get the template literal section leading up to the first\n                        // expression in this attribute\n                        const stringForPart = strings[partIndex];\n                        // Find the attribute name\n                        const name = lastAttributeNameRegex.exec(stringForPart)[2];\n                        // Find the corresponding attribute\n                        // All bound attributes have had a suffix added in\n                        // TemplateResult#getHTML to opt out of special attribute\n                        // handling. To look up the attribute value we also need to add\n                        // the suffix.\n                        const attributeLookupName = name.toLowerCase() + boundAttributeSuffix;\n                        const attributeValue = node.getAttribute(attributeLookupName);\n                        node.removeAttribute(attributeLookupName);\n                        const statics = attributeValue.split(markerRegex);\n                        this.parts.push({ type: 'attribute', index, name, strings: statics });\n                        partIndex += statics.length - 1;\n                    }\n                }\n                if (node.tagName === 'TEMPLATE') {\n                    stack.push(node);\n                    walker.currentNode = node.content;\n                }\n            }\n            else if (node.nodeType === 3 /* Node.TEXT_NODE */) {\n                const data = node.data;\n                if (data.indexOf(marker) >= 0) {\n                    const parent = node.parentNode;\n                    const strings = data.split(markerRegex);\n                    const lastIndex = strings.length - 1;\n                    // Generate a new text node for each literal section\n                    // These nodes are also used as the markers for node parts\n                    for (let i = 0; i < lastIndex; i++) {\n                        let insert;\n                        let s = strings[i];\n                        if (s === '') {\n                            insert = createMarker();\n                        }\n                        else {\n                            const match = lastAttributeNameRegex.exec(s);\n                            if (match !== null && endsWith(match[2], boundAttributeSuffix)) {\n                                s = s.slice(0, match.index) + match[1] +\n                                    match[2].slice(0, -boundAttributeSuffix.length) + match[3];\n                            }\n                            insert = document.createTextNode(s);\n                        }\n                        parent.insertBefore(insert, node);\n                        this.parts.push({ type: 'node', index: ++index });\n                    }\n                    // If there's no text, we must insert a comment to mark our place.\n                    // Else, we can trust it will stick around after cloning.\n                    if (strings[lastIndex] === '') {\n                        parent.insertBefore(createMarker(), node);\n                        nodesToRemove.push(node);\n                    }\n                    else {\n                        node.data = strings[lastIndex];\n                    }\n                    // We have a part for each match found\n                    partIndex += lastIndex;\n                }\n            }\n            else if (node.nodeType === 8 /* Node.COMMENT_NODE */) {\n                if (node.data === marker) {\n                    const parent = node.parentNode;\n                    // Add a new marker node to be the startNode of the Part if any of\n                    // the following are true:\n                    //  * We don't have a previousSibling\n                    //  * The previousSibling is already the start of a previous part\n                    if (node.previousSibling === null || index === lastPartIndex) {\n                        index++;\n                        parent.insertBefore(createMarker(), node);\n                    }\n                    lastPartIndex = index;\n                    this.parts.push({ type: 'node', index });\n                    // If we don't have a nextSibling, keep this node so we have an end.\n                    // Else, we can remove it to save future costs.\n                    if (node.nextSibling === null) {\n                        node.data = '';\n                    }\n                    else {\n                        nodesToRemove.push(node);\n                        index--;\n                    }\n                    partIndex++;\n                }\n                else {\n                    let i = -1;\n                    while ((i = node.data.indexOf(marker, i + 1)) !== -1) {\n                        // Comment node has a binding marker inside, make an inactive part\n                        // The binding won't work, but subsequent bindings will\n                        // TODO (justinfagnani): consider whether it's even worth it to\n                        // make bindings in comments work\n                        this.parts.push({ type: 'node', index: -1 });\n                        partIndex++;\n                    }\n                }\n            }\n        }\n        // Remove text binding nodes after the walk to not disturb the TreeWalker\n        for (const n of nodesToRemove) {\n            n.parentNode.removeChild(n);\n        }\n    }\n}\nconst endsWith = (str, suffix) => {\n    const index = str.length - suffix.length;\n    return index >= 0 && str.slice(index) === suffix;\n};\nexport const isTemplatePartActive = (part) => part.index !== -1;\n// Allows `document.createComment('')` to be renamed for a\n// small manual size-savings.\nexport const createMarker = () => document.createComment('');\n/**\n * This regex extracts the attribute name preceding an attribute-position\n * expression. It does this by matching the syntax allowed for attributes\n * against the string literal directly preceding the expression, assuming that\n * the expression is in an attribute-value position.\n *\n * See attributes in the HTML spec:\n * https://www.w3.org/TR/html5/syntax.html#elements-attributes\n *\n * \" \\x09\\x0a\\x0c\\x0d\" are HTML space characters:\n * https://www.w3.org/TR/html5/infrastructure.html#space-characters\n *\n * \"\\0-\\x1F\\x7F-\\x9F\" are Unicode control characters, which includes every\n * space character except \" \".\n *\n * So an attribute is:\n *  * The name: any character except a control character, space character, ('),\n *    (\"), \">\", \"=\", or \"/\"\n *  * Followed by zero or more space characters\n *  * Followed by \"=\"\n *  * Followed by zero or more space characters\n *  * Followed by:\n *    * Any character except space, ('), (\"), \"<\", \">\", \"=\", (`), or\n *    * (\") then any non-(\"), or\n *    * (') then any non-(')\n */\nexport const lastAttributeNameRegex = /([ \\x09\\x0a\\x0c\\x0d])([^\\0-\\x1F\\x7F-\\x9F \"'>=/]+)([ \\x09\\x0a\\x0c\\x0d]*=[ \\x09\\x0a\\x0c\\x0d]*(?:[^ \\x09\\x0a\\x0c\\x0d\"'`<>=]*|\"[^\"]*|'[^']*))$/;\n//# sourceMappingURL=template.js.map","/**\n * @license\n * Copyright (c) 2017 The Polymer Project Authors. All rights reserved.\n * This code may only be used under the BSD style license found at\n * http://polymer.github.io/LICENSE.txt\n * The complete set of authors may be found at\n * http://polymer.github.io/AUTHORS.txt\n * The complete set of contributors may be found at\n * http://polymer.github.io/CONTRIBUTORS.txt\n * Code distributed by Google as part of the polymer project is also\n * subject to an additional IP rights grant found at\n * http://polymer.github.io/PATENTS.txt\n */\n/**\n * @module lit-html\n */\nimport { isDirective } from './directive.js';\nimport { removeNodes } from './dom.js';\nimport { noChange, nothing } from './part.js';\nimport { TemplateInstance } from './template-instance.js';\nimport { TemplateResult } from './template-result.js';\nimport { createMarker } from './template.js';\nexport const isPrimitive = (value) => {\n    return (value === null ||\n        !(typeof value === 'object' || typeof value === 'function'));\n};\nexport const isIterable = (value) => {\n    return Array.isArray(value) ||\n        // tslint:disable-next-line:no-any\n        !!(value && value[Symbol.iterator]);\n};\n/**\n * Writes attribute values to the DOM for a group of AttributeParts bound to a\n * single attibute. The value is only set once even if there are multiple parts\n * for an attribute.\n */\nexport class AttributeCommitter {\n    constructor(element, name, strings) {\n        this.dirty = true;\n        this.element = element;\n        this.name = name;\n        this.strings = strings;\n        this.parts = [];\n        for (let i = 0; i < strings.length - 1; i++) {\n            this.parts[i] = this._createPart();\n        }\n    }\n    /**\n     * Creates a single part. Override this to create a differnt type of part.\n     */\n    _createPart() {\n        return new AttributePart(this);\n    }\n    _getValue() {\n        const strings = this.strings;\n        const l = strings.length - 1;\n        let text = '';\n        for (let i = 0; i < l; i++) {\n            text += strings[i];\n            const part = this.parts[i];\n            if (part !== undefined) {\n                const v = part.value;\n                if (isPrimitive(v) || !isIterable(v)) {\n                    text += typeof v === 'string' ? v : String(v);\n                }\n                else {\n                    for (const t of v) {\n                        text += typeof t === 'string' ? t : String(t);\n                    }\n                }\n            }\n        }\n        text += strings[l];\n        return text;\n    }\n    commit() {\n        if (this.dirty) {\n            this.dirty = false;\n            this.element.setAttribute(this.name, this._getValue());\n        }\n    }\n}\n/**\n * A Part that controls all or part of an attribute value.\n */\nexport class AttributePart {\n    constructor(committer) {\n        this.value = undefined;\n        this.committer = committer;\n    }\n    setValue(value) {\n        if (value !== noChange && (!isPrimitive(value) || value !== this.value)) {\n            this.value = value;\n            // If the value is a not a directive, dirty the committer so that it'll\n            // call setAttribute. If the value is a directive, it'll dirty the\n            // committer if it calls setValue().\n            if (!isDirective(value)) {\n                this.committer.dirty = true;\n            }\n        }\n    }\n    commit() {\n        while (isDirective(this.value)) {\n            const directive = this.value;\n            this.value = noChange;\n            directive(this);\n        }\n        if (this.value === noChange) {\n            return;\n        }\n        this.committer.commit();\n    }\n}\n/**\n * A Part that controls a location within a Node tree. Like a Range, NodePart\n * has start and end locations and can set and update the Nodes between those\n * locations.\n *\n * NodeParts support several value types: primitives, Nodes, TemplateResults,\n * as well as arrays and iterables of those types.\n */\nexport class NodePart {\n    constructor(options) {\n        this.value = undefined;\n        this.__pendingValue = undefined;\n        this.options = options;\n    }\n    /**\n     * Appends this part into a container.\n     *\n     * This part must be empty, as its contents are not automatically moved.\n     */\n    appendInto(container) {\n        this.startNode = container.appendChild(createMarker());\n        this.endNode = container.appendChild(createMarker());\n    }\n    /**\n     * Inserts this part after the `ref` node (between `ref` and `ref`'s next\n     * sibling). Both `ref` and its next sibling must be static, unchanging nodes\n     * such as those that appear in a literal section of a template.\n     *\n     * This part must be empty, as its contents are not automatically moved.\n     */\n    insertAfterNode(ref) {\n        this.startNode = ref;\n        this.endNode = ref.nextSibling;\n    }\n    /**\n     * Appends this part into a parent part.\n     *\n     * This part must be empty, as its contents are not automatically moved.\n     */\n    appendIntoPart(part) {\n        part.__insert(this.startNode = createMarker());\n        part.__insert(this.endNode = createMarker());\n    }\n    /**\n     * Inserts this part after the `ref` part.\n     *\n     * This part must be empty, as its contents are not automatically moved.\n     */\n    insertAfterPart(ref) {\n        ref.__insert(this.startNode = createMarker());\n        this.endNode = ref.endNode;\n        ref.endNode = this.startNode;\n    }\n    setValue(value) {\n        this.__pendingValue = value;\n    }\n    commit() {\n        while (isDirective(this.__pendingValue)) {\n            const directive = this.__pendingValue;\n            this.__pendingValue = noChange;\n            directive(this);\n        }\n        const value = this.__pendingValue;\n        if (value === noChange) {\n            return;\n        }\n        if (isPrimitive(value)) {\n            if (value !== this.value) {\n                this.__commitText(value);\n            }\n        }\n        else if (value instanceof TemplateResult) {\n            this.__commitTemplateResult(value);\n        }\n        else if (value instanceof Node) {\n            this.__commitNode(value);\n        }\n        else if (isIterable(value)) {\n            this.__commitIterable(value);\n        }\n        else if (value === nothing) {\n            this.value = nothing;\n            this.clear();\n        }\n        else {\n            // Fallback, will render the string representation\n            this.__commitText(value);\n        }\n    }\n    __insert(node) {\n        this.endNode.parentNode.insertBefore(node, this.endNode);\n    }\n    __commitNode(value) {\n        if (this.value === value) {\n            return;\n        }\n        this.clear();\n        this.__insert(value);\n        this.value = value;\n    }\n    __commitText(value) {\n        const node = this.startNode.nextSibling;\n        value = value == null ? '' : value;\n        // If `value` isn't already a string, we explicitly convert it here in case\n        // it can't be implicitly converted - i.e. it's a symbol.\n        const valueAsString = typeof value === 'string' ? value : String(value);\n        if (node === this.endNode.previousSibling &&\n            node.nodeType === 3 /* Node.TEXT_NODE */) {\n            // If we only have a single text node between the markers, we can just\n            // set its value, rather than replacing it.\n            // TODO(justinfagnani): Can we just check if this.value is primitive?\n            node.data = valueAsString;\n        }\n        else {\n            this.__commitNode(document.createTextNode(valueAsString));\n        }\n        this.value = value;\n    }\n    __commitTemplateResult(value) {\n        const template = this.options.templateFactory(value);\n        if (this.value instanceof TemplateInstance &&\n            this.value.template === template) {\n            this.value.update(value.values);\n        }\n        else {\n            // Make sure we propagate the template processor from the TemplateResult\n            // so that we use its syntax extension, etc. The template factory comes\n            // from the render function options so that it can control template\n            // caching and preprocessing.\n            const instance = new TemplateInstance(template, value.processor, this.options);\n            const fragment = instance._clone();\n            instance.update(value.values);\n            this.__commitNode(fragment);\n            this.value = instance;\n        }\n    }\n    __commitIterable(value) {\n        // For an Iterable, we create a new InstancePart per item, then set its\n        // value to the item. This is a little bit of overhead for every item in\n        // an Iterable, but it lets us recurse easily and efficiently update Arrays\n        // of TemplateResults that will be commonly returned from expressions like:\n        // array.map((i) => html`${i}`), by reusing existing TemplateInstances.\n        // If _value is an array, then the previous render was of an\n        // iterable and _value will contain the NodeParts from the previous\n        // render. If _value is not an array, clear this part and make a new\n        // array for NodeParts.\n        if (!Array.isArray(this.value)) {\n            this.value = [];\n            this.clear();\n        }\n        // Lets us keep track of how many items we stamped so we can clear leftover\n        // items from a previous render\n        const itemParts = this.value;\n        let partIndex = 0;\n        let itemPart;\n        for (const item of value) {\n            // Try to reuse an existing part\n            itemPart = itemParts[partIndex];\n            // If no existing part, create a new one\n            if (itemPart === undefined) {\n                itemPart = new NodePart(this.options);\n                itemParts.push(itemPart);\n                if (partIndex === 0) {\n                    itemPart.appendIntoPart(this);\n                }\n                else {\n                    itemPart.insertAfterPart(itemParts[partIndex - 1]);\n                }\n            }\n            itemPart.setValue(item);\n            itemPart.commit();\n            partIndex++;\n        }\n        if (partIndex < itemParts.length) {\n            // Truncate the parts array so _value reflects the current state\n            itemParts.length = partIndex;\n            this.clear(itemPart && itemPart.endNode);\n        }\n    }\n    clear(startNode = this.startNode) {\n        removeNodes(this.startNode.parentNode, startNode.nextSibling, this.endNode);\n    }\n}\n/**\n * Implements a boolean attribute, roughly as defined in the HTML\n * specification.\n *\n * If the value is truthy, then the attribute is present with a value of\n * ''. If the value is falsey, the attribute is removed.\n */\nexport class BooleanAttributePart {\n    constructor(element, name, strings) {\n        this.value = undefined;\n        this.__pendingValue = undefined;\n        if (strings.length !== 2 || strings[0] !== '' || strings[1] !== '') {\n            throw new Error('Boolean attributes can only contain a single expression');\n        }\n        this.element = element;\n        this.name = name;\n        this.strings = strings;\n    }\n    setValue(value) {\n        this.__pendingValue = value;\n    }\n    commit() {\n        while (isDirective(this.__pendingValue)) {\n            const directive = this.__pendingValue;\n            this.__pendingValue = noChange;\n            directive(this);\n        }\n        if (this.__pendingValue === noChange) {\n            return;\n        }\n        const value = !!this.__pendingValue;\n        if (this.value !== value) {\n            if (value) {\n                this.element.setAttribute(this.name, '');\n            }\n            else {\n                this.element.removeAttribute(this.name);\n            }\n            this.value = value;\n        }\n        this.__pendingValue = noChange;\n    }\n}\n/**\n * Sets attribute values for PropertyParts, so that the value is only set once\n * even if there are multiple parts for a property.\n *\n * If an expression controls the whole property value, then the value is simply\n * assigned to the property under control. If there are string literals or\n * multiple expressions, then the strings are expressions are interpolated into\n * a string first.\n */\nexport class PropertyCommitter extends AttributeCommitter {\n    constructor(element, name, strings) {\n        super(element, name, strings);\n        this.single =\n            (strings.length === 2 && strings[0] === '' && strings[1] === '');\n    }\n    _createPart() {\n        return new PropertyPart(this);\n    }\n    _getValue() {\n        if (this.single) {\n            return this.parts[0].value;\n        }\n        return super._getValue();\n    }\n    commit() {\n        if (this.dirty) {\n            this.dirty = false;\n            // tslint:disable-next-line:no-any\n            this.element[this.name] = this._getValue();\n        }\n    }\n}\nexport class PropertyPart extends AttributePart {\n}\n// Detect event listener options support. If the `capture` property is read\n// from the options object, then options are supported. If not, then the thrid\n// argument to add/removeEventListener is interpreted as the boolean capture\n// value so we should only pass the `capture` property.\nlet eventOptionsSupported = false;\ntry {\n    const options = {\n        get capture() {\n            eventOptionsSupported = true;\n            return false;\n        }\n    };\n    // tslint:disable-next-line:no-any\n    window.addEventListener('test', options, options);\n    // tslint:disable-next-line:no-any\n    window.removeEventListener('test', options, options);\n}\ncatch (_e) {\n}\nexport class EventPart {\n    constructor(element, eventName, eventContext) {\n        this.value = undefined;\n        this.__pendingValue = undefined;\n        this.element = element;\n        this.eventName = eventName;\n        this.eventContext = eventContext;\n        this.__boundHandleEvent = (e) => this.handleEvent(e);\n    }\n    setValue(value) {\n        this.__pendingValue = value;\n    }\n    commit() {\n        while (isDirective(this.__pendingValue)) {\n            const directive = this.__pendingValue;\n            this.__pendingValue = noChange;\n            directive(this);\n        }\n        if (this.__pendingValue === noChange) {\n            return;\n        }\n        const newListener = this.__pendingValue;\n        const oldListener = this.value;\n        const shouldRemoveListener = newListener == null ||\n            oldListener != null &&\n                (newListener.capture !== oldListener.capture ||\n                    newListener.once !== oldListener.once ||\n                    newListener.passive !== oldListener.passive);\n        const shouldAddListener = newListener != null && (oldListener == null || shouldRemoveListener);\n        if (shouldRemoveListener) {\n            this.element.removeEventListener(this.eventName, this.__boundHandleEvent, this.__options);\n        }\n        if (shouldAddListener) {\n            this.__options = getOptions(newListener);\n            this.element.addEventListener(this.eventName, this.__boundHandleEvent, this.__options);\n        }\n        this.value = newListener;\n        this.__pendingValue = noChange;\n    }\n    handleEvent(event) {\n        if (typeof this.value === 'function') {\n            this.value.call(this.eventContext || this.element, event);\n        }\n        else {\n            this.value.handleEvent(event);\n        }\n    }\n}\n// We copy options because of the inconsistent behavior of browsers when reading\n// the third argument of add/removeEventListener. IE11 doesn't support options\n// at all. Chrome 41 only reads `capture` if the argument is an object.\nconst getOptions = (o) => o &&\n    (eventOptionsSupported ?\n        { capture: o.capture, passive: o.passive, once: o.once } :\n        o.capture);\n//# sourceMappingURL=parts.js.map","let defineCECounter = 0;\n\n/**\n * Registers a new element with an automatically generated unique name.\n * Helps to make a test fully isolated.\n *\n * @example\n * const tag = defineCE(class extends MyMixin(HTMLElement) {\n *   // define custom element class body\n * });\n * const el = fixture(`<${tag}></${tag}>`);\n * // test el\n *\n * @param {function} klass Class which extends HTMLElement\n * @returns {string} Tag name of the registered element\n */\nexport function defineCE(klass) {\n  const tag = `test-${defineCECounter}`;\n  customElements.define(tag, klass);\n  defineCECounter += 1;\n  return tag;\n}\n\n/**\n * Indicates that this is Internet Explorer.\n *\n * @returns {boolean}\n */\nexport function isIE() {\n  return !!navigator.userAgent.match(/Trident/g) || !!navigator.userAgent.match(/MSIE/g);\n}\n\n/**\n * Resolves after provided amount of miliseconds.\n *\n * @example\n * await aTimeout(100);\n *\n * @param {number} ms Miliseconds.\n * @returns {Promise<void>} Promise to await until time is up\n */\nexport function aTimeout(ms) {\n  return new Promise(resolve => {\n    setTimeout(resolve, ms);\n  });\n}\n\n/**\n * Resolves after requestAnimationFrame.\n *\n * @example\n * await nextFrame();\n *\n * @returns {Promise<void>} Promise that resolved after requestAnimationFrame\n */\nexport function nextFrame() {\n  return new Promise(resolve => requestAnimationFrame(() => resolve()));\n}\n\n/**\n * Blurs the provided element and await time before and after it on IE.\n *\n * @example\n * const el = await fixture('<input type=\"text\" autofocus />');\n * await triggerBlurFor(el);\n * // el is no longer focused\n *\n * @param {HTMLElement} element Element/Node to blur\n * @returns {Promise<void>} Promise to await until blur is done (for IE)\n */\nexport async function triggerBlurFor(element) {\n  if (isIE()) {\n    await nextFrame();\n    await nextFrame();\n  }\n  element.blur();\n  if (isIE()) {\n    element.blur();\n    await nextFrame();\n    await nextFrame();\n  }\n}\n\n/**\n * Focuses the provided element and await time before and after it on IE.\n *\n * Background info:\n * Adding an event and immediately trigger it fails in IE.\n * Also before checking the effects of a trigger IE needs some time.\n *\n * @example\n * const el = await fixture('<input type=\"text\" />');\n * await triggerFocusFor(el);\n * // el is now focused\n *\n * @param {HTMLElement} element Element/Node to focus\n * @returns {Promise<void>} Promise to await until focus is done (for IE)\n */\nexport async function triggerFocusFor(element) {\n  if (isIE()) {\n    await nextFrame();\n    await nextFrame();\n  }\n  element.focus();\n  if (isIE()) {\n    element.focus();\n    await nextFrame();\n    await nextFrame();\n  }\n}\n\n/**\n * Listens for one event and resolves with this event object after it was fired.\n *\n * @example\n * setTimeout(() => el.fireDone());\n * await oneEvent(el, 'done');\n * expect(el.done).to.be.true;\n *\n * @param {EventTarget} eventTarget Target of the event, usually an Element\n * @param {string} eventName Name of the event\n * @returns {Promise<CustomEvent>} Promise to await until the event has been fired\n */\nexport function oneEvent(eventTarget, eventName) {\n  return new Promise(resolve => {\n    function listener(ev) {\n      resolve(ev);\n      eventTarget.removeEventListener(eventName, listener);\n    }\n    eventTarget.addEventListener(eventName, listener);\n  });\n}\n\n/**\n * Waits until the given predicate returns a truthy value. Calls and awaits the predicate\n * function at the given interval time. Can be used to poll until a certain condition is true.\n *\n * @example\n * ```js\n * import { fixture, waitUntil } from '@open-wc/testing-helpers';\n *\n * const element = await fixture(html`<my-element></my-element>`);\n *\n * await waitUntil(() => element.someAsyncProperty, 'element should become ready');\n * ```\n *\n * @param {() => boolean | Promise<boolean>} predicate - predicate function which is called each poll interval.\n *   The predicate is awaited, so it can return a promise.\n * @param {string} [message] an optional message to display when the condition timed out\n * @param {{ interval?: number, timeout?: number }} [options] timeout and polling interval\n */\nexport function waitUntil(predicate, message, options = {}) {\n  const { interval = 50, timeout = 2000 } = options;\n\n  return new Promise((resolve, reject) => {\n    let timeoutId;\n\n    setTimeout(() => {\n      clearTimeout(timeoutId);\n      reject(new Error(message ? `Timeout: ${message}` : 'waitUntil timed out'));\n    }, timeout);\n\n    async function nextInterval() {\n      try {\n        if (await predicate()) {\n          resolve();\n        } else {\n          timeoutId = setTimeout(() => {\n            nextInterval();\n          }, interval);\n        }\n      } catch (error) {\n        reject(error);\n      }\n    }\n    nextInterval();\n  });\n}\n","/**\n * @license\n * Copyright (c) 2017 The Polymer Project Authors. All rights reserved.\n * This code may only be used under the BSD style license found at\n * http://polymer.github.io/LICENSE.txt\n * The complete set of authors may be found at\n * http://polymer.github.io/AUTHORS.txt\n * The complete set of contributors may be found at\n * http://polymer.github.io/CONTRIBUTORS.txt\n * Code distributed by Google as part of the polymer project is also\n * subject to an additional IP rights grant found at\n * http://polymer.github.io/PATENTS.txt\n */\n/**\n *\n * Main lit-html module.\n *\n * Main exports:\n *\n * -  [[html]]\n * -  [[svg]]\n * -  [[render]]\n *\n * @module lit-html\n * @preferred\n */\n/**\n * Do not remove this comment; it keeps typedoc from misplacing the module\n * docs.\n */\nimport { defaultTemplateProcessor } from './lib/default-template-processor.js';\nimport { SVGTemplateResult, TemplateResult } from './lib/template-result.js';\nexport { DefaultTemplateProcessor, defaultTemplateProcessor } from './lib/default-template-processor.js';\nexport { directive, isDirective } from './lib/directive.js';\n// TODO(justinfagnani): remove line when we get NodePart moving methods\nexport { removeNodes, reparentNodes } from './lib/dom.js';\nexport { noChange, nothing } from './lib/part.js';\nexport { AttributeCommitter, AttributePart, BooleanAttributePart, EventPart, isIterable, isPrimitive, NodePart, PropertyCommitter, PropertyPart } from './lib/parts.js';\nexport { parts, render } from './lib/render.js';\nexport { templateCaches, templateFactory } from './lib/template-factory.js';\nexport { TemplateInstance } from './lib/template-instance.js';\nexport { SVGTemplateResult, TemplateResult } from './lib/template-result.js';\nexport { createMarker, isTemplatePartActive, Template } from './lib/template.js';\n// IMPORTANT: do not change the property name or the assignment expression.\n// This line will be used in regexes to search for lit-html usage.\n// TODO(justinfagnani): inject version number at build time\n(window['litHtmlVersions'] || (window['litHtmlVersions'] = [])).push('1.1.2');\n/**\n * Interprets a template literal as an HTML template that can efficiently\n * render to and update a container.\n */\nexport const html = (strings, ...values) => new TemplateResult(strings, values, 'html', defaultTemplateProcessor);\n/**\n * Interprets a template literal as an SVG template that can efficiently\n * render to and update a container.\n */\nexport const svg = (strings, ...values) => new SVGTemplateResult(strings, values, 'svg', defaultTemplateProcessor);\n//# sourceMappingURL=lit-html.js.map","import { nextFrame } from './helpers.js';\n\nconst isDefinedPromise = action => typeof action === 'object' && Promise.resolve(action) === action;\n\n/**\n * Awaits for \"update complete promises\" of elements\n * - for [lit-element](https://github.com/polymer/lit-element) that is `el.updateComplete`;\n * - for [stencil](https://github.com/ionic-team/stencil/) that is `el.componentOnReady()`;\n *\n * If none of those specfic Promise hooks are found, it will wait for one frame via\n * `await nextFrame()`.\n *\n * Ensures that ShadyDOM finished its job if available.\n *\n * @template {Element} T\n * @param {T} el\n * @returns {Promise<T>}\n */\nexport async function elementUpdated(el) {\n  let hasSpecificAwait = false;\n  // @ts-ignore\n  let update = el && el.updateComplete;\n  if (isDefinedPromise(update)) {\n    await update;\n    hasSpecificAwait = true;\n  }\n\n  // @ts-ignore\n  update = el && el.componentOnReady ? el.componentOnReady() : false;\n  if (isDefinedPromise(update)) {\n    await update;\n    hasSpecificAwait = true;\n  }\n\n  if (!hasSpecificAwait) {\n    await nextFrame();\n  }\n\n  // @ts-ignore\n  if (window.ShadyDOM && typeof window.ShadyDOM.flush === 'function') {\n    // @ts-ignore\n    window.ShadyDOM.flush();\n  }\n\n  return el;\n}\n","import { TemplateResult } from 'lit-html';\n\nexport const isIterable = object => object != null && typeof object[Symbol.iterator] === 'function';\n\nfunction isValidNonIterableRenderArg(x) {\n  return (\n    x instanceof TemplateResult ||\n    x instanceof Node ||\n    typeof x === 'number' ||\n    typeof x === 'boolean' ||\n    typeof x === 'string'\n  );\n}\n\nexport function isValidRenderArg(x) {\n  return isIterable(x) ? [...x].every(isValidNonIterableRenderArg) : isValidNonIterableRenderArg(x);\n}\n\n/**\n * Node#nodeType enum\n * @readonly\n * @enum {number}\n */\nexport const NODE_TYPES = Object.freeze({\n  ELEMENT_NODE: 1,\n  TEXT_NODE: 3,\n  COMMENT_NODE: 8,\n  DOCUMENT_FRAGMENT_NODE: 11,\n});\n","/* eslint-disable */\nimport { render } from 'lit-html';\nimport { elementUpdated } from '@open-wc/testing-helpers/index-no-side-effects.js';\nimport { array, boolean, color, date, text, number, object } from '@storybook/addon-knobs';\nimport { manager } from '@storybook/addon-knobs/dist/registerKnobs.js';\n\nfunction getType(meta) {\n  let type = 'string';\n  if (meta.type) {\n    type = meta.type;\n  }\n  if (meta.storybookKnobs && meta.storybookKnobs.type) {\n    type = meta.storybookKnobs.type;\n  }\n  return type.toLowerCase();\n}\n\nfunction getGroupName(\n  meta,\n  index,\n  defaultGroup = 'Properties',\n  multiple = false,\n  filterProperties,\n) {\n  if (filterProperties) {\n    return 'Debug';\n  }\n  let group = defaultGroup;\n  if (meta.storybookKnobs && meta.storybookKnobs.group) {\n    group = meta.storybookKnobs.group;\n  }\n\n  if (multiple) {\n    group = `${index}: ${group}`;\n  }\n\n  return group;\n}\n\nfunction getLabel({ meta, elIndex, filterProperties }) {\n  if (filterProperties) {\n    return `${elIndex}: ${meta.name}`;\n  }\n  return meta.name;\n}\n\nfunction propertiesToKnobs({ el, elIndex, metaData, hasMultiple, filterProperties }) {\n  if (metaData && metaData.properties) {\n    const properties = filterProperties\n      ? metaData.properties.filter(prop => filterProperties.includes(prop.name))\n      : metaData.properties;\n\n    properties.forEach(prop => {\n      const propName = prop.name;\n      const type = getType(prop);\n      const group = getGroupName(prop, elIndex, 'Properties', hasMultiple, filterProperties);\n      const label = getLabel({ meta: prop, elIndex, filterProperties });\n\n      if (type) {\n        switch (type) {\n          case 'string':\n            el[propName] = text(label, el[propName], group);\n            break;\n          case 'number':\n            el[propName] = number(label, el[propName], {}, group);\n            break;\n          case 'array':\n            el[propName] = array(label, el[propName], ',', group);\n            break;\n          case 'boolean':\n            el[propName] = boolean(label, el[propName], group);\n            break;\n          case 'object':\n          case 'array<object>':\n            el[propName] = object(label, el[propName], group);\n            break;\n          case 'date':\n            el[propName] = new Date(date(label, el[propName], group));\n            break;\n          default:\n        }\n      }\n    });\n  }\n}\n\nfunction cssPropertiesToKnobs(el, i, cssVariables, multiple) {\n  cssVariables.forEach(varMeta => {\n    const cssName = varMeta.name;\n    const type = getType(varMeta);\n    const group = getGroupName(varMeta, i, 'CSS', multiple);\n\n    const validTypes = ['length', 'string', 'color'];\n\n    if (validTypes.includes(type)) {\n      let value;\n      const style = window.getComputedStyle(el);\n      const defaultValue = style.getPropertyValue(cssName);\n      switch (type) {\n        case 'string':\n        case 'length':\n          value = text(cssName, defaultValue, group);\n          break;\n        case 'color':\n          value = color(cssName, defaultValue, group);\n          break;\n        /* no default */\n      }\n      if (value) {\n        el.style.setProperty(cssName, value);\n      }\n    }\n  });\n}\n\nfunction isValidComponent(tagName) {\n  if (!tagName) {\n    return false;\n  }\n  if (typeof tagName === 'string') {\n    return true;\n  }\n  throw new Error('Provided component needs to be a string. e.g. component: \"my-element\"');\n}\n\nfunction isValidMetaData(customElements) {\n  if (!customElements) {\n    return false;\n  }\n  if (customElements.tags && Array.isArray(customElements.tags)) {\n    return true;\n  }\n  throw new Error(`You need to setup valid meta data in your config.js via setCustomElements().\n    See the readme of addon-docs for web components for more details.`);\n}\n\nfunction syncElToKnobs(el, elIndex, metaData, multiple, filterProperties) {\n  if (metaData.properties) {\n    const properties = filterProperties\n      ? metaData.properties.filter(prop => filterProperties.includes(prop.name))\n      : metaData.properties;\n    properties.forEach(property => {\n      const group = getGroupName(property, elIndex, 'Properties', multiple, filterProperties);\n      const label = getLabel({ meta: property, elIndex, filterProperties });\n      const knobsName = `${label}_${group}`;\n      manager.knobStore.update(knobsName, { value: el[property.name] });\n    });\n  }\n  // // TODO: find a way to update css\n  // if (metaData.cssProperties) {\n  //   metaData.cssProperties.forEach(property => {\n  //     const group = getGroupName(property, '', elIndex, 'CSS', multiple);\n  //     const knobsName = `${property.name}_${group}`;\n  //     const style = window.getComputedStyle(el);\n  //     const value = style.getPropertyValue(property);\n\n  //     manager.knobStore.update(knobsName, { value });\n  //   });\n  // }\n  manager._mayCallChannel();\n}\n\nexport function withWebComponentsKnobs(storyFn, data) {\n  // @ts-ignore\n  let customElements = window.__STORYBOOK_CUSTOM_ELEMENTS__;\n\n  if (isValidComponent(data.parameters.component) && isValidMetaData(customElements)) {\n    let querySelectorAll = data.parameters.component;\n    if (data.parameters.customElements) {\n      customElements = { ...customElements, ...data.parameters.customElements };\n    }\n    if (customElements.querySelectorAll) {\n      querySelectorAll = customElements.querySelectorAll;\n    }\n    const { filterProperties } = customElements;\n\n    const wrapper = document.createElement('div');\n    render(storyFn(), wrapper);\n\n    const wcTags = Array.from(wrapper.querySelectorAll(querySelectorAll)).filter(node =>\n      node.tagName.includes('-'),\n    );\n\n    if (wcTags.length === 0) {\n      throw new Error(`The provided querySelectorString \"${querySelectorAll}\" did\n        not select any custom elements (with a \"-\" in the tag name)`);\n    }\n\n    const hasMultiple = wcTags.length > 1;\n\n    wcTags.forEach((el, elIndex) => {\n      const metaData = customElements.tags.find(tag => tag.name.toUpperCase() === el.tagName);\n      if (metaData && metaData.properties) {\n        propertiesToKnobs({ el, elIndex, metaData, hasMultiple, filterProperties });\n      }\n      // wait for elementUpdated as web component may come with predefined styles in shadow dom\n      elementUpdated(el).then(() => {\n        if (!filterProperties && metaData && metaData.cssProperties) {\n          cssPropertiesToKnobs(el, elIndex, metaData.cssProperties, hasMultiple);\n        }\n      });\n\n      if (metaData) {\n        const defaultEventNames = ['click', 'focusin', 'focusout', 'keyup'];\n        const userEventNames = metaData.events ? metaData.events.map(item => item.name) : [];\n        const uniqueEventNames = [...new Set([...defaultEventNames, ...userEventNames])];\n        uniqueEventNames.forEach(evName => {\n          el.addEventListener(evName, () => {\n            syncElToKnobs(el, elIndex, metaData, hasMultiple, filterProperties);\n          });\n        });\n      }\n    });\n    return wrapper;\n  }\n\n  return storyFn();\n}\n"],"names":["String","Math","random","slice","options","window","addEventListener","removeEventListener","_e","nextFrame","Promise","resolve","requestAnimationFrame","push","isDefinedPromise","action","_typeof","el","hasSpecificAwait","update","updateComplete","componentOnReady","ShadyDOM","flush","Object","freeze","ELEMENT_NODE","TEXT_NODE","COMMENT_NODE","DOCUMENT_FRAGMENT_NODE","getType","meta","type","storybookKnobs","toLowerCase","getGroupName","index","defaultGroup","multiple","filterProperties","group","getLabel","elIndex","name","withWebComponentsKnobs","storyFn","data","customElements","__STORYBOOK_CUSTOM_ELEMENTS__","tagName","Error","isValidComponent","parameters","component","tags","Array","isArray","isValidMetaData","querySelectorAll","wrapper","document","createElement","render","wcTags","from","filter","node","includes","length","hasMultiple","forEach","metaData","find","tag","toUpperCase","properties","prop","propName","label","text","number","array","boolean","object","Date","date","propertiesToKnobs","elementUpdated","then","cssProperties","i","cssVariables","varMeta","cssName","value","defaultValue","getComputedStyle","getPropertyValue","color","style","setProperty","cssPropertiesToKnobs","userEventNames","events","map","item","Set","evName","property","knobsName","manager","knobStore","_mayCallChannel","syncElToKnobs"],"mappings":"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"}