"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.ChromeLauncherPage = void 0;
const test_runner_core_1 = require("@web/test-runner-core");
const test_runner_coverage_v8_1 = require("@web/test-runner-coverage-v8");
class ChromeLauncherPage {
    constructor(config, testFiles, product, puppeteerPage) {
        this.nativeInstrumentationEnabledOnPage = false;
        this.navigations = [];
        this.config = config;
        this.testFiles = testFiles;
        this.product = product;
        this.puppeteerPage = puppeteerPage;
        // track browser navigations
        puppeteerPage.on('request', e => {
            if (e.isNavigationRequest()) {
                this.navigations.push(new URL(e.url()));
            }
        });
    }
    async runSession(url, coverage) {
        var _a;
        this.testURL = new URL(url);
        this.navigations = [];
        if (coverage &&
            ((_a = this.config.coverageConfig) === null || _a === void 0 ? void 0 : _a.nativeInstrumentation) !== false &&
            this.product === 'chromium') {
            if (this.nativeInstrumentationEnabledOnPage) {
                await this.puppeteerPage.coverage.stopJSCoverage();
            }
            this.nativeInstrumentationEnabledOnPage = true;
            await this.puppeteerPage.coverage.startJSCoverage();
        }
        await this.puppeteerPage.setViewport({ height: 600, width: 800 });
        await this.puppeteerPage.goto(url);
    }
    async stopSession() {
        const errors = [];
        let testCoverage;
        // check if the page was navigated, resulting in broken tests
        const navigationError = test_runner_core_1.getBrowserPageNavigationError(this.testURL, this.navigations);
        if (navigationError) {
            errors.push(navigationError);
        }
        else {
            testCoverage = await this.collectTestCoverage(this.config, this.testFiles);
        }
        // navigate to an empty page to kill any running code on the page, stopping timers and
        // breaking a potential endless reload loop
        await this.puppeteerPage.goto('data:,');
        return { testCoverage, errors };
    }
    async collectTestCoverage(config, testFiles) {
        var _a, _b, _c, _d, _e;
        const coverageFromBrowser = await this.puppeteerPage.evaluate(() => window.__coverage__);
        if (coverageFromBrowser) {
            // coverage was generated by JS, return that
            return coverageFromBrowser;
        }
        if (((_a = config.coverageConfig) === null || _a === void 0 ? void 0 : _a.nativeInstrumentation) === false) {
            throw new Error('Coverage is enabled with nativeInstrumentation disabled. ' +
                'Expected coverage provided in the browser as a global __coverage__ variable.' +
                'Use a plugin like babel-plugin-istanbul to generate the coverage, or enable native instrumentation.');
        }
        if (!this.nativeInstrumentationEnabledOnPage) {
            return undefined;
        }
        // get native coverage from puppeteer
        // TODO: this is using a private puppeteer API to grab v8 code coverage, this can be removed
        // when https://github.com/puppeteer/puppeteer/issues/2136 is resolved
        const response = (await this.puppeteerPage._client.send('Profiler.takePreciseCoverage'));
        // puppeteer already has the script sources available, remove this when above issue is resolved
        const scriptSources = (_d = (_c = (_b = this.puppeteerPage) === null || _b === void 0 ? void 0 : _b.coverage) === null || _c === void 0 ? void 0 : _c._jsCoverage) === null || _d === void 0 ? void 0 : _d._scriptSources;
        const v8Coverage = response.result
            // remove puppeteer specific scripts
            .filter(r => r.url && r.url !== '__puppeteer_evaluation_script__')
            // attach source code
            .map(r => (Object.assign(Object.assign({}, r), { source: scriptSources.get(r.scriptId) })));
        await ((_e = this.puppeteerPage.coverage) === null || _e === void 0 ? void 0 : _e.stopJSCoverage());
        this.nativeInstrumentationEnabledOnPage = false;
        return test_runner_coverage_v8_1.v8ToIstanbul(config, testFiles, v8Coverage);
    }
}
exports.ChromeLauncherPage = ChromeLauncherPage;
//# sourceMappingURL=ChromeLauncherPage.js.map