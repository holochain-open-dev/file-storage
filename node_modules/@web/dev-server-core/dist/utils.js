"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.getRequestFilePath = exports.getRequestBrowserPath = exports.isInlineScriptRequest = exports.getResponseBody = exports.RequestCancelledError = exports.getHtmlPath = exports.toFilePath = exports.toBrowserPath = void 0;
const is_stream_1 = __importDefault(require("is-stream"));
const get_stream_1 = __importDefault(require("get-stream"));
const isbinaryfile_1 = require("isbinaryfile");
const path_1 = __importDefault(require("path"));
const REGEXP_TO_BROWSER_PATH = new RegExp(path_1.default.sep === '\\' ? '\\\\' : path_1.default.sep, 'g');
const REGEXP_TO_FILE_PATH = new RegExp('/', 'g');
/**
 * Turns a file path into a path suitable for browsers, with a / as seperator.
 * @param {string} filePath
 * @returns {string}
 */
function toBrowserPath(filePath) {
    return filePath.replace(REGEXP_TO_BROWSER_PATH, '/');
}
exports.toBrowserPath = toBrowserPath;
/**
 * Transforms a file system path to a browser URL. For example windows uses `\` on the file system,
 * but it should use `/` in the browser.
 */
function toFilePath(browserPath) {
    return browserPath.replace(REGEXP_TO_FILE_PATH, path_1.default.sep);
}
exports.toFilePath = toFilePath;
function getHtmlPath(path) {
    return path.endsWith('/') ? `${path}index.html` : path;
}
exports.getHtmlPath = getHtmlPath;
class RequestCancelledError extends Error {
}
exports.RequestCancelledError = RequestCancelledError;
/**
 * Returns the context body as string or buffer, depending on the content type.
 * Response streams can only be read once, the response body is replaced with
 * the stream result.
 */
async function getResponseBody(ctx) {
    let requestCanceled = false;
    ctx.req.on('close', () => {
        requestCanceled = true;
    });
    if (Buffer.isBuffer(ctx.body)) {
        const contentLength = Number(ctx.response.get('content-length'));
        const canStringify = !(await isbinaryfile_1.isBinaryFile(ctx.body, contentLength));
        if (requestCanceled) {
            throw new RequestCancelledError();
        }
        if (canStringify) {
            ctx.body = ctx.body.toString();
        }
        return ctx.body;
    }
    if (typeof ctx.body === 'string') {
        return ctx.body;
    }
    if (is_stream_1.default(ctx.body)) {
        // a stream can only be read once, so after reading it assign
        // the string response to the body so that it can be accessed
        // again later
        try {
            const bodyBuffer = await get_stream_1.default.buffer(ctx.body);
            ctx.body = bodyBuffer;
            // recursive call will stringify the buffer
            return getResponseBody(ctx);
        }
        catch (error) {
            if (error instanceof RequestCancelledError) {
                throw error;
            }
            if (requestCanceled) {
                throw new RequestCancelledError();
            }
            throw error;
        }
    }
    return ctx.body;
}
exports.getResponseBody = getResponseBody;
function isInlineScriptRequest(ctx) {
    return ctx.url.includes(`inline-script-`) && ctx.URL.searchParams.has('source');
}
exports.isInlineScriptRequest = isInlineScriptRequest;
function getRequestBrowserPath(context) {
    // inline module requests have the source in a query string
    if (isInlineScriptRequest(context)) {
        return context.URL.searchParams.get('source');
    }
    return context.path;
}
exports.getRequestBrowserPath = getRequestBrowserPath;
function getRequestFilePath(context, rootDir) {
    const requestPath = getRequestBrowserPath(context);
    const filePath = toFilePath(requestPath);
    return path_1.default.join(rootDir, filePath);
}
exports.getRequestFilePath = getRequestFilePath;
//# sourceMappingURL=utils.js.map