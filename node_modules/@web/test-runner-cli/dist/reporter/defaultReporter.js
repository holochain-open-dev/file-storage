"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.defaultReporter = void 0;
const createSourceMapFunction_1 = require("../utils/createSourceMapFunction");
const reportTestFileResults_1 = require("./reportTestFileResults");
const getTestProgress_1 = require("./getTestProgress");
const createStackLocationRegExp_1 = require("../utils/createStackLocationRegExp");
function isBufferedLogger(logger) {
    return (typeof logger.logBufferedMessages === 'function' &&
        Array.isArray(logger.buffer));
}
function defaultReporter({ reportTestResults = true, reportTestProgress = true, } = {}) {
    let args;
    let favoriteBrowser;
    let stackLocationRegExp;
    let sourceMapFunction;
    return {
        start(_args) {
            var _a;
            args = _args;
            favoriteBrowser = (_a = args.browserNames.find(name => {
                const n = name.toLowerCase();
                return n.includes('chrome') || n.includes('chromium') || n.includes('firefox');
            })) !== null && _a !== void 0 ? _a : args.browserNames[0];
            stackLocationRegExp = createStackLocationRegExp_1.createStackLocationRegExp(args.config.protocol, args.config.hostname, args.config.port);
            sourceMapFunction = createSourceMapFunction_1.createSourceMapFunction(args.config.protocol, args.config.hostname, args.config.port);
        },
        onTestRunStarted({ testRun }) {
            if (testRun !== 0) {
                // create a new source map function to clear the cached source maps
                sourceMapFunction = createSourceMapFunction_1.createSourceMapFunction(args.config.protocol, args.config.hostname, args.config.port);
            }
        },
        async reportTestFileResults({ logger, sessionsForTestFile, testFile }) {
            if (!reportTestResults) {
                return undefined;
            }
            if (!isBufferedLogger(logger)) {
                throw new Error('Expected a BufferedLogger instance.');
            }
            return reportTestFileResults_1.reportTestFileResults(logger, testFile, args.browserNames, favoriteBrowser, args.config.rootDir, stackLocationRegExp, sessionsForTestFile, sourceMapFunction);
        },
        getTestProgress({ testRun, focusedTestFile, testCoverage }) {
            if (!reportTestProgress) {
                return [];
            }
            return getTestProgress_1.getTestProgressReport(args.config, {
                browserNames: args.browserNames,
                testRun,
                testFiles: args.testFiles,
                sessions: args.sessions,
                startTime: args.startTime,
                focusedTestFile,
                watch: args.config.watch,
                coverage: !!args.config.coverage,
                coverageConfig: args.config.coverageConfig,
                testCoverage,
            });
        },
    };
}
exports.defaultReporter = defaultReporter;
//# sourceMappingURL=defaultReporter.js.map