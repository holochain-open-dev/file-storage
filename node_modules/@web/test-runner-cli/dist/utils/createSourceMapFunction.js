"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.createSourceMapFunction = void 0;
const path_1 = require("path");
const convert_source_map_1 = __importDefault(require("convert-source-map"));
const source_map_1 = require("source-map");
const request_1 = require("./request");
const toFilePath_1 = require("./toFilePath");
async function getSourceMap(protocol, host, port, browserPath, filePath, userAgent) {
    // fetch the source code used by the browser, using the browser's user agent to
    // account for accurate transformation
    const { body } = await request_1.request({
        protocol,
        host,
        path: `/${encodeURI(browserPath)}`,
        port: String(port),
        method: 'GET',
        headers: { 'user-agent': userAgent },
    });
    // we couldn't retreive this file, this could be because it is a generated file
    // from a serer plugin which no longer exists
    if (!body)
        return null;
    return (
    // inline source map
    convert_source_map_1.default.fromSource(body) ||
        // external source map
        convert_source_map_1.default.fromMapFileSource(body, path_1.dirname(filePath)));
}
function resolveRelativeTo(relativeTo, path) {
    const dir = path_1.dirname(relativeTo);
    if (path.startsWith(dir)) {
        return path;
    }
    return path_1.join(dir, path);
}
function createSourceMapFunction(protocol, host, port) {
    const cachedSourceMaps = new Map();
    return async (browserPath, filePath, userAgent, line, column) => {
        var _a, _b;
        try {
            const cacheKey = `${filePath}${userAgent}`;
            const cached = cachedSourceMaps.get(cacheKey);
            // get the raw source map, from cache or new
            let sourceMap;
            if (cached === null || cached === void 0 ? void 0 : cached.sourceMap) {
                sourceMap = cached === null || cached === void 0 ? void 0 : cached.sourceMap;
            }
            else {
                sourceMap = await getSourceMap(protocol, host, port, browserPath, filePath, userAgent);
                if (!sourceMap)
                    return null;
                cachedSourceMaps.set(cacheKey, { sourceMap: sourceMap });
            }
            // if there is no line and column we're looking for just the associated file, for example
            // the test file itself has soruce maps. if this is a single file source map, we can return
            // that.
            if (typeof line !== 'number' && typeof column !== 'number') {
                const sources = sourceMap.getProperty('sources');
                if (sources && sources.length === 1) {
                    return { filePath: resolveRelativeTo(filePath, sources[0]) };
                }
                return null;
            }
            // do the actual source mapping
            let consumer;
            if (cached === null || cached === void 0 ? void 0 : cached.consumer) {
                consumer = cached.consumer;
            }
            else {
                consumer = await new source_map_1.SourceMapConsumer(sourceMap.sourcemap);
                cachedSourceMaps.get(cacheKey).consumer = consumer;
            }
            let originalPosition = consumer.originalPositionFor({
                line: line !== null && line !== void 0 ? line : 0,
                column: column !== null && column !== void 0 ? column : 0,
                bias: source_map_1.SourceMapConsumer.GREATEST_LOWER_BOUND,
            });
            if (originalPosition.line == null) {
                originalPosition = consumer.originalPositionFor({
                    line: line !== null && line !== void 0 ? line : 0,
                    column: column !== null && column !== void 0 ? column : 0,
                    bias: source_map_1.SourceMapConsumer.LEAST_UPPER_BOUND,
                });
            }
            if (originalPosition.line == null) {
                return null;
            }
            const newFilePath = toFilePath_1.toFilePath(originalPosition.source);
            return {
                filePath: resolveRelativeTo(filePath, newFilePath),
                line: (_a = originalPosition.line) !== null && _a !== void 0 ? _a : undefined,
                column: (_b = originalPosition.column) !== null && _b !== void 0 ? _b : undefined,
            };
        }
        catch (error) {
            console.error(error);
            return null;
        }
    };
}
exports.createSourceMapFunction = createSourceMapFunction;
//# sourceMappingURL=createSourceMapFunction.js.map