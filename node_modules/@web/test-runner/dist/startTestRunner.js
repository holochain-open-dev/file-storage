"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.startTestRunner = void 0;
const test_runner_cli_1 = require("@web/test-runner-cli");
const test_runner_chrome_1 = require("@web/test-runner-chrome");
const plugins_1 = require("@web/test-runner-commands/plugins");
const TestRunnerStartError_1 = require("./TestRunnerStartError");
const chalk_1 = __importDefault(require("chalk"));
const loadLauncher_1 = require("./loadLauncher");
const collectGroupConfigs_1 = require("./collectGroupConfigs");
const nodeResolvePlugin_1 = require("./nodeResolvePlugin");
const esbuildPlugin_1 = require("./esbuildPlugin");
const cliOptions = [
    {
        name: 'groups',
        type: String,
        description: 'Pattern of group config files.',
    },
    {
        name: 'group',
        type: String,
        description: 'Name of the group to run tests for. When this is set, the other groups are ignored.',
    },
    {
        name: 'node-resolve',
        type: Boolean,
        description: 'Resolve bare module imports using node resolution',
    },
    {
        name: 'preserve-symlinks',
        type: Boolean,
        description: "Don't follow symlinks when resolving imports",
    },
    {
        name: 'puppeteer',
        type: Boolean,
        description: 'Run tests using puppeteer',
    },
    {
        name: 'playwright',
        type: Boolean,
        description: 'Run tests using playwright',
    },
    {
        name: 'browsers',
        type: String,
        multiple: true,
        description: 'Browsers to run when choosing puppeteer or playwright',
    },
    {
        name: 'esbuild-target',
        type: String,
        multiple: true,
        description: 'JS language target to compile down to using esbuild. Recommended value is "auto", which compiles based on user agent. Check the docs for more options.',
    },
    {
        name: 'debug',
        type: Boolean,
        description: 'Log debug messages',
    },
];
async function startTestRunner(options = {}) {
    var _a;
    const { autoExitProcess = true, argv = process.argv } = options;
    try {
        const cliArgs = test_runner_cli_1.readCliArgsConfig(cliOptions, argv);
        const cliArgsConfig = {};
        for (const [key, value] of Object.entries(cliArgs)) {
            if (key !== 'browsers') {
                // cli args are read from a file, they are validated by cli-options and later on as well
                cliArgsConfig[key] = value;
            }
        }
        const config = await test_runner_cli_1.readConfig(cliArgsConfig);
        const { rootDir } = config;
        let groupConfigs = [];
        if (config.groups) {
            const configPatterns = [];
            for (const entry of typeof config.groups === 'string' ? [config.groups] : config.groups) {
                if (typeof entry === 'object') {
                    groupConfigs.push(entry);
                }
                else {
                    configPatterns.push(entry);
                }
            }
            // group entries which are strings are globs which point to group conigs
            groupConfigs.push(...(await collectGroupConfigs_1.collectGroupConfigs(configPatterns)));
        }
        if (cliArgs.group != null) {
            const groupConfig = groupConfigs.find(c => c.name === cliArgs.group);
            if (!groupConfig) {
                throw new TestRunnerStartError_1.TestRunnerStartError(`Could not find any group named ${cliArgs.group}`);
            }
            groupConfigs = [groupConfig];
        }
        if (cliArgs.puppeteer) {
            if (config.browsers && config.browsers.length > 0) {
                throw new TestRunnerStartError_1.TestRunnerStartError('The --puppeteer flag cannot be used when defining browsers manually in your config.');
            }
            config.browsers = loadLauncher_1.puppeteerLauncher(cliArgs.browsers);
        }
        else if (cliArgs.playwright) {
            if (config.browsers && config.browsers.length > 0) {
                throw new TestRunnerStartError_1.TestRunnerStartError('The --playwright flag cannot be used when defining browsers manually in your config.');
            }
            config.browsers = loadLauncher_1.playwrightLauncher(cliArgs.browsers);
        }
        else {
            if (cliArgs.browsers != null) {
                throw new TestRunnerStartError_1.TestRunnerStartError(`The browsers option must be used along with the puppeteer or playwright option.`);
            }
            // add default chrome launcher if the user did not configure their own browsers
            if (!config.browsers) {
                config.browsers = [test_runner_chrome_1.chromeLauncher()];
            }
        }
        if (typeof rootDir !== 'string') {
            throw new TestRunnerStartError_1.TestRunnerStartError('No rootDir specified.');
        }
        config.testFramework = Object.assign({ path: require.resolve('@web/test-runner-mocha/dist/autorun.js') }, ((_a = config.testFramework) !== null && _a !== void 0 ? _a : {}));
        if (!config.reporters) {
            config.reporters = [test_runner_cli_1.defaultReporter()];
        }
        if (config.plugins == null) {
            config.plugins = [];
        }
        if (config.esbuildTarget) {
            config.plugins.push(esbuildPlugin_1.esbuildPlugin(config.esbuildTarget));
        }
        if (config.nodeResolve) {
            const userOptions = typeof config.nodeResolve === 'object' ? config.nodeResolve : undefined;
            config.plugins.push(nodeResolvePlugin_1.nodeResolvePlugin(rootDir, config.preserveSymlinks, userOptions));
        }
        // plugin with a noop transformImport hook, this will cause the dev server to analyze modules and
        // catch syntax errors. this way we still report syntax errors when the user has no flags enabled
        config.plugins.push({
            name: 'syntax-checker',
            transformImport() {
                return undefined;
            },
        });
        config.plugins.push(plugins_1.setViewportPlugin(), plugins_1.emulateMediaPlugin(), plugins_1.setUserAgentPlugin());
        const validatedConfig = test_runner_cli_1.validateCoreConfig(config);
        return test_runner_cli_1.startTestRunner(validatedConfig, groupConfigs, { autoExitProcess });
    }
    catch (error) {
        if (error instanceof TestRunnerStartError_1.TestRunnerStartError) {
            console.error(chalk_1.default.red(`\nFailed to start test runner: ${error.message}\n`));
        }
        else {
            console.error(error);
        }
        if (autoExitProcess) {
            process.exit(1);
        }
        else {
            throw error;
        }
    }
}
exports.startTestRunner = startTestRunner;
//# sourceMappingURL=startTestRunner.js.map