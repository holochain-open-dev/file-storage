'use strict';

var tsModule = require('typescript');
var tsSimpleType = require('ts-simple-type');
var path = require('path');

/*! *****************************************************************************
Copyright (c) Microsoft Corporation.

Permission to use, copy, modify, and/or distribute this software for any
purpose with or without fee is hereby granted.

THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH
REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY
AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,
INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM
LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR
OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
PERFORMANCE OF THIS SOFTWARE.
***************************************************************************** */

exports.__assign = function() {
    exports.__assign = Object.assign || function __assign(t) {
        for (var s, i = 1, n = arguments.length; i < n; i++) {
            s = arguments[i];
            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p)) t[p] = s[p];
        }
        return t;
    };
    return exports.__assign.apply(this, arguments);
};

function __awaiter(thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
}

function __generator(thisArg, body) {
    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;
    return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() { return this; }), g;
    function verb(n) { return function (v) { return step([n, v]); }; }
    function step(op) {
        if (f) throw new TypeError("Generator is already executing.");
        while (_) try {
            if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;
            if (y = 0, t) op = [op[0] & 2, t.value];
            switch (op[0]) {
                case 0: case 1: t = op; break;
                case 4: _.label++; return { value: op[1], done: false };
                case 5: _.label++; y = op[1]; op = [0]; continue;
                case 7: op = _.ops.pop(); _.trys.pop(); continue;
                default:
                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }
                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }
                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }
                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }
                    if (t[2]) _.ops.pop();
                    _.trys.pop(); continue;
            }
            op = body.call(thisArg, _);
        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }
        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };
    }
}

function __values(o) {
    var s = typeof Symbol === "function" && Symbol.iterator, m = s && o[s], i = 0;
    if (m) return m.call(o);
    if (o && typeof o.length === "number") return {
        next: function () {
            if (o && i >= o.length) o = void 0;
            return { value: o && o[i++], done: !o };
        }
    };
    throw new TypeError(s ? "Object is not iterable." : "Symbol.iterator is not defined.");
}

function __read(o, n) {
    var m = typeof Symbol === "function" && o[Symbol.iterator];
    if (!m) return o;
    var i = m.call(o), r, ar = [], e;
    try {
        while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);
    }
    catch (error) { e = { error: error }; }
    finally {
        try {
            if (r && !r.done && (m = i["return"])) m.call(i);
        }
        finally { if (e) throw e.error; }
    }
    return ar;
}

function __spread() {
    for (var ar = [], i = 0; i < arguments.length; i++)
        ar = ar.concat(__read(arguments[i]));
    return ar;
}

/**
 * Takes a node and tries to resolve a constant value from it.
 * Returns undefined if no constant value can be resolved.
 * @param node
 * @param context
 */
function resolveNodeValue(node, context) {
    var e_1, _a, e_2, _b;
    var _c, _d;
    if (node == null)
        return undefined;
    var ts = context.ts, checker = context.checker;
    var depth = (context.depth || 0) + 1;
    // Always break when depth is larger than 10.
    // This ensures we cannot run into infinite recursion.
    if (depth > 10)
        return undefined;
    if (ts.isStringLiteralLike(node)) {
        return { value: node.text, node: node };
    }
    else if (ts.isNumericLiteral(node)) {
        return { value: Number(node.text), node: node };
    }
    else if (ts.isPrefixUnaryExpression(node)) {
        var value = (_c = resolveNodeValue(node.operand, exports.__assign(exports.__assign({}, context), { depth: depth }))) === null || _c === void 0 ? void 0 : _c.value;
        return { value: applyPrefixUnaryOperatorToValue(value, node.operator, ts), node: node };
    }
    else if (ts.isObjectLiteralExpression(node)) {
        var object = {};
        try {
            for (var _e = __values(node.properties), _f = _e.next(); !_f.done; _f = _e.next()) {
                var prop = _f.value;
                if (ts.isPropertyAssignment(prop)) {
                    // Resolve the "key"
                    var name_1 = ((_d = resolveNodeValue(prop.name, exports.__assign(exports.__assign({}, context), { depth: depth }))) === null || _d === void 0 ? void 0 : _d.value) || prop.name.getText();
                    // Resolve the "value
                    var resolvedValue = resolveNodeValue(prop.initializer, exports.__assign(exports.__assign({}, context), { depth: depth }));
                    if (resolvedValue != null && typeof name_1 === "string") {
                        object[name_1] = resolvedValue.value;
                    }
                }
            }
        }
        catch (e_1_1) { e_1 = { error: e_1_1 }; }
        finally {
            try {
                if (_f && !_f.done && (_a = _e.return)) _a.call(_e);
            }
            finally { if (e_1) throw e_1.error; }
        }
        return {
            value: object,
            node: node
        };
    }
    else if (node.kind === ts.SyntaxKind.TrueKeyword) {
        return { value: true, node: node };
    }
    else if (node.kind === ts.SyntaxKind.FalseKeyword) {
        return { value: false, node: node };
    }
    else if (node.kind === ts.SyntaxKind.NullKeyword) {
        return { value: null, node: node };
    }
    else if (node.kind === ts.SyntaxKind.UndefinedKeyword) {
        return { value: undefined, node: node };
    }
    // Resolve initializers for variable declarations
    if (ts.isVariableDeclaration(node)) {
        return resolveNodeValue(node.initializer, exports.__assign(exports.__assign({}, context), { depth: depth }));
    }
    // Resolve value of a property access expression. For example: MyEnum.RED
    else if (ts.isPropertyAccessExpression(node)) {
        return resolveNodeValue(node.name, exports.__assign(exports.__assign({}, context), { depth: depth }));
    }
    // Resolve [expression] parts of {[expression]: "value"}
    else if (ts.isComputedPropertyName(node)) {
        return resolveNodeValue(node.expression, exports.__assign(exports.__assign({}, context), { depth: depth }));
    }
    // Resolve initializer value of enum members.
    else if (ts.isEnumMember(node)) {
        if (node.initializer != null) {
            return resolveNodeValue(node.initializer, exports.__assign(exports.__assign({}, context), { depth: depth }));
        }
        else {
            return { value: node.parent.name.text + "." + node.name.getText(), node: node };
        }
    }
    // Resolve values of variables.
    else if (ts.isIdentifier(node) && checker != null) {
        var declarations = resolveDeclarations(node, { checker: checker, ts: ts });
        if (declarations.length > 0) {
            var resolved = resolveNodeValue(declarations[0], exports.__assign(exports.__assign({}, context), { depth: depth }));
            if (context.strict || resolved != null) {
                return resolved;
            }
        }
        if (context.strict) {
            return undefined;
        }
        return { value: node.getText(), node: node };
    }
    // Fallthrough
    //  - "my-value" as string
    //  - <any>"my-value"
    //  - ("my-value")
    else if (ts.isAsExpression(node) || ts.isTypeAssertion(node) || ts.isParenthesizedExpression(node)) {
        return resolveNodeValue(node.expression, exports.__assign(exports.__assign({}, context), { depth: depth }));
    }
    // static get is() {
    //    return "my-element";
    // }
    else if ((ts.isGetAccessor(node) || ts.isMethodDeclaration(node) || ts.isFunctionDeclaration(node)) && node.body != null) {
        try {
            for (var _g = __values(node.body.statements), _h = _g.next(); !_h.done; _h = _g.next()) {
                var stm = _h.value;
                if (ts.isReturnStatement(stm)) {
                    return resolveNodeValue(stm.expression, exports.__assign(exports.__assign({}, context), { depth: depth }));
                }
            }
        }
        catch (e_2_1) { e_2 = { error: e_2_1 }; }
        finally {
            try {
                if (_h && !_h.done && (_b = _g.return)) _b.call(_g);
            }
            finally { if (e_2) throw e_2.error; }
        }
    }
    // [1, 2]
    else if (ts.isArrayLiteralExpression(node)) {
        return {
            node: node,
            value: node.elements.map(function (el) { var _a; return (_a = resolveNodeValue(el, exports.__assign(exports.__assign({}, context), { depth: depth }))) === null || _a === void 0 ? void 0 : _a.value; })
        };
    }
    return undefined;
}
// eslint-disable-next-line @typescript-eslint/no-explicit-any
function applyPrefixUnaryOperatorToValue(value, operator, ts) {
    if (typeof value === "object" && value != null) {
        return value;
    }
    switch (operator) {
        case ts.SyntaxKind.MinusToken:
            return -value;
        case ts.SyntaxKind.ExclamationToken:
            return !value;
        case ts.SyntaxKind.PlusToken:
            return +value;
    }
    return value;
}

/**
 * Converts from snake case to camel case
 * @param str
 */
/**
 * Converts from camel case to snake case
 * @param str
 */
function camelToDashCase(str) {
    return str.replace(/[A-Z]/g, function (m) { return "-" + m.toLowerCase(); });
}
/**
 * Returns if a name is private (starts with "_" or "#");
 * @param name	 * @param name
 */
function isNamePrivate(name) {
    return name.startsWith("_") || name.startsWith("#");
}

/**
 * Resolves all relevant declarations of a specific node.
 * @param node
 * @param context
 */
function resolveDeclarations(node, context) {
    if (node == null)
        return [];
    var symbol = getSymbol(node, context);
    if (symbol == null)
        return [];
    return resolveSymbolDeclarations(symbol);
}
/**
 * Returns the symbol of a node.
 * This function follows aliased symbols.
 * @param node
 * @param context
 */
function getSymbol(node, context) {
    if (node == null)
        return undefined;
    var checker = context.checker, ts = context.ts;
    // Get the symbol
    var symbol = checker.getSymbolAtLocation(node);
    if (symbol == null) {
        var identifier = getNodeIdentifier(node, context);
        symbol = identifier != null ? checker.getSymbolAtLocation(identifier) : undefined;
    }
    // Resolve aliased symbols
    if (symbol != null && isAliasSymbol(symbol, ts)) {
        symbol = checker.getAliasedSymbol(symbol);
        if (symbol == null)
            return undefined;
    }
    return symbol;
}
/**
 * Resolves the declarations of a symbol. A valueDeclaration is always the first entry in the array
 * @param symbol
 */
function resolveSymbolDeclarations(symbol) {
    // Filters all declarations
    var valueDeclaration = symbol.valueDeclaration;
    var declarations = symbol.getDeclarations() || [];
    if (valueDeclaration == null) {
        return declarations;
    }
    else {
        // Make sure that "valueDeclaration" is always the first entry
        return __spread([valueDeclaration], declarations.filter(function (decl) { return decl !== valueDeclaration; }));
    }
}
/**
 * Resolve a declaration by trying to find the real value by following assignments.
 * @param node
 * @param context
 */
function resolveDeclarationsDeep(node, context) {
    var e_1, _a;
    var declarations = [];
    var allDeclarations = resolveDeclarations(node, context);
    try {
        for (var allDeclarations_1 = __values(allDeclarations), allDeclarations_1_1 = allDeclarations_1.next(); !allDeclarations_1_1.done; allDeclarations_1_1 = allDeclarations_1.next()) {
            var declaration = allDeclarations_1_1.value;
            if (context.ts.isVariableDeclaration(declaration) && declaration.initializer != null && context.ts.isIdentifier(declaration.initializer)) {
                declarations.push.apply(declarations, __spread(resolveDeclarationsDeep(declaration.initializer, context)));
            }
            else if (context.ts.isTypeAliasDeclaration(declaration) && declaration.type != null && context.ts.isIdentifier(declaration.type)) {
                declarations.push.apply(declarations, __spread(resolveDeclarationsDeep(declaration.type, context)));
            }
            else {
                declarations.push(declaration);
            }
        }
    }
    catch (e_1_1) { e_1 = { error: e_1_1 }; }
    finally {
        try {
            if (allDeclarations_1_1 && !allDeclarations_1_1.done && (_a = allDeclarations_1.return)) _a.call(allDeclarations_1);
        }
        finally { if (e_1) throw e_1.error; }
    }
    return declarations;
}
/**
 * Returns if the symbol has "alias" flag
 * @param symbol
 * @param ts
 */
function isAliasSymbol(symbol, ts) {
    return hasFlag(symbol.flags, ts.SymbolFlags.Alias);
}
/**
 * Returns a set of modifiers on a node
 * @param node
 * @param ts
 */
function getModifiersFromNode(node, ts) {
    var modifiers = new Set();
    if (hasModifier(node, ts.SyntaxKind.ReadonlyKeyword)) {
        modifiers.add("readonly");
    }
    if (hasModifier(node, ts.SyntaxKind.StaticKeyword)) {
        modifiers.add("static");
    }
    if (ts.isGetAccessor(node)) {
        modifiers.add("readonly");
    }
    return modifiers.size > 0 ? modifiers : undefined;
}
/**
 * Returns if a number has a flag
 * @param num
 * @param flag
 */
function hasFlag(num, flag) {
    return (num & flag) !== 0;
}
/**
 * Returns if a node has a specific modifier.
 * @param node
 * @param modifierKind
 */
function hasModifier(node, modifierKind) {
    if (node.modifiers == null)
        return false;
    return (node.modifiers || []).find(function (modifier) { return modifier.kind === modifierKind; }) != null;
}
/**
 * Returns the visibility of a node
 */
function getMemberVisibilityFromNode(node, ts) {
    if (hasModifier(node, ts.SyntaxKind.PrivateKeyword) || ("name" in node && ts.isIdentifier(node.name) && isNamePrivate(node.name.text))) {
        return "private";
    }
    else if (hasModifier(node, ts.SyntaxKind.ProtectedKeyword)) {
        return "protected";
    }
    else if (getNodeSourceFileLang(node) === "ts") {
        // Only return "public" in typescript land
        return "public";
    }
    return undefined;
}
/**
 * Returns all keys and corresponding interface/class declarations for keys in an interface.
 * @param interfaceDeclaration
 * @param context
 */
function getInterfaceKeys(interfaceDeclaration, context) {
    var e_2, _a;
    var extensions = [];
    var ts = context.ts;
    try {
        for (var _b = __values(interfaceDeclaration.members), _c = _b.next(); !_c.done; _c = _b.next()) {
            var member = _c.value;
            // { "my-button": MyButton; }
            if (ts.isPropertySignature(member) && member.type != null) {
                var resolvedKey = resolveNodeValue(member.name, context);
                if (resolvedKey == null) {
                    continue;
                }
                var identifier = void 0;
                var declaration = void 0;
                if (ts.isTypeReferenceNode(member.type)) {
                    // { ____: MyButton; } or { ____: namespace.MyButton; }
                    identifier = member.type.typeName;
                }
                else if (ts.isTypeLiteralNode(member.type)) {
                    identifier = undefined;
                    declaration = member.type;
                }
                else {
                    continue;
                }
                if (declaration != null || identifier != null) {
                    extensions.push({ key: String(resolvedKey.value), keyNode: resolvedKey.node, declaration: declaration, identifier: identifier });
                }
            }
        }
    }
    catch (e_2_1) { e_2 = { error: e_2_1 }; }
    finally {
        try {
            if (_c && !_c.done && (_a = _b.return)) _a.call(_b);
        }
        finally { if (e_2) throw e_2.error; }
    }
    return extensions;
}
/**
 * Find a node recursively walking up the tree using parent nodes.
 * @param node
 * @param test
 */
function findParent(node, test) {
    if (node == null)
        return;
    return test(node) ? node : findParent(node.parent, test);
}
/**
 * Find a node recursively walking down the children of the tree. Depth first search.
 * @param node
 * @param test
 */
function findChild(node, test) {
    if (!node)
        return;
    if (test(node))
        return node;
    return node.forEachChild(function (child) { return findChild(child, test); });
}
/**
 * Find multiple children by walking down the children of the tree. Depth first search.
 * @param node
 * @param test
 * @param emit
 */
function findChildren(node, test, emit) {
    if (!node)
        return;
    if (test(node)) {
        emit(node);
    }
    node.forEachChild(function (child) { return findChildren(child, test, emit); });
}
/**
 * Returns the language of the node's source file
 * @param node
 */
function getNodeSourceFileLang(node) {
    return node.getSourceFile().fileName.endsWith("ts") ? "ts" : "js";
}
/**
 * Returns the leading comment for a given node
 * @param node
 * @param ts
 */
function getLeadingCommentForNode(node, ts) {
    var sourceFileText = node.getSourceFile().text;
    var leadingComments = ts.getLeadingCommentRanges(sourceFileText, node.pos);
    if (leadingComments != null && leadingComments.length > 0) {
        return sourceFileText.substring(leadingComments[0].pos, leadingComments[0].end);
    }
    return undefined;
}
/**
 * Returns the declaration name of a given node if possible.
 * @param node
 * @param context
 */
function getNodeName(node, context) {
    var _a;
    return (_a = getNodeIdentifier(node, context)) === null || _a === void 0 ? void 0 : _a.getText();
}
/**
 * Returns the declaration name of a given node if possible.
 * @param node
 * @param context
 */
function getNodeIdentifier(node, context) {
    if (context.ts.isIdentifier(node)) {
        return node;
    }
    else if ((context.ts.isClassLike(node) ||
        context.ts.isInterfaceDeclaration(node) ||
        context.ts.isVariableDeclaration(node) ||
        context.ts.isMethodDeclaration(node) ||
        context.ts.isPropertyDeclaration(node) ||
        context.ts.isFunctionDeclaration(node)) &&
        node.name != null &&
        context.ts.isIdentifier(node.name)) {
        return node.name;
    }
    return undefined;
}

/**
 * Visits custom element definitions.
 * @param node
 * @param ts
 * @param checker
 */
function discoverDefinitions(node, _a) {
    var ts = _a.ts, checker = _a.checker;
    // customElements.define("my-element", MyElement)
    if (ts.isCallExpression(node)) {
        if (ts.isPropertyAccessExpression(node.expression) && node.expression.name.escapedText === "define") {
            var leftExpression = node.expression.expression;
            // Take "window.customElements" into account and return the "customElements" part
            if (ts.isPropertyAccessExpression(leftExpression) &&
                ts.isIdentifier(leftExpression.expression) &&
                leftExpression.expression.escapedText === "window") {
                leftExpression = leftExpression.name;
            }
            // Check if the "left expression" is called "customElements"
            if (ts.isIdentifier(leftExpression) &&
                leftExpression.escapedText === "customElements" &&
                node.expression.name != null &&
                ts.isIdentifier(node.expression.name)) {
                // Find the arguments of: define("my-element", MyElement)
                var _b = __read(node.arguments, 2), unresolvedTagNameNode = _b[0], identifierNode = _b[1];
                // Resolve the tag name node
                // ("my-element", MyElement)
                var resolvedTagNameNode = resolveNodeValue(unresolvedTagNameNode, { ts: ts, checker: checker, strict: true });
                if (resolvedTagNameNode != null && identifierNode != null && typeof resolvedTagNameNode.value === "string") {
                    var tagName = resolvedTagNameNode.value;
                    var tagNameNode = resolvedTagNameNode.node;
                    // (___, MyElement)
                    if (ts.isIdentifier(identifierNode)) {
                        return [
                            {
                                tagName: tagName,
                                identifierNode: identifierNode,
                                tagNameNode: tagNameNode
                            }
                        ];
                    }
                    // (___, class { ... })
                    else if (ts.isClassLike(identifierNode) || ts.isInterfaceDeclaration(identifierNode)) {
                        return [
                            {
                                tagName: tagName,
                                tagNameNode: tagNameNode,
                                declarationNode: identifierNode
                            }
                        ];
                    }
                }
            }
        }
        return undefined;
    }
    // interface HTMLElementTagNameMap { "my-button": MyButton; }
    if (ts.isInterfaceDeclaration(node) && ["HTMLElementTagNameMap", "ElementTagNameMap"].includes(node.name.text)) {
        var extensions = getInterfaceKeys(node, { ts: ts, checker: checker });
        return extensions.map(function (_a) {
            var key = _a.key, keyNode = _a.keyNode, identifier = _a.identifier, declaration = _a.declaration;
            return ({
                tagName: key,
                tagNameNode: keyNode,
                identifierNode: identifier,
                declarationNode: declaration
            });
        });
    }
    return undefined;
}

/**
 * Flattens an array.
 * Use this function to keep support for node 10
 * @param items
 */
function arrayFlat(items) {
    var e_1, _a;
    // eslint-disable-next-line @typescript-eslint/no-explicit-any
    if ("flat" in items) {
        // eslint-disable-next-line @typescript-eslint/no-explicit-any
        return items.flat();
    }
    var flattenArray = [];
    try {
        for (var items_1 = __values(items), items_1_1 = items_1.next(); !items_1_1.done; items_1_1 = items_1.next()) {
            var item = items_1_1.value;
            flattenArray.push.apply(flattenArray, __spread(item));
        }
    }
    catch (e_1_1) { e_1 = { error: e_1_1 }; }
    finally {
        try {
            if (items_1_1 && !items_1_1.done && (_a = items_1.return)) _a.call(items_1);
        }
        finally { if (e_1) throw e_1.error; }
    }
    return flattenArray;
}
/**
 * Filters an array returning only defined items
 * @param array
 */
function arrayDefined(array) {
    return array.filter(function (item) { return item != null; });
}
/**
 * Filters an array returning only unique itesm
 * @param array
 */
function arrayDedupe(array) {
    var e_2, _a;
    var uniqueItems = [];
    try {
        for (var array_1 = __values(array), array_1_1 = array_1.next(); !array_1_1.done; array_1_1 = array_1.next()) {
            var item = array_1_1.value;
            if (uniqueItems.indexOf(item) === -1) {
                uniqueItems.push(item);
            }
        }
    }
    catch (e_2_1) { e_2 = { error: e_2_1 }; }
    finally {
        try {
            if (array_1_1 && !array_1_1.done && (_a = array_1.return)) _a.call(array_1);
        }
        finally { if (e_2) throw e_2.error; }
    }
    return uniqueItems;
}

var NOTHING = Symbol();
/**
 * This function wraps a callback returning a value and cahced the value.
 * @param callback
 */
function lazy(callback) {
    var value = NOTHING;
    return function () {
        if (value === NOTHING) {
            value = callback();
        }
        return value;
    };
}

/**
 * Relax the type so that for example "string literal" become "string" and "function" become "any"
 * This is used for javascript files to provide type checking with Typescript type inferring
 * @param type
 */
function relaxType(type) {
    switch (type.kind) {
        case "INTERSECTION":
        case "UNION":
            return exports.__assign(exports.__assign({}, type), { types: type.types.map(function (t) { return relaxType(t); }) });
        case "ENUM":
            return exports.__assign(exports.__assign({}, type), { types: type.types.map(function (t) { return relaxType(t); }) });
        case "ARRAY":
            return exports.__assign(exports.__assign({}, type), { type: relaxType(type.type) });
        case "PROMISE":
            return exports.__assign(exports.__assign({}, type), { type: relaxType(type.type) });
        case "OBJECT":
            return {
                name: type.name,
                kind: "OBJECT"
            };
        case "INTERFACE":
        case "FUNCTION":
        case "CLASS":
            return {
                name: type.name,
                kind: "ANY"
            };
        case "NUMBER_LITERAL":
            return { kind: "NUMBER" };
        case "STRING_LITERAL":
            return { kind: "STRING" };
        case "BOOLEAN_LITERAL":
            return { kind: "BOOLEAN" };
        case "BIG_INT_LITERAL":
            return { kind: "BIG_INT" };
        case "ENUM_MEMBER":
            return exports.__assign(exports.__assign({}, type), { type: relaxType(type.type) });
        case "ALIAS":
            return exports.__assign(exports.__assign({}, type), { target: relaxType(type.target) });
        case "NULL":
        case "UNDEFINED":
            return { kind: "ANY" };
        default:
            return type;
    }
}
// Only search in "lib.dom.d.ts" performance reasons for now
var LIB_FILE_NAMES = ["lib.dom.d.ts"];
// Map "tsModule => name => SimpleType"
var LIB_TYPE_CACHE = new Map();
/**
 * Return a Typescript library type with a specific name
 * @param name
 * @param ts
 * @param program
 */
function getLibTypeWithName(name, _a) {
    var e_1, _b;
    var ts = _a.ts, program = _a.program;
    var nameTypeCache = LIB_TYPE_CACHE.get(ts) || new Map();
    if (nameTypeCache.has(name)) {
        return nameTypeCache.get(name);
    }
    else {
        LIB_TYPE_CACHE.set(ts, nameTypeCache);
    }
    var node;
    var _loop_1 = function (libFileName) {
        var e_2, _a;
        var sourceFile = program.getSourceFile(libFileName) || program.getSourceFiles().find(function (f) { return f.fileName.endsWith(libFileName); });
        if (sourceFile == null) {
            return "continue";
        }
        try {
            for (var _b = (e_2 = void 0, __values(sourceFile.statements)), _c = _b.next(); !_c.done; _c = _b.next()) {
                var statement = _c.value;
                if (ts.isInterfaceDeclaration(statement) && ((_c = statement.name) === null || _c === void 0 ? void 0 : _c.text) === name) {
                    node = statement;
                    break;
                }
            }
        }
        catch (e_2_1) { e_2 = { error: e_2_1 }; }
        finally {
            try {
                if (_c && !_c.done && (_a = _b.return)) _a.call(_b);
            }
            finally { if (e_2) throw e_2.error; }
        }
        if (node != null) {
            return "break";
        }
    };
    try {
        for (var LIB_FILE_NAMES_1 = __values(LIB_FILE_NAMES), LIB_FILE_NAMES_1_1 = LIB_FILE_NAMES_1.next(); !LIB_FILE_NAMES_1_1.done; LIB_FILE_NAMES_1_1 = LIB_FILE_NAMES_1.next()) {
            var libFileName = LIB_FILE_NAMES_1_1.value;
            var state_1 = _loop_1(libFileName);
            if (state_1 === "break")
                break;
        }
    }
    catch (e_1_1) { e_1 = { error: e_1_1 }; }
    finally {
        try {
            if (LIB_FILE_NAMES_1_1 && !LIB_FILE_NAMES_1_1.done && (_b = LIB_FILE_NAMES_1.return)) _b.call(LIB_FILE_NAMES_1);
        }
        finally { if (e_1) throw e_1.error; }
    }
    var checker = program.getTypeChecker();
    var type = node == null ? undefined : tsSimpleType.toSimpleType(node, checker);
    if (type != null) {
        // Apparently Typescript wraps the type in "generic arguments" when take the type from the interface declaration
        // Remove "generic arguments" here
        if (type.kind === "GENERIC_ARGUMENTS") {
            type = type.target;
        }
    }
    nameTypeCache.set(name, type);
    return type;
}

/**
 * Returns typescript jsdoc node for a given node
 * @param node
 * @param ts
 */
function getJSDocNode(node, ts) {
    var _a, _b, _c;
    var parent = (_b = (_a = ts.getJSDocTags(node)) === null || _a === void 0 ? void 0 : _a[0]) === null || _b === void 0 ? void 0 : _b.parent;
    if (parent != null && ts.isJSDoc(parent)) {
        return parent;
    }
    // eslint-disable-next-line @typescript-eslint/no-explicit-any
    return (_c = node.jsDoc) === null || _c === void 0 ? void 0 : _c.find(function (n) { return ts.isJSDoc(n); });
}
/**
 * Returns jsdoc for a given node.
 * @param node
 * @param ts
 * @param tagNames
 */
function getJsDoc(node, ts, tagNames) {
    var _a;
    var jsDocNode = getJSDocNode(node, ts);
    // If we couldn't find jsdoc, find and parse the jsdoc string ourselves
    if (jsDocNode == null) {
        var leadingComment = getLeadingCommentForNode(node, ts);
        if (leadingComment != null) {
            var jsDoc = parseJsDocString(leadingComment);
            // Return this jsdoc if we don't have to filter by tag name
            if (jsDoc == null || tagNames == null || tagNames.length === 0) {
                return jsDoc;
            }
            return exports.__assign(exports.__assign({}, jsDoc), { tags: (_a = jsDoc.tags) === null || _a === void 0 ? void 0 : _a.filter(function (t) { return tagNames.includes(t.tag); }) });
        }
        return undefined;
    }
    // Parse all jsdoc tags
    // Typescript removes some information after parsing jsdoc tags, so unfortunately we will have to parse.
    return {
        description: jsDocNode.comment == null ? undefined : unescapeJSDoc(String(jsDocNode.comment)),
        node: jsDocNode,
        tags: jsDocNode.tags == null
            ? []
            : arrayDefined(jsDocNode.tags.map(function (node) {
                var _a, _b, _c;
                var tag = String(node.tagName.escapedText);
                // Filter by tag name
                if (tagNames != null && tagNames.length > 0 && !tagNames.includes(tag.toLowerCase())) {
                    return undefined;
                }
                // If Typescript generated a "type expression" or "name", comment will not include those.
                // We can't just use what typescript parsed because it doesn't include things like optional jsdoc: name notation [...]
                // Therefore we need to manually get the text and remove newlines/*
                var typeExpressionPart = "typeExpression" in node ? (_a = node.typeExpression) === null || _a === void 0 ? void 0 : _a.getText() : undefined;
                var namePart = "name" in node ? (_b = node.name) === null || _b === void 0 ? void 0 : _b.getText() : undefined;
                var fullComment = (typeExpressionPart === null || typeExpressionPart === void 0 ? void 0 : typeExpressionPart.startsWith("@")) ? // To make matters worse, if Typescript can't parse a certain jsdoc, it will include the rest of the jsdocs tag from there in "typeExpressionPart"
                    // Therefore we check if there are multiple jsdoc tags in the string to only take the first one
                    // This will discard the following jsdocs, but at least we don't crash :-)
                    typeExpressionPart.split(/\n\s*\*\s?@/)[0] || ""
                    : "@" + tag + (typeExpressionPart != null ? " " + typeExpressionPart + " " : "") + (namePart != null ? " " + namePart + " " : "") + " " + (node.comment || "");
                return {
                    node: node,
                    tag: tag,
                    comment: (_c = node.comment) === null || _c === void 0 ? void 0 : _c.replace(/^\s*-\s*/, "").trim(),
                    parsed: lazy(function () { return parseJsDocTagString(fullComment); })
                };
            }))
    };
}
/**
 * Converts a given string to a SimpleType
 * Defaults to ANY
 * See http://usejsdoc.org/tags-type.html
 * @param str
 * @param context
 */
function parseSimpleJsDocTypeExpression(str, context) {
    var e_1, _a;
    // Fail safe if "str" is somehow undefined
    if (str == null) {
        return { kind: "ANY" };
    }
    // Parse normal types
    switch (str.toLowerCase()) {
        case "undefined":
            return { kind: "UNDEFINED" };
        case "null":
            return { kind: "NULL" };
        case "string":
            return { kind: "STRING" };
        case "number":
            return { kind: "NUMBER" };
        case "boolean":
            return { kind: "BOOLEAN" };
        case "array":
            return { kind: "ARRAY", type: { kind: "ANY" } };
        case "object":
            return { kind: "OBJECT", members: [] };
        case "any":
        case "*":
            return { kind: "ANY" };
    }
    // Match
    //  {  string  }
    if (str.startsWith(" ") || str.endsWith(" ")) {
        return parseSimpleJsDocTypeExpression(str.trim(), context);
    }
    // Match:
    //   {string|number}
    if (str.includes("|")) {
        return {
            kind: "UNION",
            types: str.split("|").map(function (str) {
                var childType = parseSimpleJsDocTypeExpression(str, context);
                // Convert ANY types to string literals so that {on|off} is "on"|"off" and not ANY|ANY
                if (childType.kind === "ANY") {
                    return {
                        kind: "STRING_LITERAL",
                        value: str
                    };
                }
                return childType;
            })
        };
    }
    // Match:
    //  {?number}       (nullable)
    //  {!number}       (not nullable)
    //  {...number}     (array of)
    var prefixMatch = str.match(/^(\?|!|(\.\.\.))(.+)$/);
    if (prefixMatch != null) {
        var modifier = prefixMatch[1];
        var type = parseSimpleJsDocTypeExpression(prefixMatch[3], context);
        switch (modifier) {
            case "?":
                return {
                    kind: "UNION",
                    types: [
                        {
                            kind: "NULL"
                        },
                        type
                    ]
                };
            case "!":
                return type;
            case "...":
                return {
                    kind: "ARRAY",
                    type: type
                };
        }
    }
    // Match:
    //  {(......)}
    var parenMatch = str.match(/^\((.+)\)$/);
    if (parenMatch != null) {
        return parseSimpleJsDocTypeExpression(parenMatch[1], context);
    }
    // Match
    //   {"red"}
    var stringLiteralMatch = str.match(/^["'](.+)["']$/);
    if (stringLiteralMatch != null) {
        return {
            kind: "STRING_LITERAL",
            value: stringLiteralMatch[1]
        };
    }
    // Match
    //   {[number]}
    var arrayMatch = str.match(/^\[(.+)]$/);
    if (arrayMatch != null) {
        return {
            kind: "ARRAY",
            type: parseSimpleJsDocTypeExpression(arrayMatch[1], context)
        };
    }
    // Match
    //   CustomEvent<string>
    //   MyInterface<string, number>
    //   MyInterface<{foo: string, bar: string}, number>
    var genericArgsMatch = str.match(/^(.*)<(.*)>$/);
    if (genericArgsMatch != null) {
        // Here we split generic arguments by "," and
        //   afterwards remerge parts that were incorrectly split
        // For example: "{foo: string, bar: string}, number" would result in
        //   ["{foo: string", "bar: string}", "number"]
        // The correct way to improve "parseSimpleJsDocTypeExpression" is to build a custom lexer/parser.
        var typeArgStrings = [];
        try {
            for (var _b = __values(genericArgsMatch[2].split(/\s*,\s*/)), _c = _b.next(); !_c.done; _c = _b.next()) {
                var part = _c.value;
                if (part.match(/[}:]/) != null && typeArgStrings.length > 0) {
                    typeArgStrings[typeArgStrings.length - 1] += ", " + part;
                }
                else {
                    typeArgStrings.push(part);
                }
            }
        }
        catch (e_1_1) { e_1 = { error: e_1_1 }; }
        finally {
            try {
                if (_c && !_c.done && (_a = _b.return)) _a.call(_b);
            }
            finally { if (e_1) throw e_1.error; }
        }
        return {
            kind: "GENERIC_ARGUMENTS",
            target: parseSimpleJsDocTypeExpression(genericArgsMatch[1], context),
            typeArguments: typeArgStrings.map(function (typeArg) { return parseSimpleJsDocTypeExpression(typeArg, context); })
        };
    }
    // If nothing else, try to find the type in Typescript global lib or else return "any"
    return getLibTypeWithName(str, context) || { kind: "ANY" };
}
/**
 * Finds a @type jsdoc tag in the jsdoc and returns the corresponding simple type
 * @param jsDoc
 * @param context
 */
function getJsDocType(jsDoc, context) {
    var _a;
    if (jsDoc.tags != null) {
        var typeJsDocTag = jsDoc.tags.find(function (t) { return t.tag === "type"; });
        if (typeJsDocTag != null) {
            // We get the text of the node because typescript strips the type jsdoc tag under certain circumstances
            var parsedJsDoc = parseJsDocTagString(((_a = typeJsDocTag.node) === null || _a === void 0 ? void 0 : _a.getText()) || "");
            if (parsedJsDoc.type != null) {
                return parseSimpleJsDocTypeExpression(parsedJsDoc.type, context);
            }
        }
    }
}
var JSDOC_TAGS_WITH_REQUIRED_NAME = ["param", "fires", "@element", "@customElement"];
/**
 * Takes a string that represents a value in jsdoc and transforms it to a javascript value
 * @param value
 */
function parseJsDocValue(value) {
    if (value == null) {
        return value;
    }
    // Parse quoted strings
    var quotedMatch = value.match(/^["'`](.*)["'`]$/);
    if (quotedMatch != null) {
        return quotedMatch[1];
    }
    // Parse keywords
    switch (value) {
        case "false":
            return false;
        case "true":
            return true;
        case "undefined":
            return undefined;
        case "null":
            return null;
    }
    // Parse number
    if (!isNaN(Number(value))) {
        return Number(value);
    }
    return value;
}
/**
 * Parses "@tag {type} name description" or "@tag name {type} description"
 * @param str
 */
function parseJsDocTagString(str) {
    var jsDocTag = {
        tag: ""
    };
    if (str[0] !== "@") {
        return jsDocTag;
    }
    var moveStr = function (byLength) {
        str = str.substring(typeof byLength === "number" ? byLength : byLength.length);
    };
    var unqouteStr = function (quotedStr) {
        return quotedStr.replace(/^['"](.+)["']$/, function (_, match) { return match; });
    };
    var matchTag = function () {
        // Match tag
        // Example: "  @mytag"
        var tagResult = str.match(/^(\s*@(\S+))/);
        if (tagResult == null) {
            return jsDocTag;
        }
        else {
            // Move string to the end of the match
            // Example: "  @mytag|"
            moveStr(tagResult[1]);
            jsDocTag.tag = tagResult[2];
        }
    };
    var matchType = function () {
        // Match type
        // Example: "   {MyType}"
        var typeResult = str.match(/^(\s*{([\s\S]*)})/);
        if (typeResult != null) {
            // Move string to the end of the match
            // Example: "  {MyType}|"
            moveStr(typeResult[1]);
            jsDocTag.type = typeResult[2];
        }
    };
    var matchName = function () {
        // Match optional name
        // Example: "  [myname=mydefault]"
        var defaultNameResult = str.match(/^(\s*\[([\s\S]+)\])/);
        if (defaultNameResult != null) {
            // Move string to the end of the match
            // Example: "  [myname=mydefault]|"
            moveStr(defaultNameResult[1]);
            // Using [...] means that this doc is optional
            jsDocTag.optional = true;
            // Split the inner content between [...] into parts
            // Example:  "myname=mydefault" => "myname", "mydefault"
            var parts = defaultNameResult[2].split("=");
            if (parts.length === 2) {
                // Both name and default were given
                jsDocTag.name = unqouteStr(parts[0]);
                jsDocTag.default = parseJsDocValue(parts[1]);
            }
            else if (parts.length !== 0) {
                // No default was given
                jsDocTag.name = unqouteStr(parts[0]);
            }
        }
        else {
            // else, match required name
            // Example: "   myname"
            // A name is needed some jsdoc tags making it possible to include omit "-"
            // Therefore we don't look for "-" or line end if the name is required - in that case we only need to eat the first word to find the name.
            var regex = JSDOC_TAGS_WITH_REQUIRED_NAME.includes(jsDocTag.tag) ? /^(\s*(\S+))/ : /^(\s*(\S+))((\s*-[\s\S]+)|\s*)($|[\r\n])/;
            var nameResult = str.match(regex);
            if (nameResult != null) {
                // Move string to end of match
                // Example: "   myname|"
                moveStr(nameResult[1]);
                jsDocTag.name = unqouteStr(nameResult[2].trim());
            }
        }
    };
    var matchComment = function () {
        // Match comment
        if (str.length > 0) {
            // The rest of the string is parsed as comment. Remove "-" if needed.
            jsDocTag.description = str.replace(/^\s*-\s*/, "").trim() || undefined;
        }
        // Expand the name based on namespace and classname
        if (jsDocTag.name != null) {
            /**
             * The name could look like this, so we need to parse and the remove the class name and namespace from the name
             *   InputSwitch#[CustomEvent]input-switch-check-changed
             *   InputSwitch#input-switch-check-changed
             */
            var match = jsDocTag.name.match(/(.*)#(\[.*\])?(.*)/);
            if (match != null) {
                jsDocTag.className = match[1];
                jsDocTag.namespace = match[2];
                jsDocTag.name = match[3];
            }
        }
    };
    matchTag();
    matchType();
    matchName();
    // Type can come both before and after "name"
    if (jsDocTag.type == null) {
        matchType();
    }
    matchComment();
    return jsDocTag;
}
/**
 * Parses an entire jsdoc string
 * @param doc
 */
function parseJsDocString(doc) {
    var e_2, _a;
    // Prepare lines
    var lines = doc.split("\n").map(function (line) { return line.trim(); });
    var description = "";
    var readDescription = true;
    var currentTag = "";
    var tags = [];
    /**
     * Parsing will add to "currentTag" and commit it when necessary
     */
    var commitCurrentTag = function () {
        if (currentTag.length > 0) {
            var tagToCommit_1 = currentTag;
            var tagMatch = tagToCommit_1.match(/^@(\S+)\s*/);
            if (tagMatch != null) {
                tags.push({
                    parsed: lazy(function () { return parseJsDocTagString(tagToCommit_1); }),
                    node: undefined,
                    tag: tagMatch[1],
                    comment: tagToCommit_1.substr(tagMatch[0].length)
                });
            }
            currentTag = "";
        }
    };
    try {
        // Parse all lines one by one
        for (var lines_1 = __values(lines), lines_1_1 = lines_1.next(); !lines_1_1.done; lines_1_1 = lines_1.next()) {
            var line = lines_1_1.value;
            // Don't parse the last line ("*/")
            if (line.match(/\*\//)) {
                continue;
            }
            // Match a line like: "* @mytag description"
            var tagCommentMatch = line.match(/(^\s*\*\s*)@\s*/);
            if (tagCommentMatch != null) {
                // Commit current tag (if any has been read). Now "currentTag" will reset.
                commitCurrentTag();
                // Add everything on the line from "@"
                currentTag += line.substr(tagCommentMatch[1].length);
                // We hit a jsdoc tag, so don't read description anymore
                readDescription = false;
            }
            else if (!readDescription) {
                // If we are not reading the description, we are currently reading a multiline tag
                var commentMatch = line.match(/^\s*\*\s*/);
                if (commentMatch != null) {
                    currentTag += "\n" + line.substr(commentMatch[0].length);
                }
            }
            else {
                // Read everything after "*" into the description if we are currently reading the description
                // If we are on the first line, add everything after "/*"
                var startLineMatch = line.match(/^\s*\/\*\*/);
                if (startLineMatch != null) {
                    description += line.substr(startLineMatch[0].length);
                }
                // Add everything after "*" into the current description
                var commentMatch = line.match(/^\s*\*\s*/);
                if (commentMatch != null) {
                    if (description.length > 0) {
                        description += "\n";
                    }
                    description += line.substr(commentMatch[0].length);
                }
            }
        }
    }
    catch (e_2_1) { e_2 = { error: e_2_1 }; }
    finally {
        try {
            if (lines_1_1 && !lines_1_1.done && (_a = lines_1.return)) _a.call(lines_1);
        }
        finally { if (e_2) throw e_2.error; }
    }
    // Commit a tag if we were currently parsing one
    commitCurrentTag();
    if (description.length === 0 && tags.length === 0) {
        return undefined;
    }
    return {
        description: unescapeJSDoc(description),
        tags: tags
    };
}
/**
 * Certain characters as "@" can be escaped in order to prevent Typescript from
 * parsing it as a jsdoc tag. This function unescapes these characters.
 * @param str
 */
function unescapeJSDoc(str) {
    return str.replace(/\\@/, "@");
}

var EVENT_NAMES = [
    "Event",
    "CustomEvent",
    "AnimationEvent",
    "ClipboardEvent",
    "DragEvent",
    "FocusEvent",
    "HashChangeEvent",
    "InputEvent",
    "KeyboardEvent",
    "MouseEvent",
    "PageTransitionEvent",
    "PopStateEvent",
    "ProgressEvent",
    "StorageEvent",
    "TouchEvent",
    "TransitionEvent",
    "UiEvent",
    "WheelEvent"
];
/**
 * Discovers events dispatched
 * @param node
 * @param context
 */
function discoverEvents(node, context) {
    var _a;
    var ts = context.ts, checker = context.checker;
    // new CustomEvent("my-event");
    if (ts.isNewExpression(node)) {
        var expression = node.expression, args = node.arguments;
        if (EVENT_NAMES.includes(expression.getText()) && args && args.length >= 1) {
            var arg = args[0];
            var eventName = (_a = resolveNodeValue(arg, exports.__assign(exports.__assign({}, context), { strict: true }))) === null || _a === void 0 ? void 0 : _a.value;
            if (typeof eventName === "string") {
                // Either grab jsdoc from the new expression or from a possible call expression that its wrapped in
                var jsDoc = getJsDoc(expression, ts) ||
                    (ts.isCallLikeExpression(node.parent) && getJsDoc(node.parent.parent, ts)) ||
                    (ts.isExpressionStatement(node.parent) && getJsDoc(node.parent, ts)) ||
                    undefined;
                return [
                    {
                        jsDoc: jsDoc,
                        name: eventName,
                        node: node,
                        type: lazy(function () { return checker.getTypeAtLocation(node); })
                    }
                ];
            }
        }
    }
    return undefined;
}

/**
 * Discovers global feature defined on "HTMLElementEventMap" or "HTMLElement"
 */
var discoverGlobalFeatures = {
    event: function (node, context) {
        var e_1, _a;
        var _b, _c;
        var ts = context.ts, checker = context.checker;
        if (context.ts.isInterfaceDeclaration(node) && ["HTMLElementEventMap", "GlobalEventHandlersEventMap"].includes(node.name.text)) {
            var events = [];
            var _loop_1 = function (member) {
                if (ts.isPropertySignature(member)) {
                    var name_1 = (_b = resolveNodeValue(member.name, context)) === null || _b === void 0 ? void 0 : _b.value;
                    if (name_1 != null && typeof name_1 === "string") {
                        events.push({
                            node: member.initializer || member,
                            jsDoc: getJsDoc(member, ts),
                            name: name_1,
                            type: lazy(function () { return checker.getTypeAtLocation(member); })
                        });
                    }
                }
            };
            try {
                for (var _d = __values(node.members), _e = _d.next(); !_e.done; _e = _d.next()) {
                    var member = _e.value;
                    _loop_1(member);
                }
            }
            catch (e_1_1) { e_1 = { error: e_1_1 }; }
            finally {
                try {
                    if (_e && !_e.done && (_a = _d.return)) _a.call(_d);
                }
                finally { if (e_1) throw e_1.error; }
            }
            (_c = context === null || context === void 0 ? void 0 : context.emitContinue) === null || _c === void 0 ? void 0 : _c.call(context);
            return events;
        }
    },
    member: function (node, context) {
        var e_2, _a;
        var _b, _c;
        var ts = context.ts;
        if (context.ts.isInterfaceDeclaration(node) && node.name.text === "HTMLElement") {
            var members = [];
            var _loop_2 = function (member) {
                if (ts.isPropertySignature(member)) {
                    var name_2 = (_b = resolveNodeValue(member.name, context)) === null || _b === void 0 ? void 0 : _b.value;
                    if (name_2 != null && typeof name_2 === "string") {
                        members.push({
                            priority: "medium",
                            node: member,
                            jsDoc: getJsDoc(member, ts),
                            kind: "property",
                            propName: name_2,
                            type: lazy(function () { return context.checker.getTypeAtLocation(member); })
                        });
                    }
                }
            };
            try {
                for (var _d = __values(node.members), _e = _d.next(); !_e.done; _e = _d.next()) {
                    var member = _e.value;
                    _loop_2(member);
                }
            }
            catch (e_2_1) { e_2 = { error: e_2_1 }; }
            finally {
                try {
                    if (_e && !_e.done && (_a = _d.return)) _a.call(_d);
                }
                finally { if (e_2) throw e_2.error; }
            }
            (_c = context === null || context === void 0 ? void 0 : context.emitContinue) === null || _c === void 0 ? void 0 : _c.call(context);
            return members;
        }
    }
};

/**
 * Discovers inheritance from a node by looking at "extends" and "implements"
 * @param node
 * @param baseContext
 */
function discoverInheritance(node, baseContext) {
    var declarationKind = undefined;
    var heritageClauses = [];
    var declarationNodes = new Set();
    var context = exports.__assign(exports.__assign({}, baseContext), { emitDeclaration: function (decl) { return declarationNodes.add(decl); }, emitInheritance: function (kind, identifier) { return heritageClauses.push({ kind: kind, identifier: identifier, declaration: undefined }); }, emitDeclarationKind: function (kind) { return (declarationKind = declarationKind || kind); }, visitedNodes: new Set() });
    // Resolve the structure of the node
    resolveStructure(node, context);
    // Reverse heritage clauses because they come out in wrong order
    heritageClauses.reverse();
    return {
        declarationNodes: Array.from(declarationNodes),
        heritageClauses: heritageClauses,
        declarationKind: declarationKind
    };
}
function resolveStructure(node, context) {
    var e_1, _a, e_2, _b, e_3, _c, e_4, _d;
    var ts = context.ts;
    if (context.visitedNodes.has(node)) {
        return;
    }
    context.visitedNodes.add(node);
    // Call this function recursively if this node is an identifier
    if (ts.isIdentifier(node)) {
        try {
            for (var _e = __values(resolveDeclarationsDeep(node, context)), _f = _e.next(); !_f.done; _f = _e.next()) {
                var decl = _f.value;
                resolveStructure(decl, context);
            }
        }
        catch (e_1_1) { e_1 = { error: e_1_1 }; }
        finally {
            try {
                if (_f && !_f.done && (_a = _e.return)) _a.call(_e);
            }
            finally { if (e_1) throw e_1.error; }
        }
    }
    // Emit declaration node if we've found a class of interface
    else if (ts.isClassLike(node) || ts.isInterfaceDeclaration(node)) {
        context.emitDeclarationKind(ts.isClassLike(node) ? "class" : "interface");
        context.emitDeclaration(node);
        try {
            // Resolve inheritance
            for (var _g = __values(node.heritageClauses || []), _h = _g.next(); !_h.done; _h = _g.next()) {
                var heritage = _h.value;
                try {
                    for (var _j = (e_3 = void 0, __values(heritage.types || [])), _k = _j.next(); !_k.done; _k = _j.next()) {
                        var type = _k.value;
                        resolveHeritage(heritage, type.expression, context);
                    }
                }
                catch (e_3_1) { e_3 = { error: e_3_1 }; }
                finally {
                    try {
                        if (_k && !_k.done && (_c = _j.return)) _c.call(_j);
                    }
                    finally { if (e_3) throw e_3.error; }
                }
            }
        }
        catch (e_2_1) { e_2 = { error: e_2_1 }; }
        finally {
            try {
                if (_h && !_h.done && (_b = _g.return)) _b.call(_g);
            }
            finally { if (e_2) throw e_2.error; }
        }
    }
    // Emit a declaration node if this node is a type literal
    else if (ts.isTypeLiteralNode(node) || ts.isObjectLiteralExpression(node)) {
        context.emitDeclarationKind("interface");
        context.emitDeclaration(node);
    }
    // Emit a mixin if this node is a function
    else if (ts.isFunctionLike(node) || ts.isCallLikeExpression(node)) {
        context.emitDeclarationKind("mixin");
        if (ts.isFunctionLike(node) && node.getSourceFile().isDeclarationFile) {
            // Find any identifiers if the node is in a declaration file
            findChildren(node.type, ts.isIdentifier, function (identifier) {
                resolveStructure(identifier, context);
            });
        }
        else {
            // Else find the first class declaration in the block
            // Note that we don't look for a return statement because this would complicate things
            var clzDecl = findChild(node, ts.isClassLike);
            if (clzDecl != null) {
                resolveStructure(clzDecl, context);
                return;
            }
            // If we didn't find any class declarations, we might be in a function that wraps a mixin
            // Therefore find the return statement and call this method recursively
            var returnNode = findChild(node, ts.isReturnStatement);
            if (returnNode != null && returnNode.expression != null && returnNode.expression !== node) {
                var returnNodeExp = returnNode.expression;
                // If a function call is returned, this function call expression is followed, and the arguments are treated as heritage
                //    Example: return MyFirstMixin(MySecondMixin(Base))   -->   MyFirstMixin is followed, and MySecondMixin + Base are inherited
                if (ts.isCallExpression(returnNodeExp) && returnNodeExp.expression != null) {
                    try {
                        for (var _l = __values(returnNodeExp.arguments), _m = _l.next(); !_m.done; _m = _l.next()) {
                            var arg = _m.value;
                            resolveHeritage(undefined, arg, context);
                        }
                    }
                    catch (e_4_1) { e_4 = { error: e_4_1 }; }
                    finally {
                        try {
                            if (_m && !_m.done && (_d = _l.return)) _d.call(_l);
                        }
                        finally { if (e_4) throw e_4.error; }
                    }
                    resolveStructure(returnNodeExp.expression, context);
                }
                return;
            }
        }
    }
    else if (ts.isVariableDeclaration(node) && (node.initializer != null || node.type != null)) {
        resolveStructure((node.initializer || node.type), context);
    }
    else if (ts.isIntersectionTypeNode(node)) {
        emitTypeLiteralsDeclarations(node, context);
    }
}
function resolveHeritage(heritage, node, context) {
    var e_5, _a, e_6, _b;
    var ts = context.ts;
    /**
     * Parse mixins
     */
    if (ts.isCallExpression(node)) {
        // Mixins
        var identifier = node.expression, args = node.arguments;
        try {
            // Extend classes given to the mixin
            // Example: class MyElement extends MyMixin(MyBase) --> MyBase
            // Example: class MyElement extends MyMixin(MyBase1, MyBase2) --> MyBase1, MyBase2
            for (var args_1 = __values(args), args_1_1 = args_1.next(); !args_1_1.done; args_1_1 = args_1.next()) {
                var arg = args_1_1.value;
                resolveHeritage(heritage, arg, context);
            }
        }
        catch (e_5_1) { e_5 = { error: e_5_1 }; }
        finally {
            try {
                if (args_1_1 && !args_1_1.done && (_a = args_1.return)) _a.call(args_1);
            }
            finally { if (e_5) throw e_5.error; }
        }
        // Resolve and traverse the mixin function
        // Example: class MyElement extends MyMixin(MyBase) --> MyMixin
        if (identifier != null && ts.isIdentifier(identifier)) {
            resolveHeritage("mixin", identifier, context);
        }
    }
    else if (ts.isIdentifier(node)) {
        // Try to handle situation like this, by resolving the variable in between
        //    const Base = ExtraMixin(base);
        //    class MixinClass extends Base { }
        var dontEmitHeritageClause = false;
        // Resolve the declaration of this identifier
        var declarations = resolveDeclarationsDeep(node, context);
        var _loop_1 = function (decl) {
            // If the resolved declaration is a variable declaration assigned to a function, try to follow the assignments.
            //    Example:    const MyBase = MyMixin(Base); return class extends MyBase { ... }
            if (context.ts.isVariableDeclaration(decl) && decl.initializer != null) {
                if (context.ts.isCallExpression(decl.initializer)) {
                    var hasDeclaration_1 = false;
                    resolveStructure(decl, exports.__assign(exports.__assign({}, context), { emitInheritance: function () { }, emitDeclarationKind: function () { }, emitDeclaration: function () {
                            hasDeclaration_1 = true;
                        } }));
                    if (!hasDeclaration_1) {
                        resolveHeritage(heritage, decl.initializer, context);
                        dontEmitHeritageClause = true;
                    }
                }
            }
            // Don't emit inheritance if it's a parameter, because the parameter
            //    is a subsitution for the actual base class which we have already resolved.
            else if (context.ts.isParameter(decl)) {
                dontEmitHeritageClause = true;
            }
        };
        try {
            for (var declarations_1 = __values(declarations), declarations_1_1 = declarations_1.next(); !declarations_1_1.done; declarations_1_1 = declarations_1.next()) {
                var decl = declarations_1_1.value;
                _loop_1(decl);
            }
        }
        catch (e_6_1) { e_6 = { error: e_6_1 }; }
        finally {
            try {
                if (declarations_1_1 && !declarations_1_1.done && (_b = declarations_1.return)) _b.call(declarations_1);
            }
            finally { if (e_6) throw e_6.error; }
        }
        if (!dontEmitHeritageClause) {
            // This is an "implements" clause if implement keyword is used or if all the resolved declarations are interfaces
            var kind = heritage != null && typeof heritage === "string"
                ? heritage
                : (heritage === null || heritage === void 0 ? void 0 : heritage.token) === ts.SyntaxKind.ImplementsKeyword ||
                    (declarations.length > 0 && !declarations.some(function (decl) { return !context.ts.isInterfaceDeclaration(decl); }))
                    ? "implements"
                    : "extends";
            context.emitInheritance(kind, node);
        }
    }
}
/**
 * Emits "type literals" in the AST. Emits them with "emitDeclaration"
 * @param node
 * @param context
 */
function emitTypeLiteralsDeclarations(node, context) {
    var _a;
    if (context.ts.isTypeLiteralNode(node)) {
        // If we encounter a construct signature, follow the type
        var construct = (_a = node.members) === null || _a === void 0 ? void 0 : _a.find(function (member) { return context.ts.isConstructSignatureDeclaration(member); });
        if (construct != null && construct.type != null) {
            context.emitDeclarationKind("mixin");
            emitTypeLiteralsDeclarations(construct.type, context);
        }
        else {
            context.emitDeclaration(node);
        }
    }
    else {
        node.forEachChild(function (n) { return emitTypeLiteralsDeclarations(n, context); });
    }
}

/**
 * Discovers members based on standard vanilla custom element rules
 * @param node
 * @param context
 */
function discoverMembers(node, context) {
    var e_1, _a, e_2, _b;
    var _c, _d;
    var ts = context.ts, checker = context.checker;
    // Never pick up members not declared directly on the declaration node being traversed
    if (node.parent !== context.declarationNode) {
        return undefined;
    }
    // static get observedAttributes() { return ['c', 'l']; }
    if (ts.isGetAccessor(node) && hasModifier(node, ts.SyntaxKind.StaticKeyword)) {
        if (node.name.getText() === "observedAttributes" && node.body != null) {
            var members = [];
            // Find either the first "return" statement or the first "array literal expression"
            var arrayLiteralExpression = (_d = (_c = node.body.statements.find(function (statement) { return ts.isReturnStatement(statement); })) === null || _c === void 0 ? void 0 : _c.expression) !== null && _d !== void 0 ? _d : node.body.statements.find(function (statement) { return ts.isArrayLiteralExpression(statement); });
            if (arrayLiteralExpression != null && ts.isArrayLiteralExpression(arrayLiteralExpression)) {
                try {
                    // Emit an attribute for each string literal in the array.
                    for (var _e = __values(arrayLiteralExpression.elements), _f = _e.next(); !_f.done; _f = _e.next()) {
                        var attrNameNode = _f.value;
                        var attrName = ts.isStringLiteralLike(attrNameNode) ? attrNameNode.text : undefined;
                        if (attrName == null)
                            continue;
                        members.push({
                            priority: "medium",
                            node: attrNameNode,
                            jsDoc: getJsDoc(attrNameNode, ts),
                            kind: "attribute",
                            attrName: attrName,
                            type: undefined // () => ({ kind: "ANY" } as SimpleType),
                        });
                    }
                }
                catch (e_1_1) { e_1 = { error: e_1_1 }; }
                finally {
                    try {
                        if (_f && !_f.done && (_a = _e.return)) _a.call(_e);
                    }
                    finally { if (e_1) throw e_1.error; }
                }
            }
            return members;
        }
    }
    // class { myProp = "hello"; }
    else if (ts.isPropertyDeclaration(node) || ts.isPropertySignature(node)) {
        var name_1 = node.name, initializer = node.initializer;
        if (ts.isIdentifier(name_1) || ts.isStringLiteralLike(name_1)) {
            // Always ignore the "prototype" property
            if (name_1.text === "prototype") {
                return undefined;
            }
            // Find default value based on initializer
            var resolvedDefaultValue = initializer != null ? resolveNodeValue(initializer, context) : undefined;
            var def = resolvedDefaultValue != null ? resolvedDefaultValue.value : initializer === null || initializer === void 0 ? void 0 : initializer.getText();
            return [
                {
                    priority: "high",
                    node: node,
                    kind: "property",
                    jsDoc: getJsDoc(node, ts),
                    propName: name_1.text,
                    type: lazy(function () { return checker.getTypeAtLocation(node); }),
                    default: def,
                    visibility: getMemberVisibilityFromNode(node, ts),
                    modifiers: getModifiersFromNode(node, ts)
                    //required: isPropertyRequired(node, context.checker),
                }
            ];
        }
    }
    // class { set myProp(value: string) { ... } }
    else if (ts.isSetAccessor(node) || ts.isGetAccessor(node)) {
        var name_2 = node.name, parameters = node.parameters;
        if (ts.isIdentifier(name_2)) {
            var parameter_1 = ts.isSetAccessor(node) != null && (parameters === null || parameters === void 0 ? void 0 : parameters.length) > 0 ? parameters[0] : undefined;
            return [
                {
                    priority: "high",
                    node: node,
                    jsDoc: getJsDoc(node, ts),
                    kind: "property",
                    propName: name_2.text,
                    type: lazy(function () { return (parameter_1 == null ? context.checker.getTypeAtLocation(node) : context.checker.getTypeAtLocation(parameter_1)); }),
                    visibility: getMemberVisibilityFromNode(node, ts),
                    modifiers: getModifiersFromNode(node, ts)
                }
            ];
        }
    }
    // constructor { super(); this.title = "Hello"; }
    else if (ts.isConstructorDeclaration(node)) {
        if (node.body != null) {
            var assignments = node.body.statements
                .filter(function (stmt) { return ts.isExpressionStatement(stmt); })
                .map(function (stmt) { return stmt.expression; })
                .filter(function (exp) { return ts.isBinaryExpression(exp); });
            var members = [];
            var _loop_1 = function (assignment) {
                var left = assignment.left, right = assignment.right;
                if (ts.isPropertyAccessExpression(left)) {
                    if (left.expression.kind === ts.SyntaxKind.ThisKeyword) {
                        var propName = left.name.getText();
                        var resolvedInitializer = resolveNodeValue(right, context);
                        var def = resolvedInitializer != null ? resolvedInitializer.value : undefined; //right.getText();
                        members.push({
                            priority: "low",
                            node: node,
                            kind: "property",
                            propName: propName,
                            default: def,
                            type: function () { return relaxType(tsSimpleType.toSimpleType(checker.getTypeAtLocation(right), checker)); },
                            jsDoc: getJsDoc(assignment.parent, ts),
                            visibility: isNamePrivate(propName) ? "private" : undefined
                        });
                    }
                }
            };
            try {
                for (var assignments_1 = __values(assignments), assignments_1_1 = assignments_1.next(); !assignments_1_1.done; assignments_1_1 = assignments_1.next()) {
                    var assignment = assignments_1_1.value;
                    _loop_1(assignment);
                }
            }
            catch (e_2_1) { e_2 = { error: e_2_1 }; }
            finally {
                try {
                    if (assignments_1_1 && !assignments_1_1.done && (_b = assignments_1.return)) _b.call(assignments_1);
                }
                finally { if (e_2) throw e_2.error; }
            }
            return members;
        }
    }
    return undefined;
}

/**
 * Discovers methods
 * @param node
 * @param context
 */
function discoverMethods(node, context) {
    var _a;
    var ts = context.ts;
    // Never pick up method declaration not declared directly on the declaration node being traversed
    if (node.parent !== context.declarationNode) {
        return undefined;
    }
    // class { myMethod () {} }
    if ((ts.isMethodDeclaration(node) || ts.isMethodSignature(node)) && !hasModifier(node, ts.SyntaxKind.StaticKeyword)) {
        // Outscope static methods for now
        var name_1 = node.name.getText();
        if (!context.config.analyzeDefaultLib && isHTMLElementMethodName(name_1)) {
            return undefined;
        }
        // Allow the analyzer to analyze within methods
        (_a = context.emitContinue) === null || _a === void 0 ? void 0 : _a.call(context);
        return [
            {
                jsDoc: getJsDoc(node, ts),
                name: name_1,
                node: node,
                visibility: getMemberVisibilityFromNode(node, ts),
                type: lazy(function () { return context.checker.getTypeAtLocation(node); })
            }
        ];
    }
    return undefined;
}
function isHTMLElementMethodName(name) {
    return ["attributeChangedCallback", "connectedCallback", "disconnectedCallback"].includes(name);
}

/**
 * Excludes nodes from "lib.dom.d.ts" if analyzeLibDom is false
 * @param node
 * @param context
 */
function excludeNode(node, context) {
    if (context.config.analyzeDefaultLib) {
        return undefined;
    }
    return isLibDom(node);
}
function isLibDom(node) {
    return node.getSourceFile().fileName.endsWith("lib.dom.d.ts");
}

/**
 * A flavor that discovers using standard custom element rules
 */
var CustomElementFlavor = /** @class */ (function () {
    function CustomElementFlavor() {
        this.excludeNode = excludeNode;
        this.discoverDefinitions = discoverDefinitions;
        this.discoverFeatures = {
            member: discoverMembers,
            event: discoverEvents,
            method: discoverMethods
        };
        this.discoverGlobalFeatures = discoverGlobalFeatures;
        this.discoverInheritance = discoverInheritance;
    }
    return CustomElementFlavor;
}());

/**
 * Transforms jsdoc tags to a T array using a "transform"
 * @param node
 * @param tagNames
 * @param transform
 * @param context
 */
function parseJsDocForNode(node, tagNames, transform, context) {
    var _a;
    var tags = (getJsDoc(node, context.ts, tagNames) || {}).tags;
    if (tags != null && tags.length > 0) {
        (_a = context.emitContinue) === null || _a === void 0 ? void 0 : _a.call(context);
        return arrayDefined(tags.map(function (tag) { return transform(tag.node, tag.parsed()); }));
    }
    return undefined;
}

/**
 * Discovers definitions using "@customElement" or "@element" jsdoc
 * @param node
 * @param context
 */
function discoverDefinitions$1(node, context) {
    // /** @customElement my-element */ myClass extends HTMLElement { ... }
    if (context.ts.isInterfaceDeclaration(node) || context.ts.isClassDeclaration(node)) {
        var identifier_1 = getNodeIdentifier(node, context);
        return parseJsDocForNode(node, ["customelement", "element"], function (tagNode, _a) {
            var name = _a.name;
            return {
                tagName: name || "",
                definitionNode: tagNode,
                identifierNode: identifier_1,
                tagNameNode: tagNode
            };
        }, context);
    }
}

var discoverFeatures = {
    csspart: function (node, context) {
        if (context.ts.isInterfaceDeclaration(node) || context.ts.isClassDeclaration(node)) {
            return parseJsDocForNode(node, ["csspart"], function (tagNode, _a) {
                var name = _a.name, description = _a.description;
                if (name != null && name.length > 0) {
                    return {
                        name: name,
                        jsDoc: description != null ? { description: description } : undefined
                    };
                }
            }, context);
        }
    },
    cssproperty: function (node, context) {
        if (context.ts.isInterfaceDeclaration(node) || context.ts.isClassDeclaration(node)) {
            return parseJsDocForNode(node, ["cssprop", "cssproperty", "cssvar", "cssvariable"], function (tagNode, _a) {
                var name = _a.name, description = _a.description, type = _a.type, def = _a.default;
                if (name != null && name.length > 0) {
                    return {
                        name: name,
                        jsDoc: description != null ? { description: description } : undefined,
                        typeHint: type || undefined,
                        default: def
                    };
                }
            }, context);
        }
    },
    event: function (node, context) {
        if (context.ts.isInterfaceDeclaration(node) || context.ts.isClassDeclaration(node)) {
            return parseJsDocForNode(node, ["event", "fires", "emits"], function (tagNode, _a) {
                var name = _a.name, description = _a.description, type = _a.type;
                if (name != null && name.length > 0 && tagNode != null) {
                    return {
                        name: name,
                        jsDoc: description != null ? { description: description } : undefined,
                        type: type != null ? lazy(function () { return parseSimpleJsDocTypeExpression(type, context) || { kind: "ANY" }; }) : undefined,
                        typeHint: type,
                        node: tagNode
                    };
                }
            }, context);
        }
    },
    slot: function (node, context) {
        if (context.ts.isInterfaceDeclaration(node) || context.ts.isClassDeclaration(node)) {
            return parseJsDocForNode(node, ["slot"], function (tagNode, _a) {
                var name = _a.name, type = _a.type, description = _a.description;
                // Treat "-" as unnamed slot
                if (name === "-") {
                    name = undefined;
                }
                // Grab the type from jsdoc and use it to find permitted tag names
                // Example: @slot {"div"|"span"} myslot
                var permittedTagNameType = type == null ? undefined : parseSimpleJsDocTypeExpression(type, context);
                var permittedTagNames = (function () {
                    if (permittedTagNameType == null) {
                        return undefined;
                    }
                    switch (permittedTagNameType.kind) {
                        case "STRING_LITERAL":
                            return [permittedTagNameType.value];
                        case "UNION":
                            return permittedTagNameType.types
                                .filter(function (type) { return type.kind === "STRING_LITERAL"; })
                                .map(function (type) { return type.value; });
                        default:
                            return undefined;
                    }
                })();
                return {
                    name: name,
                    jsDoc: description != null ? { description: description } : undefined,
                    permittedTagNames: permittedTagNames
                };
            }, context);
        }
    },
    member: function (node, context) {
        if (context.ts.isInterfaceDeclaration(node) || context.ts.isClassDeclaration(node)) {
            var priority_1 = getNodeSourceFileLang(node) === "js" ? "high" : "medium";
            var properties = parseJsDocForNode(node, ["prop", "property"], function (tagNode, _a) {
                var name = _a.name, def = _a.default, type = _a.type, description = _a.description;
                if (name != null && name.length > 0) {
                    return {
                        priority: priority_1,
                        kind: "property",
                        propName: name,
                        jsDoc: description != null ? { description: description } : undefined,
                        typeHint: type,
                        type: lazy(function () { return (type && parseSimpleJsDocTypeExpression(type, context)) || { kind: "ANY" }; }),
                        node: tagNode,
                        default: def,
                        visibility: undefined,
                        reflect: undefined,
                        required: undefined,
                        deprecated: undefined
                    };
                }
            }, context);
            var attributes = parseJsDocForNode(node, ["attr", "attribute"], function (tagNode, _a) {
                var name = _a.name, def = _a.default, type = _a.type, description = _a.description;
                if (name != null && name.length > 0) {
                    return {
                        priority: priority_1,
                        kind: "attribute",
                        attrName: name,
                        jsDoc: description != null ? { description: description } : undefined,
                        type: lazy(function () { return (type && parseSimpleJsDocTypeExpression(type, context)) || { kind: "ANY" }; }),
                        typeHint: type,
                        node: tagNode,
                        default: def,
                        visibility: undefined,
                        reflect: undefined,
                        required: undefined,
                        deprecated: undefined
                    };
                }
            }, context);
            if (attributes != null || properties != null) {
                return __spread((attributes || []), (properties || []));
            }
            return undefined;
        }
    }
};

var discoverGlobalFeatures$1 = {
    csspart: function (node, context) {
        var _a;
        if (context.ts.isInterfaceDeclaration(node) && node.name.text === "HTMLElement") {
            return (_a = discoverFeatures.csspart) === null || _a === void 0 ? void 0 : _a.call(discoverFeatures, node, context);
        }
    },
    cssproperty: function (node, context) {
        var _a;
        if (context.ts.isInterfaceDeclaration(node) && node.name.text === "HTMLElement") {
            return (_a = discoverFeatures.cssproperty) === null || _a === void 0 ? void 0 : _a.call(discoverFeatures, node, context);
        }
    },
    event: function (node, context) {
        var _a;
        if (context.ts.isInterfaceDeclaration(node) && node.name.text === "HTMLElement") {
            return (_a = discoverFeatures.event) === null || _a === void 0 ? void 0 : _a.call(discoverFeatures, node, context);
        }
    },
    slot: function (node, context) {
        var _a;
        if (context.ts.isInterfaceDeclaration(node) && node.name.text === "HTMLElement") {
            return (_a = discoverFeatures.slot) === null || _a === void 0 ? void 0 : _a.call(discoverFeatures, node, context);
        }
    },
    member: function (node, context) {
        var _a;
        if (context.ts.isInterfaceDeclaration(node) && node.name.text === "HTMLElement") {
            return (_a = discoverFeatures === null || discoverFeatures === void 0 ? void 0 : discoverFeatures.member) === null || _a === void 0 ? void 0 : _a.call(discoverFeatures, node, context);
        }
    }
};

/**
 * Refines a component declaration by using jsdoc tags
 * @param declaration
 * @param context
 */
function refineDeclaration(declaration, context) {
    if (declaration.jsDoc == null || declaration.jsDoc.tags == null) {
        return undefined;
    }
    // Applies the "@deprecated" jsdoc tag
    var deprecatedTag = declaration.jsDoc.tags.find(function (t) { return t.tag === "deprecated"; });
    if (deprecatedTag != null) {
        return exports.__assign(exports.__assign({}, declaration), { deprecated: deprecatedTag.comment || true });
    }
    return undefined;
}

/**
 * Refines features by looking at the jsdoc tags on the feature
 */
var refineFeature = {
    event: function (event, context) {
        if (event.jsDoc == null || event.jsDoc.tags == null)
            return event;
        // Check if the feature has "@ignore" jsdoc tag
        if (hasIgnoreJsDocTag(event.jsDoc)) {
            return undefined;
        }
        return [applyJsDocDeprecated, applyJsDocVisibility, applyJsDocType].reduce(function (event, applyFunc) { return applyFunc(event, event.jsDoc, context); }, event);
    },
    method: function (method, context) {
        if (method.jsDoc == null || method.jsDoc.tags == null)
            return method;
        // Check if the feature has "@ignore" jsdoc tag
        if (hasIgnoreJsDocTag(method.jsDoc)) {
            return undefined;
        }
        method = [applyJsDocDeprecated, applyJsDocVisibility].reduce(function (method, applyFunc) { return applyFunc(method, method.jsDoc, context); }, method);
        return method;
    },
    member: function (member, context) {
        // Return right away if the member doesn't have jsdoc
        if (member.jsDoc == null || member.jsDoc.tags == null)
            return member;
        // Check if the feature has "@ignore" jsdoc tag
        if (hasIgnoreJsDocTag(member.jsDoc)) {
            return undefined;
        }
        return [
            applyJsDocDeprecated,
            applyJsDocVisibility,
            applyJsDocRequired,
            applyJsDocDefault,
            applyJsDocReflect,
            applyJsDocType,
            applyJsDocAttribute,
            applyJsDocModifiers
        ].reduce(function (member, applyFunc) { return applyFunc(member, member.jsDoc, context); }, member);
    }
};
/**
 * Applies the "@deprecated" jsdoc tag
 * @param feature
 * @param jsDoc
 */
function applyJsDocDeprecated(feature, jsDoc) {
    var _a;
    var deprecatedTag = (_a = jsDoc.tags) === null || _a === void 0 ? void 0 : _a.find(function (tag) { return tag.tag === "deprecated"; });
    if (deprecatedTag != null) {
        return exports.__assign(exports.__assign({}, feature), { deprecated: deprecatedTag.comment || true });
    }
    return feature;
}
/**
 * Applies the "@access" jsdoc tag
 * @param feature
 * @param jsDoc
 */
function applyJsDocVisibility(feature, jsDoc) {
    var _a;
    var visibilityTag = (_a = jsDoc.tags) === null || _a === void 0 ? void 0 : _a.find(function (tag) { return ["public", "protected", "private", "package", "access"].includes(tag.tag); }); // member + method
    if (visibilityTag != null) {
        return exports.__assign(exports.__assign({}, feature), { visibility: (function () {
                switch (visibilityTag.tag) {
                    case "public":
                        return "public";
                    case "protected":
                        return "protected";
                    case "package":
                    case "private":
                        return "private";
                    case "access":
                        switch (visibilityTag.parsed().name) {
                            case "public":
                                return "public";
                            case "protected":
                                return "protected";
                            case "private":
                            case "package":
                                return "private";
                            default:
                                return undefined;
                        }
                    default:
                        return undefined;
                }
            })() });
    }
    return feature;
}
/**
 * Applies the "@attribute" jsdoc tag
 * @param feature
 * @param jsDoc
 * @param context
 */
function applyJsDocAttribute(feature, jsDoc, context) {
    var _a, _b, _c;
    var attributeTag = (_a = jsDoc.tags) === null || _a === void 0 ? void 0 : _a.find(function (tag) { return ["attr", "attribute"].includes(tag.tag); });
    if (attributeTag != null && feature.attrName == null) {
        var parsed_1 = attributeTag.parsed();
        var result = exports.__assign(exports.__assign({}, feature), { attrName: attributeTag.parsed().name || feature.propName, default: (_b = feature.default) !== null && _b !== void 0 ? _b : parsed_1.default });
        // @attr jsdoc tag can also include the type of attribute
        if (parsed_1.type != null && result.typeHint == null) {
            result.typeHint = parsed_1.type;
            result.type = (_c = feature.type) !== null && _c !== void 0 ? _c : lazy(function () { return parseSimpleJsDocTypeExpression(parsed_1.type || "", context); });
        }
        return result;
    }
    return feature;
}
/**
 * Applies the "@required" jsdoc tag
 * @param feature
 * @param jsDoc
 */
function applyJsDocRequired(feature, jsDoc) {
    var _a;
    var requiredTag = (_a = jsDoc.tags) === null || _a === void 0 ? void 0 : _a.find(function (tag) { return ["optional", "required"].includes(tag.tag); });
    if (requiredTag != null) {
        return exports.__assign(exports.__assign({}, feature), { required: requiredTag.tag === "required" });
    }
    return feature;
}
/**
 * Applies the "@readonly" jsdoc tag
 * @param feature
 * @param jsDoc
 */
function applyJsDocModifiers(feature, jsDoc) {
    var _a;
    var readonlyTag = (_a = jsDoc.tags) === null || _a === void 0 ? void 0 : _a.find(function (tag) { return tag.tag === "readonly"; });
    if (readonlyTag != null) {
        return exports.__assign(exports.__assign({}, feature), { modifiers: (feature.modifiers != null ? new Set(feature.modifiers) : new Set()).add("readonly") });
    }
    return feature;
}
/**
 * Applies the "@default" jsdoc tag
 * @param feature
 * @param jsDoc
 */
function applyJsDocDefault(feature, jsDoc) {
    var _a;
    var defaultTag = (_a = jsDoc.tags) === null || _a === void 0 ? void 0 : _a.find(function (tag) { return tag.tag === "default"; });
    if (defaultTag != null) {
        return exports.__assign(exports.__assign({}, feature), { default: defaultTag.comment });
    }
    return feature;
}
/**
 * Applies the "@reflect" jsdoc tag
 * @param feature
 * @param jsDoc
 */
function applyJsDocReflect(feature, jsDoc) {
    var _a;
    var reflectTag = (_a = jsDoc.tags) === null || _a === void 0 ? void 0 : _a.find(function (tag) { return tag.tag === "reflect"; });
    if (reflectTag != null && feature.reflect == null) {
        return exports.__assign(exports.__assign({}, feature), { reflect: (function () {
                switch (reflectTag.comment) {
                    case "to-attribute":
                        return "to-attribute";
                    case "to-property":
                        return "to-property";
                    case "both":
                        return "both";
                    default:
                        return undefined;
                }
            })() });
    }
    return feature;
}
/**
 * Applies the "@type" jsdoc tag
 * @param feature
 * @param jsDoc
 * @param context
 */
function applyJsDocType(feature, jsDoc, context) {
    var _a, _b;
    var typeTag = (_a = jsDoc.tags) === null || _a === void 0 ? void 0 : _a.find(function (tag) { return tag.tag === "type"; });
    if (typeTag != null && feature.typeHint == null) {
        var parsed_2 = typeTag.parsed();
        if (parsed_2.type != null && parsed_2.type.length > 0) {
            return exports.__assign(exports.__assign({}, feature), { typeHint: parsed_2.type, type: (_b = feature.type) !== null && _b !== void 0 ? _b : lazy(function () { return parseSimpleJsDocTypeExpression(parsed_2.type || "", context); }) });
        }
    }
    return feature;
}
/**
 * Returns if jsdoc contains an ignore node
 * @param jsDoc
 */
function hasIgnoreJsDocTag(jsDoc) {
    var _a;
    return ((_a = jsDoc === null || jsDoc === void 0 ? void 0 : jsDoc.tags) === null || _a === void 0 ? void 0 : _a.find(function (tag) { return tag.tag === "ignore"; })) != null;
}

/**
 * Flavors for analyzing jsdoc related features
 */
var JsDocFlavor = /** @class */ (function () {
    function JsDocFlavor() {
        this.discoverDefinitions = discoverDefinitions$1;
        this.discoverFeatures = discoverFeatures;
        this.discoverGlobalFeatures = discoverGlobalFeatures$1;
        this.refineFeature = refineFeature;
        this.refineDeclaration = refineDeclaration;
    }
    return JsDocFlavor;
}());

/**
 * Discovers element definitions in "IntrinsicElements"
 * @param node
 * @param context
 */
function discoverDefinitions$2(node, context) {
    var ts = context.ts;
    if (ts.isInterfaceDeclaration(node)) {
        if (node.name.text === "IntrinsicElements") {
            var extensions = getInterfaceKeys(node, context);
            return extensions.map(function (_a) {
                var key = _a.key, keyNode = _a.keyNode, identifier = _a.identifier, declaration = _a.declaration;
                return ({
                    tagName: key,
                    tagNameNode: keyNode,
                    identifierNode: identifier,
                    declarationNode: declaration
                });
            });
        }
    }
    return undefined;
}

/**
 * Discovers members declared on "IntrinsicAttributes"
 */
var discoverGlobalFeatures$2 = {
    member: function (node, context) {
        var e_1, _a;
        var _b, _c;
        var ts = context.ts;
        if (ts.isInterfaceDeclaration(node) && node.name.text === "IntrinsicAttributes") {
            var members = [];
            var _loop_1 = function (member) {
                if (ts.isPropertySignature(member)) {
                    var name_1 = (_b = resolveNodeValue(member.name, context)) === null || _b === void 0 ? void 0 : _b.value;
                    if (name_1 != null && typeof name_1 === "string") {
                        members.push({
                            priority: "medium",
                            node: member,
                            jsDoc: getJsDoc(member, ts),
                            kind: "property",
                            propName: name_1,
                            attrName: name_1,
                            type: function () { return context.checker.getTypeAtLocation(member); }
                        });
                    }
                }
            };
            try {
                for (var _d = __values(node.members), _e = _d.next(); !_e.done; _e = _d.next()) {
                    var member = _e.value;
                    _loop_1(member);
                }
            }
            catch (e_1_1) { e_1 = { error: e_1_1 }; }
            finally {
                try {
                    if (_e && !_e.done && (_a = _d.return)) _a.call(_d);
                }
                finally { if (e_1) throw e_1.error; }
            }
            (_c = context === null || context === void 0 ? void 0 : context.emitContinue) === null || _c === void 0 ? void 0 : _c.call(context);
            return members;
        }
    }
};

/**
 * Flavors for analyzing jsx related features
 */
var JSXFlavor = /** @class */ (function () {
    function JSXFlavor() {
        this.discoverDefinitions = discoverDefinitions$2;
        this.discoverGlobalFeatures = discoverGlobalFeatures$2;
    }
    return JSXFlavor;
}());

/**
 * Visits lit-element related definitions.
 * Specifically it finds the usage of the @customElement decorator.
 * @param node
 * @param context
 */
function discoverDefinitions$3(node, context) {
    var e_1, _a;
    var ts = context.ts, checker = context.checker;
    // @customElement("my-element")
    if (ts.isClassDeclaration(node)) {
        try {
            // Visit all decorators on the class
            for (var _b = __values(node.decorators || []), _c = _b.next(); !_c.done; _c = _b.next()) {
                var decorator = _c.value;
                var callExpression = decorator.expression;
                // Find "@customElement"
                if (ts.isCallExpression(callExpression) && ts.isIdentifier(callExpression.expression)) {
                    var decoratorIdentifierName = callExpression.expression.escapedText;
                    // Decorators called "customElement"
                    if (decoratorIdentifierName === "customElement") {
                        // Resolve the value of the first argument. This is the tag name.
                        var unresolvedTagNameNode = callExpression.arguments[0];
                        var resolvedTagNameNode = resolveNodeValue(unresolvedTagNameNode, { ts: ts, checker: checker });
                        var identifier = getNodeIdentifier(node, context);
                        if (resolvedTagNameNode != null && typeof resolvedTagNameNode.value === "string") {
                            return [
                                {
                                    tagName: resolvedTagNameNode.value,
                                    tagNameNode: resolvedTagNameNode.node,
                                    identifierNode: identifier
                                }
                            ];
                        }
                    }
                }
            }
        }
        catch (e_1_1) { e_1 = { error: e_1_1 }; }
        finally {
            try {
                if (_c && !_c.done && (_a = _b.return)) _a.call(_b);
            }
            finally { if (e_1) throw e_1.error; }
        }
        return;
    }
    node.forEachChild(function (child) {
        discoverDefinitions$3(child, context);
    });
}

var LIT_ELEMENT_PROPERTY_DECORATOR_KINDS = ["property", "internalProperty"];
/**
 * Returns a potential lit element property decorator.
 * @param node
 * @param context
 */
function getLitElementPropertyDecorator(node, context) {
    var e_1, _a;
    if (node.decorators == null)
        return undefined;
    var ts = context.ts;
    try {
        // Find a decorator with "property" name.
        for (var _b = __values(node.decorators), _c = _b.next(); !_c.done; _c = _b.next()) {
            var decorator = _c.value;
            var expression = decorator.expression;
            // We find the first decorator calling specific identifier name (found in LIT_ELEMENT_PROPERTY_DECORATOR_KINDS)
            if (ts.isCallExpression(expression) && ts.isIdentifier(expression.expression)) {
                var identifier = expression.expression;
                var kind = identifier.text;
                if (LIT_ELEMENT_PROPERTY_DECORATOR_KINDS.includes(kind)) {
                    return { expression: expression, kind: kind };
                }
            }
        }
    }
    catch (e_1_1) { e_1 = { error: e_1_1 }; }
    finally {
        try {
            if (_c && !_c.done && (_a = _b.return)) _a.call(_b);
        }
        finally { if (e_1) throw e_1.error; }
    }
}
/**
 * Returns a potential lit property decorator configuration.
 * @param node
 * @param context
 */
function getLitElementPropertyDecoratorConfig(node, context) {
    var ts = context.ts;
    // Get reference to a possible "@property" decorator.
    var decorator = getLitElementPropertyDecorator(node, context);
    if (decorator != null) {
        // Parse the first argument to the decorator which is the lit-property configuration.
        var configNode = decorator.expression.arguments[0];
        // Add decorator to "nodes"
        var config = { node: { decorator: decorator.expression } };
        // Apply specific config based on the decorator kind
        switch (decorator.kind) {
            case "internalProperty":
                config.attribute = false;
                break;
        }
        // Get lit options from the object literal expression
        return configNode != null && ts.isObjectLiteralExpression(configNode) ? getLitPropertyOptions(configNode, context, config) : config;
    }
    return undefined;
}
/**
 * Parses an object literal expression and returns a lit property configuration.
 * @param node
 * @param existingConfig
 * @param context
 */
function getLitPropertyOptions(node, context, existingConfig) {
    if (existingConfig === void 0) { existingConfig = {}; }
    var ts = context.ts;
    // Build up the property configuration by looking at properties in the object literal expression
    return node.properties.reduce(function (config, property) {
        if (!ts.isPropertyAssignment(property))
            return config;
        var initializer = property.initializer;
        var kind = ts.isIdentifier(property.name) ? property.name.text : undefined;
        return parseLitPropertyOption({ kind: kind, initializer: initializer, config: config }, context);
    }, existingConfig);
}
function parseLitPropertyOption(_a, context) {
    var _b, _c;
    var kind = _a.kind, initializer = _a.initializer, config = _a.config;
    var ts = context.ts, checker = context.checker;
    // noinspection DuplicateCaseLabelJS
    switch (kind) {
        case "converter": {
            return exports.__assign(exports.__assign({}, config), { hasConverter: true });
        }
        case "reflect": {
            return exports.__assign(exports.__assign({}, config), { reflect: ((_b = resolveNodeValue(initializer, context)) === null || _b === void 0 ? void 0 : _b.value) === true });
        }
        case "attribute": {
            var attribute = void 0;
            if (initializer.kind === ts.SyntaxKind.TrueKeyword) {
                attribute = true;
            }
            else if (initializer.kind === ts.SyntaxKind.FalseKeyword) {
                attribute = false;
            }
            else if (ts.isStringLiteral(initializer)) {
                attribute = initializer.text;
            }
            return exports.__assign(exports.__assign({}, config), { attribute: attribute, node: exports.__assign(exports.__assign({}, (config.node || {})), { attribute: initializer }) });
        }
        case "type": {
            var type = void 0;
            var value = ts.isIdentifier(initializer) ? initializer.text : undefined;
            switch (value) {
                case "String":
                case "StringConstructor":
                    type = { kind: "STRING" };
                    break;
                case "Number":
                case "NumberConstructor":
                    type = { kind: "NUMBER" };
                    break;
                case "Boolean":
                case "BooleanConstructor":
                    type = { kind: "BOOLEAN" };
                    break;
                case "Array":
                case "ArrayConstructor":
                    type = { kind: "ARRAY", type: { kind: "ANY" } };
                    break;
                case "Object":
                case "ObjectConstructor":
                    type = { kind: "OBJECT", members: [] };
                    break;
                default:
                    // This is an unknown type, so set the name as a string
                    type = initializer.getText();
                    break;
            }
            return exports.__assign(exports.__assign({}, config), { type: type, node: exports.__assign(exports.__assign({}, (config.node || {})), { type: initializer }) });
        }
        // Polymer specific field
        case "value": {
            return exports.__assign(exports.__assign({}, config), { default: (_c = resolveNodeValue(initializer, { ts: ts, checker: checker })) === null || _c === void 0 ? void 0 : _c.value });
        }
    }
    return config;
}

/**
 * Parses lit-related declaration members.
 * This is primary by looking at the "@property" decorator and the "static get properties()".
 * @param node
 * @param context
 */
function discoverMembers$1(node, context) {
    var ts = context.ts;
    // Never pick up members not declared directly on the declaration node being traversed
    if (node.parent !== context.declarationNode) {
        return undefined;
    }
    // static get properties() { return { myProp: {type: String} } }
    if (ts.isGetAccessor(node) && hasModifier(node, ts.SyntaxKind.StaticKeyword)) {
        var name_1 = node.name.getText();
        if (name_1 === "properties" && node.body != null) {
            var returnStatement = node.body.statements.find(ts.isReturnStatement.bind(ts));
            if (returnStatement != null) {
                return parseStaticProperties(returnStatement, context);
            }
        }
    }
    // @property({type: String}) myProp = "hello";
    else if (ts.isSetAccessor(node) || ts.isGetAccessor(node) || ts.isPropertyDeclaration(node) || ts.isPropertySignature(node)) {
        return parsePropertyDecorator(node, context);
    }
}
/**
 * Visits a lit property decorator and returns members based on it.
 * @param node
 * @param context
 */
function parsePropertyDecorator(node, context) {
    var ts = context.ts, checker = context.checker;
    // Parse the content of a possible lit "@property" decorator.
    var litConfig = getLitElementPropertyDecoratorConfig(node, context);
    if (litConfig != null) {
        var propName = node.name.getText();
        // Get the attribute based on the configuration
        var attrName = getLitAttributeName(propName, litConfig, context);
        // Find the default value for this property
        var initializer = "initializer" in node ? node.initializer : undefined;
        var resolvedDefaultValue = initializer != null ? resolveNodeValue(initializer, context) : undefined;
        var def = resolvedDefaultValue != null ? resolvedDefaultValue.value : initializer === null || initializer === void 0 ? void 0 : initializer.getText();
        // Find our if the property/attribute is required
        //const required = ("initializer" in node && isPropertyRequired(node, context.checker)) || undefined;
        var required = undefined;
        var jsDoc = getJsDoc(node, ts);
        // Emit a property with "attrName"
        return [
            {
                priority: "high",
                kind: "property",
                propName: propName,
                attrName: attrName,
                type: lazy(function () {
                    var propType = checker.getTypeAtLocation(node);
                    var inJavascriptFile = getNodeSourceFileLang(node) === "js";
                    return inJavascriptFile && typeof litConfig.type === "object" && litConfig.type.kind === "ANY" ? litConfig.type : propType;
                }),
                node: node,
                default: def,
                required: required,
                jsDoc: jsDoc,
                meta: litConfig,
                visibility: getMemberVisibilityFromNode(node, ts),
                reflect: litConfig.reflect ? "both" : attrName != null ? "to-property" : undefined,
                modifiers: getModifiersFromNode(node, ts)
            }
        ];
    }
    return undefined;
}
/**
 * Returns if we are in a Polymer context.
 * @param context
 */
function inPolymerFlavorContext(context) {
    var _a, _b, _c;
    var declaration = context.getDeclaration();
    // TODO: find a better way to construct a cache key
    var cacheKey = "isPolymerFlavorContext:" + (((_a = context.sourceFile) === null || _a === void 0 ? void 0 : _a.fileName) || "unknown");
    if (context.cache.general.has(cacheKey)) {
        return context.cache.general.get(cacheKey);
    }
    var result = false;
    // Use "@polymer" jsdoc tag to indicate that this is polymer context
    if ((_c = (_b = declaration.jsDoc) === null || _b === void 0 ? void 0 : _b.tags) === null || _c === void 0 ? void 0 : _c.some(function (t) { return t.tag === "polymer" || t.tag === "polymerElement"; })) {
        result = true;
    }
    // TODO: This only checks the immediate inheritance. Make it recursive to go throught the entire inheritance chain.
    if (context.getDeclaration().heritageClauses.some(function (c) { return ["PolymerElement", "Polymer.Element"].includes(c.identifier.getText()); })) {
        result = true;
    }
    context.cache.general.set(cacheKey, result);
    return result;
}
/**
 * Returns an attribute name based on a property name and a lit-configuration
 * @param propName
 * @param litConfig
 * @param context
 */
function getLitAttributeName(propName, litConfig, context) {
    // Don't emit attribute if the value is specifically "false"
    if (litConfig.attribute === false) {
        return undefined;
    }
    // Get the attribute name either by looking at "{attribute: ...}" or just taking the property name.
    var attrName = typeof litConfig.attribute === "string" ? litConfig.attribute : propName;
    if (inPolymerFlavorContext(context)) {
        // From the documentation: https://polymer-library.polymer-project.org/3.0/docs/devguide/properties#attribute-reflection
        attrName = camelToDashCase(attrName).toLowerCase();
    }
    return attrName;
}
/**
 * Visits static properties
 * static get properties() { return { myProp: {type: String, attribute: "my-attr"} } }
 * @param returnStatement
 * @param context
 */
function parseStaticProperties(returnStatement, context) {
    var e_1, _a;
    var ts = context.ts;
    var memberResults = [];
    if (returnStatement.expression != null && ts.isObjectLiteralExpression(returnStatement.expression)) {
        var _loop_1 = function (propNode) {
            // Get propName
            var propName = propNode.name != null && ts.isIdentifier(propNode.name) ? propNode.name.text : undefined;
            if (propName == null) {
                return "continue";
            }
            // Parse the lit property config for this property
            // Treat non-object-literal-expressions like the "type" (to support Polymer specific syntax)
            var litConfig = ts.isPropertyAssignment(propNode)
                ? ts.isObjectLiteralExpression(propNode.initializer)
                    ? getLitPropertyOptions(propNode.initializer, context)
                    : inPolymerFlavorContext(context)
                        ? parseLitPropertyOption({
                            kind: "type",
                            initializer: propNode.initializer,
                            config: {}
                        }, context)
                        : {}
                : {};
            // Get attrName based on the litConfig
            var attrName = getLitAttributeName(propName, litConfig, context);
            // Get more metadata
            var jsDoc = getJsDoc(propNode, ts);
            var emitAttribute = litConfig.attribute !== false;
            // Emit either the attribute or the property
            memberResults.push({
                priority: "high",
                kind: "property",
                type: lazy(function () {
                    return (jsDoc && getJsDocType(jsDoc, context)) || (typeof litConfig.type === "object" && litConfig.type) || { kind: "ANY" };
                }),
                propName: propName,
                attrName: emitAttribute ? attrName : undefined,
                jsDoc: jsDoc,
                node: propNode,
                meta: litConfig,
                default: litConfig.default,
                reflect: litConfig.reflect ? "both" : attrName != null ? "to-property" : undefined,
                visibility: isNamePrivate(propName) ? "private" : undefined
            });
        };
        try {
            // Each property in the object literal expression corresponds to a class field.
            for (var _b = __values(returnStatement.expression.properties), _c = _b.next(); !_c.done; _c = _b.next()) {
                var propNode = _c.value;
                _loop_1(propNode);
            }
        }
        catch (e_1_1) { e_1 = { error: e_1_1 }; }
        finally {
            try {
                if (_c && !_c.done && (_a = _b.return)) _a.call(_b);
            }
            finally { if (e_1) throw e_1.error; }
        }
    }
    return memberResults;
}

function excludeNode$1(node, context) {
    if (context.config.analyzeDependencies) {
        return undefined;
    }
    // Exclude lit element related super classes if "analyzeLib" is false
    var declName = getNodeName(node, context);
    if (declName != null) {
        return declName === "LitElement" || declName === "UpdatingElement";
    }
    else {
        var fileName = node.getSourceFile().fileName;
        return fileName.includes("/lit-element.") || fileName.endsWith("/updating-element.");
    }
}

var refineFeature$1 = {
    method: function (method, context) {
        // This is temporary, but for now we force lit-element named methods to be protected
        if (LIT_ELEMENT_PROTECTED_METHODS.includes(method.name)) {
            return exports.__assign(exports.__assign({}, method), { visibility: "protected" });
        }
        return method;
    }
};
var LIT_ELEMENT_PROTECTED_METHODS = [
    "render",
    "requestUpdate",
    "firstUpdated",
    "updated",
    "update",
    "shouldUpdate",
    "hasUpdated",
    "updateComplete"
];

/**
 * Flavors for analyzing LitElement related features: https://lit-element.polymer-project.org/
 */
var LitElementFlavor = /** @class */ (function () {
    function LitElementFlavor() {
        this.excludeNode = excludeNode$1;
        this.discoverDefinitions = discoverDefinitions$3;
        this.discoverFeatures = {
            member: discoverMembers$1
        };
        this.refineFeature = refineFeature$1;
    }
    return LitElementFlavor;
}());

var VERSION = "1.1.6";
var DEFAULT_FLAVORS = [new LitElementFlavor(), new CustomElementFlavor(), new JsDocFlavor(), new JSXFlavor()];
var DEFAULT_FEATURE_COLLECTION_CACHE = new WeakMap();
var DEFAULT_COMPONENT_DECLARATION_CACHE = new WeakMap();

var ALL_COMPONENT_FEATURES = ["member", "method", "cssproperty", "csspart", "event", "slot"];

/**
 * Creates an "analyzer visit context" based on some options
 * @param options
 */
function makeContextFromConfig(options) {
    var _a, _b, _c, _d, _e, _f, _g, _h;
    if (options.program == null) {
        throw new Error("A program is required when running 'analyzeSourceFile'");
    }
    // Assign defaults
    var flavors = options.flavors || DEFAULT_FLAVORS;
    var ts = options.ts || tsModule;
    var checker = options.program.getTypeChecker();
    // Create context
    return {
        checker: checker,
        program: options.program,
        ts: ts,
        flavors: flavors,
        cache: {
            featureCollection: DEFAULT_FEATURE_COLLECTION_CACHE,
            componentDeclarationCache: DEFAULT_COMPONENT_DECLARATION_CACHE,
            general: new Map()
        },
        config: exports.__assign(exports.__assign({}, options.config), { analyzeDefaultLib: (_b = (_a = options.config) === null || _a === void 0 ? void 0 : _a.analyzeDefaultLib) !== null && _b !== void 0 ? _b : false, analyzeDependencies: (_d = (_c = options.config) === null || _c === void 0 ? void 0 : _c.analyzeDependencies) !== null && _d !== void 0 ? _d : false, excludedDeclarationNames: (_f = (_e = options.config) === null || _e === void 0 ? void 0 : _e.excludedDeclarationNames) !== null && _f !== void 0 ? _f : [], features: (_h = (_g = options.config) === null || _g === void 0 ? void 0 : _g.features) !== null && _h !== void 0 ? _h : ALL_COMPONENT_FEATURES })
    };
}

/**
 * Prepares a map of component features and a callback map that adds to the component feature map.
 */
function prepareRefineEmitMap() {
    var collection = {
        members: [],
        methods: [],
        events: [],
        slots: [],
        cssProperties: [],
        cssParts: []
    };
    var refineEmitMap = {
        event: function (event) { return collection.events.push(event); },
        member: function (member) { return collection.members.push(member); },
        csspart: function (cssPart) { return collection.cssParts.push(cssPart); },
        cssproperty: function (cssProperty) { return collection.cssProperties.push(cssProperty); },
        method: function (method) { return collection.methods.push(method); },
        slot: function (slot) { return collection.slots.push(slot); }
    };
    return {
        collection: collection,
        refineEmitMap: refineEmitMap
    };
}

/**
 * Uses flavors to refine a feature
 * Flavors can also remove a feature
 * @param featureKind
 * @param value
 * @param context
 * @param emitMap
 */
function refineFeature$2(featureKind, value, context, emitMap) {
    /*if (Array.isArray(value)) {
        value.forEach(v => refineComponentFeature(featureKind, v, context, emitMap));
        return;
    }*/
    var e_1, _a, e_2, _b, e_3, _c;
    var _d;
    var refinedValue = value;
    // Add "declaration" to the feature if necessary
    if ("getDeclaration" in context && refinedValue != null) {
        var decl = context.getDeclaration();
        if (Array.isArray(refinedValue)) {
            try {
                for (var refinedValue_1 = __values(refinedValue), refinedValue_1_1 = refinedValue_1.next(); !refinedValue_1_1.done; refinedValue_1_1 = refinedValue_1.next()) {
                    var val = refinedValue_1_1.value;
                    if (val.declaration == null) {
                        val.declaration = decl;
                    }
                }
            }
            catch (e_1_1) { e_1 = { error: e_1_1 }; }
            finally {
                try {
                    if (refinedValue_1_1 && !refinedValue_1_1.done && (_a = refinedValue_1.return)) _a.call(refinedValue_1);
                }
                finally { if (e_1) throw e_1.error; }
            }
        }
        else if (refinedValue.declaration == null) {
            refinedValue.declaration = decl;
        }
    }
    try {
        for (var _e = __values(context.flavors), _f = _e.next(); !_f.done; _f = _e.next()) {
            var flavor = _f.value;
            var refineFunc = (_d = flavor.refineFeature) === null || _d === void 0 ? void 0 : _d[featureKind];
            if (refineFunc != null) {
                if (refinedValue == null) {
                    return;
                }
                else if (Array.isArray(refinedValue)) {
                    var newValue = [];
                    try {
                        for (var refinedValue_2 = (e_3 = void 0, __values(refinedValue)), refinedValue_2_1 = refinedValue_2.next(); !refinedValue_2_1.done; refinedValue_2_1 = refinedValue_2.next()) {
                            var val = refinedValue_2_1.value;
                            // eslint-disable-next-line @typescript-eslint/no-explicit-any
                            var refined = refineFunc(val, context);
                            if (refined != null) {
                                newValue.push.apply(newValue, __spread((Array.isArray(refined) ? refined : [refined])));
                            }
                        }
                    }
                    catch (e_3_1) { e_3 = { error: e_3_1 }; }
                    finally {
                        try {
                            if (refinedValue_2_1 && !refinedValue_2_1.done && (_c = refinedValue_2.return)) _c.call(refinedValue_2);
                        }
                        finally { if (e_3) throw e_3.error; }
                    }
                    refinedValue = newValue.length === 0 ? undefined : newValue;
                }
                else {
                    // eslint-disable-next-line @typescript-eslint/no-explicit-any
                    refinedValue = refineFunc(refinedValue, context);
                }
            }
        }
    }
    catch (e_2_1) { e_2 = { error: e_2_1 }; }
    finally {
        try {
            if (_f && !_f.done && (_b = _e.return)) _b.call(_e);
        }
        finally { if (e_2) throw e_2.error; }
    }
    if (refinedValue != null) {
        // eslint-disable-next-line @typescript-eslint/no-explicit-any
        (Array.isArray(refinedValue) ? refinedValue : [refinedValue]).forEach(function (v) { var _a; return (_a = emitMap === null || emitMap === void 0 ? void 0 : emitMap[featureKind]) === null || _a === void 0 ? void 0 : _a.call(emitMap, v); });
    }
}

/**
 * Uses flavors to find features for a node
 * @param node
 * @param context
 * @param emitMap
 */
function visitFeatures(node, context, emitMap) {
    var visitMaps = arrayDefined(context.flavors.map(function (flavor) { return flavor.discoverFeatures; }));
    visitFeaturesWithVisitMaps(node, context, visitMaps, emitMap);
}
/**
 * Uses flavors to find features for a node, using a visit map
 * @param node
 * @param context
 * @param visitMaps
 * @param emitMap
 */
function visitFeaturesWithVisitMaps(node, context, visitMaps, emitMap) {
    var e_1, _a, e_2, _b;
    var _c;
    try {
        for (var _d = __values(context.config.features || []), _e = _d.next(); !_e.done; _e = _d.next()) {
            var feature = _e.value;
            try {
                // Visit all features: always "continue"
                for (var visitMaps_1 = (e_2 = void 0, __values(visitMaps)), visitMaps_1_1 = visitMaps_1.next(); !visitMaps_1_1.done; visitMaps_1_1 = visitMaps_1.next()) {
                    var functionMap = visitMaps_1_1.value;
                    var func = functionMap === null || functionMap === void 0 ? void 0 : functionMap[feature];
                    // eslint-disable-next-line @typescript-eslint/no-explicit-any
                    var value = func === null || func === void 0 ? void 0 : func(node, context);
                    if (value != null) {
                        // eslint-disable-next-line @typescript-eslint/no-explicit-any
                        (_c = emitMap[feature]) === null || _c === void 0 ? void 0 : _c.call(emitMap, value);
                    }
                }
            }
            catch (e_2_1) { e_2 = { error: e_2_1 }; }
            finally {
                try {
                    if (visitMaps_1_1 && !visitMaps_1_1.done && (_b = visitMaps_1.return)) _b.call(visitMaps_1);
                }
                finally { if (e_2) throw e_2.error; }
            }
        }
    }
    catch (e_1_1) { e_1 = { error: e_1_1 }; }
    finally {
        try {
            if (_e && !_e.done && (_a = _d.return)) _a.call(_d);
        }
        finally { if (e_1) throw e_1.error; }
    }
    // Visit child nodes
    node.forEachChild(function (child) {
        visitFeaturesWithVisitMaps(child, context, visitMaps, emitMap);
    });
}

/**
 * Merges based on a name
 * @param entries
 * @param direction
 * @param getName
 * @param merge
 */
function mergeNamedEntries(entries, getName, merge) {
    var e_1, _a;
    var merged = new Map();
    try {
        for (var entries_1 = __values(entries), entries_1_1 = entries_1.next(); !entries_1_1.done; entries_1_1 = entries_1.next()) {
            var entry = entries_1_1.value;
            var name_1 = getName(entry);
            var existing = merged.get(name_1);
            if (existing == null) {
                merged.set(name_1, entry);
            }
            else if (merge != null) {
                merged.set(name_1, merge(existing, entry));
            }
        }
    }
    catch (e_1_1) { e_1 = { error: e_1_1 }; }
    finally {
        try {
            if (entries_1_1 && !entries_1_1.done && (_a = entries_1.return)) _a.call(entries_1);
        }
        finally { if (e_1) throw e_1.error; }
    }
    return Array.from(merged.values());
}
/**
 * Merges two jsdocs
 * @param leftJsDoc
 * @param rightJsDoc
 */
function mergeJsDoc(leftJsDoc, rightJsDoc) {
    var _a;
    if (leftJsDoc == null) {
        return rightJsDoc;
    }
    else if (rightJsDoc == null) {
        return leftJsDoc;
    }
    return exports.__assign(exports.__assign({}, (leftJsDoc !== null && leftJsDoc !== void 0 ? leftJsDoc : rightJsDoc)), { description: (_a = leftJsDoc.description) !== null && _a !== void 0 ? _a : rightJsDoc.description });
}
/**
 * Merges modifiers
 * @param leftModifiers
 * @param rightModifiers
 */
function mergeModifiers(leftModifiers, rightModifiers) {
    var newSet = new Set();
    if ((leftModifiers === null || leftModifiers === void 0 ? void 0 : leftModifiers.has("static")) && (rightModifiers === null || rightModifiers === void 0 ? void 0 : rightModifiers.has("static"))) {
        newSet.add("static");
    }
    if ((leftModifiers === null || leftModifiers === void 0 ? void 0 : leftModifiers.has("readonly")) && (rightModifiers === null || rightModifiers === void 0 ? void 0 : rightModifiers.has("readonly"))) {
        newSet.add("readonly");
    }
    if (newSet.size === 0) {
        return undefined;
    }
    return newSet;
}
/**
 * Merges entries using a "merge" callback
 * @param entries
 * @param isMergeable
 * @param merge
 */
/*export function mergeEntries<T>(entries: T[], isMergeable: (entry: T, merged: T) => boolean, merge: (left: T, right: T) => T): T[] {
    let mergedEntries: T[] = [];

    for (const entry of entries) {
        let mergeableEntry: T | undefined = undefined;
        for (const mergedEntry of mergedEntries) {
            if (isMergeable(entry, mergedEntry)) {
                mergeableEntry = mergedEntry;
                break;
            }
        }

        let newEntry: T | undefined = undefined;
        if (mergeableEntry == null) {
            newEntry = entry;
        } else {
            mergedEntries = mergedEntries.filter(mergedEntry => mergedEntry !== entry && mergedEntry !== mergeableEntry);
            newEntry = merge(mergeableEntry, entry);
        }
        mergedEntries.push(newEntry);
    }

    return mergedEntries;
}*/

/**
 * Merges multiple slots
 * @param slots
 */
function mergeSlots(slots) {
    return mergeNamedEntries(slots, function (slot) { return slot.name || ""; });
}
/**
 * Merges multiple css parts
 * @param cssParts
 */
function mergeCssParts(cssParts) {
    return mergeNamedEntries(cssParts, function (cssPart) { return cssPart.name; });
}
/**
 * Merges multiple css properties
 * @param cssProps
 */
function mergeCssProperties(cssProps) {
    return mergeNamedEntries(cssProps, function (cssProp) { return cssProp.name; });
}
/**
 * Merges multiple methods
 * @param methods
 */
function mergeMethods(methods) {
    return mergeNamedEntries(methods, function (method) { return method.name; }, function (left, right) { return (exports.__assign(exports.__assign({}, left), { jsDoc: mergeJsDoc(left.jsDoc, right.jsDoc) })); });
    /*return mergeEntries(
        methods,
        (method, mergedMethod) => {
            if (method.name === mergedMethod.name) {
                return (method.modifiers?.has("static") || false) === (mergedMethod.modifiers?.has("static") || false);
            }

            return false;
        },
        (left, right) => ({
            ...left,
            jsDoc: mergeJsDoc(left.jsDoc, right.jsDoc),
            modifiers: mergeModifiers(left.modifiers, right.modifiers)
        })
    );*/
}
/**
 * Merges multiple events
 * @param events
 */
function mergeEvents(events) {
    return mergeNamedEntries(events, function (event) { return event.name; }, function (left, right) { return (exports.__assign(exports.__assign({}, left), { jsDoc: mergeJsDoc(left.jsDoc, right.jsDoc), type: function () { return (left.type != null ? left.type() : right.type != null ? right.type() : { kind: "ANY" }); }, typeHint: left.typeHint || right.typeHint })); });
}

var priorityValueMap = {
    low: 0,
    medium: 1,
    high: 2
};
/**
 * Merges multiple members based on priority
 * @param members
 * @param context
 */
function mergeMembers(members, context) {
    var e_1, _a;
    // Start merging by sorting member results from high to low priority.
    // If two priorities are the same: prioritize the first found element
    // From node 11, equal elements keep their order after sort, but not in node 10
    // Therefore we use "indexOf" to return correct order if two priorities are equal
    members = __spread(members).sort(function (a, b) {
        var vA = priorityValueMap[a.priority || "low"];
        var vB = priorityValueMap[b.priority || "low"];
        if (vA === vB) {
            var iA = members.indexOf(a);
            var iB = members.indexOf(b);
            return iA < iB ? -1 : 1;
        }
        return vA < vB ? 1 : -1;
    });
    // Keep track of merged props and merged attributes
    // These are stored in maps for speed, because we are going to lookup a member per each memberResult
    var mergeMap = {
        props: new Map(),
        attrs: new Map()
    };
    try {
        // Merge all members one by one adding them to the merge map
        for (var members_1 = __values(members), members_1_1 = members_1.next(); !members_1_1.done; members_1_1 = members_1.next()) {
            var member = members_1_1.value;
            // Find a member that is similar to this member
            var mergeableMember = findMemberToMerge(member, mergeMap);
            var newMember = undefined;
            if (mergeableMember == null) {
                // No mergeable member was found, so just add this to the map
                newMember = member;
            }
            else {
                // Remove "member" and "mergeableMember" from the merge map
                // We are going to merge those and add the result to the merge map again
                clearMergeMapWithMember(mergeableMember, mergeMap);
                clearMergeMapWithMember(member, mergeMap);
                newMember = mergeMemberIntoMember(mergeableMember, member, context.checker);
            }
            // Add to merge map
            switch (newMember.kind) {
                case "attribute":
                    mergeMap.attrs.set(newMember.attrName, newMember);
                    break;
                case "property":
                    mergeMap.props.set(newMember.propName, newMember);
                    break;
            }
        }
    }
    catch (e_1_1) { e_1 = { error: e_1_1 }; }
    finally {
        try {
            if (members_1_1 && !members_1_1.done && (_a = members_1.return)) _a.call(members_1);
        }
        finally { if (e_1) throw e_1.error; }
    }
    // Return merged results with only "high" priorities
    return __spread(mergeMap.props.values(), mergeMap.attrs.values()).map(function (member) { return (exports.__assign(exports.__assign({}, member), { priority: "high" })); });
}
/**
 * Removes a member from the merge map
 * @param member
 * @param mergeMap
 */
function clearMergeMapWithMember(member, mergeMap) {
    switch (member.kind) {
        case "attribute":
            mergeMap.attrs.delete(member.attrName);
            break;
        case "property":
            mergeMap.props.delete(member.propName);
            if (member.attrName != null) {
                mergeMap.attrs.delete(member.attrName);
            }
            break;
    }
}
/**
 * Finds a mergeable member
 * @param similar
 * @param mergeMap
 */
function findMemberToMerge(similar, mergeMap) {
    var e_2, _a;
    var attrName = similar.attrName; //?.toLowerCase(); // (similar.kind === "attribute" && similar.attrName.toLowerCase()) || undefined;
    var propName = similar.propName; /*?.toLowerCase()*/ //(similar.kind === "property" && similar.propName.toLowerCase()) || undefined;
    // Return a member that matches either propName (prioritized) or attrName
    if (propName != null) {
        var mergeable = mergeMap.props.get(propName) || mergeMap.attrs.get(propName);
        if (mergeable != null) {
            return mergeable;
        }
    }
    if (attrName != null) {
        var mergeableAttr = mergeMap.attrs.get(attrName);
        if (mergeableAttr != null) {
            return mergeableAttr;
        }
        // Try to find a prop with the attr name.
        // Don't return the prop if it already has an attribute that is not equals to the attr name
        var mergeableProp = mergeMap.props.get(attrName);
        if (mergeableProp != null && mergeableProp.attrName == null) {
            return mergeableProp;
        }
        try {
            for (var _b = __values(mergeMap.props.values()), _c = _b.next(); !_c.done; _c = _b.next()) {
                var mergedAttr = _c.value;
                if (mergedAttr.attrName === attrName) {
                    return mergedAttr;
                }
            }
        }
        catch (e_2_1) { e_2 = { error: e_2_1 }; }
        finally {
            try {
                if (_c && !_c.done && (_a = _b.return)) _a.call(_b);
            }
            finally { if (e_2) throw e_2.error; }
        }
    }
}
/**
 * Merges two members of the same kind into each other.
 * This operation prioritizes leftMember
 * @param leftMember
 * @param rightMember
 * @param checker
 */
function mergeMemberIntoMember(leftMember, rightMember, checker) {
    var _a, _b, _c, _d, _e, _f, _g;
    // Always prioritize merging attribute into property if possible
    if (leftMember.kind === "attribute" && rightMember.kind === "property") {
        return mergeMemberIntoMember(rightMember, leftMember);
    }
    return exports.__assign(exports.__assign({}, leftMember), { attrName: (_a = leftMember.attrName) !== null && _a !== void 0 ? _a : rightMember.attrName, type: (function () {
            var _a, _b;
            // Always prioritize a "property" over an "attribute" when merging types
            if (leftMember.kind === rightMember.kind || leftMember.kind === "property") {
                return (_a = leftMember.type) !== null && _a !== void 0 ? _a : rightMember.type;
            }
            else if (rightMember.kind === "property") {
                return (_b = rightMember.type) !== null && _b !== void 0 ? _b : leftMember.type;
            }
        })(), typeHint: (_b = leftMember.typeHint) !== null && _b !== void 0 ? _b : rightMember.typeHint, jsDoc: mergeJsDoc(leftMember.jsDoc, rightMember.jsDoc), modifiers: mergeModifiers(leftMember.modifiers, rightMember.modifiers), meta: (_c = leftMember.meta) !== null && _c !== void 0 ? _c : rightMember.meta, default: leftMember.default === undefined ? rightMember.default : leftMember.default, required: (_d = leftMember.required) !== null && _d !== void 0 ? _d : rightMember.required, visibility: (_e = leftMember.visibility) !== null && _e !== void 0 ? _e : rightMember.visibility, deprecated: (_f = leftMember.deprecated) !== null && _f !== void 0 ? _f : rightMember.deprecated, declaration: (_g = rightMember.declaration) !== null && _g !== void 0 ? _g : leftMember.declaration });
}

/**
 * Merges all features in collections of features
 * @param collection
 * @param context
 */
function mergeFeatures(collection, context) {
    if (Array.isArray(collection)) {
        if (collection.length === 1) {
            return collection[0];
        }
        collection = {
            cssParts: arrayFlat(collection.map(function (c) { return c.cssParts; })),
            cssProperties: arrayFlat(collection.map(function (c) { return c.cssProperties; })),
            events: arrayFlat(collection.map(function (c) { return c.events; })),
            members: arrayFlat(collection.map(function (c) { return c.members; })),
            methods: arrayFlat(collection.map(function (c) { return c.methods; })),
            slots: arrayFlat(collection.map(function (c) { return c.slots; }))
        };
        return mergeFeatures(collection, context);
    }
    return {
        cssParts: mergeCssParts(collection.cssParts),
        cssProperties: mergeCssProperties(collection.cssProperties),
        events: mergeEvents(collection.events),
        members: mergeMembers(collection.members, context),
        methods: mergeMethods(collection.methods),
        slots: mergeSlots(collection.slots)
    };
}

/**
 * Discovers features for a given node using flavors
 * @param node
 * @param context
 */
function discoverFeatures$1(node, context) {
    // Return the result if we already found this node
    if (context.cache.featureCollection.has(node)) {
        return context.cache.featureCollection.get(node);
    }
    var _a = prepareRefineEmitMap(), collection = _a.collection, refineEmitMap = _a.refineEmitMap;
    // Discovers features for "node" using flavors
    visitFeatures(node, context, {
        event: function (event) { return refineFeature$2("event", event, context, refineEmitMap); },
        member: function (memberResult) { return refineFeature$2("member", memberResult, context, refineEmitMap); },
        csspart: function (cssPart) { return refineFeature$2("csspart", cssPart, context, refineEmitMap); },
        cssproperty: function (cssProperty) { return refineFeature$2("cssproperty", cssProperty, context, refineEmitMap); },
        method: function (method) { return refineFeature$2("method", method, context, refineEmitMap); },
        slot: function (slot) { return refineFeature$2("slot", slot, context, refineEmitMap); }
    });
    // Merge features that were found
    var mergedCollection = mergeFeatures(collection, context);
    // Cache the features for this node
    context.cache.featureCollection.set(node, mergedCollection);
    return mergedCollection;
}

/**
 * Uses flavors to find inheritance for a node
 * @param node
 * @param context
 * @param emit
 * @param visitSet
 */
function visitInheritance(node, context, emit, visitSet) {
    var e_1, _a;
    var _b;
    try {
        for (var _c = __values(context.flavors), _d = _c.next(); !_d.done; _d = _c.next()) {
            var flavor = _d.value;
            var result = (_b = flavor.discoverInheritance) === null || _b === void 0 ? void 0 : _b.call(flavor, node, context);
            if (result != null) {
                emit(result);
            }
        }
    }
    catch (e_1_1) { e_1 = { error: e_1_1 }; }
    finally {
        try {
            if (_d && !_d.done && (_a = _c.return)) _a.call(_c);
        }
        finally { if (e_1) throw e_1.error; }
    }
}

/**
 * Uses flavors in order to discover inheritance from one of more nodes.
 * @param startNode
 * @param visitedNodes
 * @param context
 */
function discoverInheritance$1(startNode, visitedNodes, context) {
    var e_1, _a;
    var nodes = Array.isArray(startNode) ? startNode : [startNode];
    var declarationKind = undefined;
    var heritageClauses = [];
    var declarationNodes = new Set();
    try {
        for (var nodes_1 = __values(nodes), nodes_1_1 = nodes_1.next(); !nodes_1_1.done; nodes_1_1 = nodes_1.next()) {
            var node = nodes_1_1.value;
            visitedNodes.add(node);
            // Visit inheritance using flavors
            visitInheritance(node, context, function (result) {
                var e_2, _a;
                // Combine results into one single result
                declarationKind = declarationKind || result.declarationKind;
                if (result.declarationNodes != null) {
                    try {
                        for (var _b = (e_2 = void 0, __values(result.declarationNodes)), _c = _b.next(); !_c.done; _c = _b.next()) {
                            var node_1 = _c.value;
                            declarationNodes.add(node_1);
                        }
                    }
                    catch (e_2_1) { e_2 = { error: e_2_1 }; }
                    finally {
                        try {
                            if (_c && !_c.done && (_a = _b.return)) _a.call(_b);
                        }
                        finally { if (e_2) throw e_2.error; }
                    }
                }
                if (result.heritageClauses != null) {
                    heritageClauses.push.apply(heritageClauses, __spread(result.heritageClauses));
                }
            });
        }
    }
    catch (e_1_1) { e_1 = { error: e_1_1 }; }
    finally {
        try {
            if (nodes_1_1 && !nodes_1_1.done && (_a = nodes_1.return)) _a.call(nodes_1);
        }
        finally { if (e_1) throw e_1.error; }
    }
    return {
        declarationNodes: Array.from(declarationNodes),
        heritageClauses: heritageClauses,
        declarationKind: declarationKind || "class"
    };
}

/**
 * Uses flavors to determine if a node should be excluded from the output
 * @param node
 * @param context
 */
function excludeNode$2(node, context) {
    var e_1, _a;
    var _b;
    try {
        for (var _c = __values(context.flavors), _d = _c.next(); !_d.done; _d = _c.next()) {
            var flavor = _d.value;
            var exclude = (_b = flavor.excludeNode) === null || _b === void 0 ? void 0 : _b.call(flavor, node, context);
            if (exclude) {
                return true;
            }
        }
    }
    catch (e_1_1) { e_1 = { error: e_1_1 }; }
    finally {
        try {
            if (_d && !_d.done && (_a = _c.return)) _a.call(_c);
        }
        finally { if (e_1) throw e_1.error; }
    }
    return false;
}

/**
 * Uses flavors to refine a declaration
 * @param declaration
 * @param context
 */
function refineDeclaration$1(declaration, context) {
    var e_1, _a;
    var _b, _c;
    try {
        for (var _d = __values(context.flavors), _e = _d.next(); !_e.done; _e = _d.next()) {
            var flavor = _e.value;
            declaration = (_c = (_b = flavor.refineDeclaration) === null || _b === void 0 ? void 0 : _b.call(flavor, declaration, context)) !== null && _c !== void 0 ? _c : declaration;
        }
    }
    catch (e_1_1) { e_1 = { error: e_1_1 }; }
    finally {
        try {
            if (_e && !_e.done && (_a = _d.return)) _a.call(_d);
        }
        finally { if (e_1) throw e_1.error; }
    }
    return declaration;
}

/**
 * Discovers features on component declaration nodes
 * @param initialDeclarationNodes
 * @param baseContext
 * @param options
 */
function analyzeComponentDeclaration(initialDeclarationNodes, baseContext, options) {
    var e_1, _a, e_2, _b, e_3, _c;
    if (options === void 0) { options = {}; }
    var mainDeclarationNode = initialDeclarationNodes[0];
    if (mainDeclarationNode == null) {
        return undefined;
        //throw new Error("Couldn't find main declaration node");
    }
    // Check if there exists a cached declaration for this node.
    // If a cached declaration was found, test if it should be invalidated (by looking at inherited declarations)
    var cachedDeclaration = baseContext.cache.componentDeclarationCache.get(mainDeclarationNode);
    if (cachedDeclaration != null && !shouldInvalidateCachedDeclaration(cachedDeclaration, baseContext)) {
        return cachedDeclaration;
    }
    options.visitedNodes = options.visitedNodes || new Set();
    // Discover inheritance
    var _d = discoverInheritance$1(initialDeclarationNodes, options.visitedNodes, baseContext), declarationKind = _d.declarationKind, declarationNodes = _d.declarationNodes, heritageClauses = _d.heritageClauses;
    try {
        // Expand all heritage clauses with the component declaration
        for (var heritageClauses_1 = __values(heritageClauses), heritageClauses_1_1 = heritageClauses_1.next(); !heritageClauses_1_1.done; heritageClauses_1_1 = heritageClauses_1.next()) {
            var heritageClause = heritageClauses_1_1.value;
            // Only resolve declarations we haven't yet seen and shouldn't be excluded
            var declarations = resolveDeclarations(heritageClause.identifier, baseContext).filter(function (n) { var _a; return !((_a = options.visitedNodes) === null || _a === void 0 ? void 0 : _a.has(n)) && !shouldExcludeNode(n, baseContext); });
            if (declarations.length > 0) {
                heritageClause.declaration = analyzeComponentDeclaration(declarations, baseContext, options);
            }
        }
    }
    catch (e_1_1) { e_1 = { error: e_1_1 }; }
    finally {
        try {
            if (heritageClauses_1_1 && !heritageClauses_1_1.done && (_a = heritageClauses_1.return)) _a.call(heritageClauses_1);
        }
        finally { if (e_1) throw e_1.error; }
    }
    // Get symbol of main declaration node
    var symbol = getSymbol(mainDeclarationNode, baseContext);
    var sourceFile = mainDeclarationNode.getSourceFile();
    var baseDeclaration = {
        sourceFile: sourceFile,
        node: mainDeclarationNode,
        declarationNodes: new Set(declarationNodes),
        symbol: symbol,
        heritageClauses: heritageClauses,
        kind: declarationKind || "class",
        events: [],
        cssParts: [],
        cssProperties: [],
        members: [],
        methods: [],
        slots: [],
        jsDoc: getJsDoc(mainDeclarationNode, baseContext.ts)
    };
    // Add the "get declaration" hook to the context
    var context = exports.__assign(exports.__assign({}, baseContext), { declarationNode: mainDeclarationNode, sourceFile: mainDeclarationNode.getSourceFile(), getDeclaration: function () { return baseDeclaration; } });
    // Find features on all declaration nodes
    var featureCollections = [];
    try {
        for (var declarationNodes_1 = __values(declarationNodes), declarationNodes_1_1 = declarationNodes_1.next(); !declarationNodes_1_1.done; declarationNodes_1_1 = declarationNodes_1.next()) {
            var node = declarationNodes_1_1.value;
            if (shouldExcludeNode(node, context)) {
                continue;
            }
            // Discover component features using flavors
            featureCollections.push(discoverFeatures$1(node, exports.__assign(exports.__assign({}, context), { declarationNode: node, sourceFile: node.getSourceFile() })));
        }
    }
    catch (e_2_1) { e_2 = { error: e_2_1 }; }
    finally {
        try {
            if (declarationNodes_1_1 && !declarationNodes_1_1.done && (_b = declarationNodes_1.return)) _b.call(declarationNodes_1);
        }
        finally { if (e_2) throw e_2.error; }
    }
    try {
        // Add all inherited features to the feature collections array
        for (var heritageClauses_2 = __values(heritageClauses), heritageClauses_2_1 = heritageClauses_2.next(); !heritageClauses_2_1.done; heritageClauses_2_1 = heritageClauses_2.next()) {
            var heritageClause = heritageClauses_2_1.value;
            if (heritageClause.declaration != null) {
                featureCollections.push(exports.__assign(exports.__assign({}, heritageClause.declaration), { members: heritageClause.declaration.members }));
            }
        }
    }
    catch (e_3_1) { e_3 = { error: e_3_1 }; }
    finally {
        try {
            if (heritageClauses_2_1 && !heritageClauses_2_1.done && (_c = heritageClauses_2.return)) _c.call(heritageClauses_2);
        }
        finally { if (e_3) throw e_3.error; }
    }
    // If all nodes were excluded, return empty declaration
    if (featureCollections.length === 0) {
        return baseDeclaration;
    }
    // Merge all features into one single collection prioritizing features found in first
    var mergedFeatureCollection = mergeFeatures(featureCollections, context);
    // Refine the declaration and return the result
    var refinedDeclaration = refineDeclaration$1(exports.__assign(exports.__assign({}, baseDeclaration), { cssParts: mergedFeatureCollection.cssParts, cssProperties: mergedFeatureCollection.cssProperties, events: mergedFeatureCollection.events, methods: mergedFeatureCollection.methods, members: mergedFeatureCollection.members, slots: mergedFeatureCollection.slots }), context);
    Object.assign(baseDeclaration, refinedDeclaration);
    // Update the cache
    baseContext.cache.componentDeclarationCache.set(mainDeclarationNode, baseDeclaration);
    return baseDeclaration;
}
/**
 * Returns if a node should be excluded from the analyzing
 * @param node
 * @param context
 */
function shouldExcludeNode(node, context) {
    var _a;
    // Uses flavors to determine if the node should be excluded
    if (excludeNode$2(node, context)) {
        return true;
    }
    // It's possible to exclude declaration names
    var name = getNodeName(node, context);
    if (name != null && ((_a = context.config.excludedDeclarationNames) === null || _a === void 0 ? void 0 : _a.includes(name))) {
        return true;
    }
    return false;
}
/**
 * Returns if the declaration should be invalidated by testing
 *    if any of the inherited declarations in the tree has been invalidated
 * @param componentDeclaration
 * @param context
 */
function shouldInvalidateCachedDeclaration(componentDeclaration, context) {
    var e_4, _a;
    var _b;
    try {
        for (var _c = __values(componentDeclaration.heritageClauses), _d = _c.next(); !_d.done; _d = _c.next()) {
            var heritageClause = _d.value;
            if (heritageClause.declaration != null) {
                // This declaration shouldn't be invalidated if the existing "node.getSourceFile()" is equal to the "program.getSourceFile(...)" with the same file name,
                var node = heritageClause.declaration.node;
                var oldSourceFile = node.getSourceFile();
                var newSourceFile = context.program.getSourceFile(oldSourceFile.fileName);
                var foundInCache = (_b = (newSourceFile != null && newSourceFile === oldSourceFile)) !== null && _b !== void 0 ? _b : false;
                // Return "true" that the declaration should invalidate if it wasn't found in the cache
                if (!foundInCache) {
                    return true;
                }
                // Test the inherited declarations recursively
                if (shouldInvalidateCachedDeclaration(heritageClause.declaration, context)) {
                    return true;
                }
            }
        }
    }
    catch (e_4_1) { e_4 = { error: e_4_1 }; }
    finally {
        try {
            if (_d && !_d.done && (_a = _c.return)) _a.call(_c);
        }
        finally { if (e_4) throw e_4.error; }
    }
    return false;
}

/**
 * Visits the source file and finds all component definitions using flavors
 * @param sourceFile
 * @param context
 */
function discoverDeclarations(sourceFile, context) {
    var e_1, _a;
    var declarations = [];
    var symbol = context.checker.getSymbolAtLocation(sourceFile);
    if (symbol != null) {
        // Get all exports in the source file
        var exports_2 = context.checker.getExportsOfModule(symbol);
        try {
            // Find all class declarations in the source file
            for (var exports_1 = __values(exports_2), exports_1_1 = exports_1.next(); !exports_1_1.done; exports_1_1 = exports_1.next()) {
                var symbol_1 = exports_1_1.value;
                var node = symbol_1.valueDeclaration;
                if (node != null) {
                    if (context.ts.isClassDeclaration(node) /* || context.ts.isInterfaceDeclaration(node)*/) {
                        var nodes = resolveSymbolDeclarations(symbol_1);
                        var decl = analyzeComponentDeclaration(nodes, context);
                        if (decl != null) {
                            declarations.push(decl);
                        }
                    }
                }
            }
        }
        catch (e_1_1) { e_1 = { error: e_1_1 }; }
        finally {
            try {
                if (exports_1_1 && !exports_1_1.done && (_a = exports_1.return)) _a.call(exports_1);
            }
            finally { if (e_1) throw e_1.error; }
        }
    }
    return declarations;
}

/**
 * Executes functions in a function map until some function returns a non-undefined value.
 * @param functionMaps
 * @param keys
 * @param arg
 * @param context
 */
function executeFunctionsUntilMatch(functionMaps, keys, arg, context) {
    var e_1, _a, e_2, _b;
    keys = Array.isArray(keys) ? keys : [keys];
    try {
        for (var keys_1 = __values(keys), keys_1_1 = keys_1.next(); !keys_1_1.done; keys_1_1 = keys_1.next()) {
            var key = keys_1_1.value;
            var _loop_1 = function (functionMap) {
                var func = functionMap[key];
                if (func == null)
                    return "continue";
                // Save a "continue" flag if necessary
                var shouldContinue = false;
                var result = func(arg, exports.__assign(exports.__assign({}, context), { emitContinue: function () {
                        shouldContinue = true;
                    } }));
                // Return a result if not undefined
                if (result != null) {
                    return { value: { value: result, shouldContinue: shouldContinue } };
                }
            };
            try {
                // Loop through each function
                for (var functionMaps_1 = (e_2 = void 0, __values(functionMaps)), functionMaps_1_1 = functionMaps_1.next(); !functionMaps_1_1.done; functionMaps_1_1 = functionMaps_1.next()) {
                    var functionMap = functionMaps_1_1.value;
                    var state_1 = _loop_1(functionMap);
                    if (typeof state_1 === "object")
                        return state_1.value;
                }
            }
            catch (e_2_1) { e_2 = { error: e_2_1 }; }
            finally {
                try {
                    if (functionMaps_1_1 && !functionMaps_1_1.done && (_b = functionMaps_1.return)) _b.call(functionMaps_1);
                }
                finally { if (e_2) throw e_2.error; }
            }
        }
    }
    catch (e_1_1) { e_1 = { error: e_1_1 }; }
    finally {
        try {
            if (keys_1_1 && !keys_1_1.done && (_a = keys_1.return)) _a.call(keys_1);
        }
        finally { if (e_1) throw e_1.error; }
    }
    return undefined;
}

/**
 * Uses flavors to visit definitions
 * @param node
 * @param context
 * @param emit
 */
function visitDefinitions(node, context, emit) {
    var result = executeFunctionsUntilMatch(context.flavors, "discoverDefinitions", node, context);
    if (result != null) {
        emit(result.value);
        if (!result.shouldContinue)
            return;
    }
    // Visit child nodes
    node.forEachChild(function (child) {
        visitDefinitions(child, context, emit);
    });
}

/**
 * Visits the source file and finds all component definitions using flavors
 * @param sourceFile
 * @param context
 * @param analyzeDeclaration
 */
function discoverDefinitions$4(sourceFile, context, analyzeDeclaration) {
    // Find all definitions in the file using flavors
    var definitionResults = analyzeAndDedupeDefinitions(sourceFile, context);
    return Array.from(definitionResults.entries()).map(function (_a) {
        var _b = __read(_a, 2), definition = _b[0], declarationSet = _b[1];
        var declaration;
        var didEvaluateDeclaration = false;
        return exports.__assign(exports.__assign({}, definition), { get declaration() {
                if (!didEvaluateDeclaration) {
                    declaration = analyzeDeclaration(definition, Array.from(declarationSet));
                    didEvaluateDeclaration = true;
                }
                return declaration;
            } });
    });
}
/**
 * Finds all component definitions in a file and combine multiple declarations with same tag name.
 * @param sourceFile
 * @param context
 */
function analyzeAndDedupeDefinitions(sourceFile, context) {
    var e_1, _a, e_2, _b;
    if (sourceFile == null)
        return new Map();
    // Keep a map of "tag name" ==> "definition"
    var tagNameDefinitionMap = new Map();
    // Keep a map of "definition" ==> "declaration nodes"
    var definitionToDeclarationMap = new Map();
    // Discover definitions using flavors
    visitDefinitions(sourceFile, context, function (results) {
        var e_3, _a, e_4, _b;
        try {
            // Definitions are unique by tag name and are merged when pointing to multiple declaration nodes.
            // This is because multiple definitions can exist side by side for the same tag name (think global TagName type definition and customElements.define)
            for (var results_3 = __values(results), results_3_1 = results_3.next(); !results_3_1.done; results_3_1 = results_3.next()) {
                var result = results_3_1.value;
                // Find existing definition with the result name
                var definition = tagNameDefinitionMap.get(result.tagName);
                if (definition == null) {
                    // No existing definition was found, - create one!
                    definition = {
                        sourceFile: sourceFile,
                        tagName: result.tagName,
                        tagNameNodes: new Set(),
                        identifierNodes: new Set()
                    };
                    tagNameDefinitionMap.set(result.tagName, definition);
                }
                // Add the discovered identifier node to the definition
                if (result.identifierNode != null) {
                    definition.identifierNodes.add(result.identifierNode);
                }
                // Add the discovered tag name node to the definition
                if (result.tagNameNode) {
                    definition.tagNameNodes.add(result.tagNameNode);
                }
                // Add the discovered declaration node to the map from "definition" ==> "declaration nodes"
                var declarationNodeSet = definitionToDeclarationMap.get(definition);
                if (declarationNodeSet == null) {
                    declarationNodeSet = new Set();
                    definitionToDeclarationMap.set(definition, declarationNodeSet);
                }
                // Grab the symbol from the identifier node and get the declarations
                // If the is no symbol on the result, use "result.declarationNode" instead
                var symbol = result.identifierNode != null ? getSymbol(result.identifierNode, context) : undefined;
                var declarations = symbol != null ? resolveSymbolDeclarations(symbol) : result.declarationNode != null ? [result.declarationNode] : [];
                try {
                    for (var declarations_1 = (e_4 = void 0, __values(declarations)), declarations_1_1 = declarations_1.next(); !declarations_1_1.done; declarations_1_1 = declarations_1.next()) {
                        var decl = declarations_1_1.value;
                        declarationNodeSet.add(decl);
                    }
                }
                catch (e_4_1) { e_4 = { error: e_4_1 }; }
                finally {
                    try {
                        if (declarations_1_1 && !declarations_1_1.done && (_b = declarations_1.return)) _b.call(declarations_1);
                    }
                    finally { if (e_4) throw e_4.error; }
                }
            }
        }
        catch (e_3_1) { e_3 = { error: e_3_1 }; }
        finally {
            try {
                if (results_3_1 && !results_3_1.done && (_a = results_3.return)) _a.call(results_3);
            }
            finally { if (e_3) throw e_3.error; }
        }
    });
    // Remove duplicates where "tagName" is equals to "" if the declaration node is not used in any other definition.
    var results = Array.from(definitionToDeclarationMap.entries());
    try {
        for (var results_1 = __values(results), results_1_1 = results_1.next(); !results_1_1.done; results_1_1 = results_1.next()) {
            var _c = __read(results_1_1.value, 2), definition = _c[0], declarations = _c[1];
            if (definition.tagName === "") {
                var _loop_1 = function (checkDefinition, checkDeclarations) {
                    // Find duplicated based on overlapping declarations
                    if (definition !== checkDefinition && Array.from(declarations).find(function (decl) { return checkDeclarations.has(decl) != null; })) {
                        definitionToDeclarationMap.delete(definition);
                        return "break";
                    }
                };
                try {
                    for (var results_2 = (e_2 = void 0, __values(results)), results_2_1 = results_2.next(); !results_2_1.done; results_2_1 = results_2.next()) {
                        var _d = __read(results_2_1.value, 2), checkDefinition = _d[0], checkDeclarations = _d[1];
                        var state_1 = _loop_1(checkDefinition, checkDeclarations);
                        if (state_1 === "break")
                            break;
                    }
                }
                catch (e_2_1) { e_2 = { error: e_2_1 }; }
                finally {
                    try {
                        if (results_2_1 && !results_2_1.done && (_b = results_2.return)) _b.call(results_2);
                    }
                    finally { if (e_2) throw e_2.error; }
                }
            }
        }
    }
    catch (e_1_1) { e_1 = { error: e_1_1 }; }
    finally {
        try {
            if (results_1_1 && !results_1_1.done && (_a = results_1.return)) _a.call(results_1);
        }
        finally { if (e_1) throw e_1.error; }
    }
    return definitionToDeclarationMap;
}

/**
 * Uses flavors to find global features
 * @param node
 * @param context
 * @param emitMap
 */
function visitGlobalFeatures(node, context, emitMap) {
    var visitMaps = arrayDefined(context.flavors.map(function (flavor) { return flavor.discoverGlobalFeatures; }));
    visitFeaturesWithVisitMaps(node, context, visitMaps, emitMap);
}

/**
 * Discover all global features using flavors
 * @param node
 * @param context
 */
function discoverGlobalFeatures$3(node, context) {
    var _a = prepareRefineEmitMap(), collection = _a.collection, refineEmitMap = _a.refineEmitMap;
    // Discovers global features using flavors
    visitGlobalFeatures(node, context, {
        event: function (event) { return refineFeature$2("event", event, context, refineEmitMap); },
        member: function (memberResult) { return refineFeature$2("member", memberResult, context, refineEmitMap); },
        csspart: function (cssPart) { return refineFeature$2("csspart", cssPart, context, refineEmitMap); },
        cssproperty: function (cssProperty) { return refineFeature$2("cssproperty", cssProperty, context, refineEmitMap); },
        method: function (method) { return refineFeature$2("method", method, context, refineEmitMap); },
        slot: function (slot) { return refineFeature$2("slot", slot, context, refineEmitMap); }
    });
    // Merge features in the collection
    return mergeFeatures(collection, context);
}

/**
 * Analyzes all components in a source file.
 * @param sourceFile
 * @param options
 */
function analyzeSourceFile(sourceFile, options) {
    // Create a new context
    var context = makeContextFromConfig(options);
    // Analyze all components
    var componentDefinitions = discoverDefinitions$4(sourceFile, context, function (definition, declarationNodes) {
        // The component declaration is analyzed lazily
        return analyzeComponentDeclaration(declarationNodes, context);
    });
    // Analyze global features
    var globalFeatures = undefined;
    if (context.config.analyzeGlobalFeatures) {
        globalFeatures = discoverGlobalFeatures$3(sourceFile, context);
    }
    // Analyze exported declarations
    var declarations = undefined;
    if (context.config.analyzeAllDeclarations) {
        declarations = discoverDeclarations(sourceFile, context);
    }
    return {
        sourceFile: sourceFile,
        componentDefinitions: componentDefinitions,
        globalFeatures: globalFeatures,
        declarations: declarations
    };
}

/**
 * Returns the superclass heritage clause
 * @param declaration
 */
function getSuperclassHeritageClause(declaration) {
    return (declaration.heritageClauses.find(function (clause) { var _a; return clause.kind === "extends" && ((_a = clause.declaration) === null || _a === void 0 ? void 0 : _a.kind) === "class"; }) ||
        declaration.heritageClauses.find(function (clause) { return clause.kind === "extends" && clause.declaration == null; }));
}
/**
 * Returns mixin heritage clauses for the declaration
 * @param declaration
 */
function getMixinHeritageClauses(declaration) {
    return declaration.heritageClauses.filter(function (clause) { var _a; return clause.kind === "mixin" || ((_a = clause.declaration) === null || _a === void 0 ? void 0 : _a.kind) === "mixin"; });
}
/**
 * Returns all extends heritage clauses for the declaration
 * @param declaration
 */
function getExtendsHeritageClauses(declaration) {
    return declaration.heritageClauses.filter(function (clause) { return clause.kind === "extends"; });
}
/**
 * Returns mixin heritage clauses for the declaration and all inherited declarations
 * @param declaration
 */
function getMixinHeritageClausesInChain(declaration) {
    var clauses = [];
    visitAllHeritageClauses(declaration, function (clause) {
        if (clause.kind === "mixin") {
            clauses.push(clause);
        }
    });
    return clauses;
}
/**
 * Returns extends heritage clauses for the declaration and all inherited declarations
 * @param declaration
 */
function getExtendsHeritageClausesInChain(declaration) {
    var clauses = [];
    visitAllHeritageClauses(declaration, function (clause) {
        if (clause.kind === "extends") {
            clauses.push(clause);
        }
    });
    return clauses;
}
/**
 * A helper function that makes it possible to visit all heritage clauses in the inheritance chain.
 * @param declaration
 * @param emit
 */
function visitAllHeritageClauses(declaration, emit) {
    var e_1, _a;
    try {
        for (var _b = __values(declaration.heritageClauses), _c = _b.next(); !_c.done; _c = _b.next()) {
            var clause = _c.value;
            emit(clause);
            if (clause.declaration != null) {
                visitAllHeritageClauses(clause.declaration, emit);
            }
        }
    }
    catch (e_1_1) { e_1 = { error: e_1_1 }; }
    finally {
        try {
            if (_c && !_c.done && (_a = _b.return)) _a.call(_b);
        }
        finally { if (e_1) throw e_1.error; }
    }
}

function isTypescriptNode(value) {
    return value instanceof Object && "kind" in value && "flags" in value;
}
function isTypescriptSourceFile(value) {
    return value instanceof Object && "kind" in value && "fileName" in value;
}
function isTypescriptType(value) {
    return value instanceof Object && "flags" in value && "checker" in value;
}
/**
 * Returns a representation of the input that can be JSON stringified
 */
function stripTypescriptValues(input, checker, seenValues) {
    var e_1, _a;
    var _b, _c, _d, _e;
    if (seenValues === void 0) { seenValues = new Set(); }
    if (seenValues.has(input)) {
        return "[Circular]";
    }
    seenValues = new Set(seenValues);
    seenValues.add(input);
    if (input == null) {
        return input;
    }
    else if (typeof input === "function") {
        return stripTypescriptValues(input(), checker, seenValues);
    }
    else if (isTypescriptSourceFile(input)) {
        return "{SOURCEFILE:" + ((_b = input.fileName.match(".*/(.+)")) === null || _b === void 0 ? void 0 : _b[1]) + "}";
    }
    else if (isTypescriptNode(input)) {
        var title = "escapedText" in input ? input.escapedText : undefined;
        return "{NODE:" + ((_e = (_d = (_c = input.getSourceFile) === null || _c === void 0 ? void 0 : _c.call(input)) === null || _d === void 0 ? void 0 : _d.fileName.match(".*/(.+)")) === null || _e === void 0 ? void 0 : _e[1]) + (title != null ? ":" + title : "") + ":" + input.pos + "}";
    }
    else if (isTypescriptType(input)) {
        if (checker == null) {
            return "{TYPE}";
        }
        return "{TYPE:" + checker.typeToString(input) + "}";
    }
    else if (tsSimpleType.isSimpleType(input)) {
        return "{SIMPLE_TYPE:" + tsSimpleType.typeToString(input) + "}";
    }
    else if (Array.isArray(input)) {
        return input.map(function (i) { return stripTypescriptValues(i, checker, seenValues); });
    }
    else if (input instanceof Set) {
        return stripTypescriptValues(Array.from(input), checker, seenValues);
    }
    else if (input instanceof Map) {
        return stripTypescriptValues(Array.from(input), checker, seenValues);
    }
    else if (input instanceof Object) {
        var obj = {};
        try {
            for (var _f = __values(Object.entries(input)), _g = _f.next(); !_g.done; _g = _f.next()) {
                var _h = __read(_g.value, 2), key = _h[0], value = _h[1];
                var strippedValue = stripTypescriptValues(value, checker, seenValues);
                if (strippedValue !== undefined && (!Array.isArray(strippedValue) || strippedValue.length > 0)) {
                    obj[key] = strippedValue;
                }
            }
        }
        catch (e_1_1) { e_1 = { error: e_1_1 }; }
        finally {
            try {
                if (_g && !_g.done && (_a = _f.return)) _a.call(_f);
            }
            finally { if (e_1) throw e_1.error; }
        }
        return obj;
    }
    return input;
}

/**
 * Transforms results to json.
 * @param results
 * @param program
 * @param config
 */
var debugJsonTransformer = function (results, program, config) {
    var definitions = arrayFlat(results.map(function (res) { return res.componentDefinitions; }));
    return JSON.stringify(stripTypescriptValues(definitions, program.getTypeChecker()), null, 2);
};

/**
 * Returns a "type hint" from a type
 * The type hint is an easy to read representation of the type and is not made for being parsed.
 * @param type
 * @param checker
 * @param config
 */
function getTypeHintFromType(type, checker, config) {
    if (type == null)
        return undefined;
    if (typeof type === "string")
        return type;
    var typeHint;
    if (config.inlineTypes) {
        // Inline aliased types
        if (tsSimpleType.isSimpleType(type)) {
            // Expand a possible alias
            if (isUnionTypeAlias(type)) {
                type = type.target;
            }
            typeHint = tsSimpleType.typeToString(type);
        }
        else {
            // Transform using Typescript natively, to avoid transforming all types to simple types (overhead).
            // The "InTypeAlias" flag expands the type.
            typeHint = checker.typeToString(type, undefined, tsModule.TypeFormatFlags.InTypeAlias);
        }
    }
    else {
        // Transform types to string
        typeHint = tsSimpleType.typeToString(type, checker);
    }
    // Replace "anys" and "{}" with more human friendly representations
    if (typeHint === "any")
        return undefined;
    if (typeHint === "any[]")
        return "array";
    if (typeHint === "{}")
        return "object";
    // "CustomEvent<unknown>" and "Event" of no interest
    if (typeHint === "CustomEvent<unknown>" || typeHint === "Event")
        return undefined;
    return typeHint;
}
/**
 * Checks if a type is a type alias simple type
 * @param simpleType
 */
function isUnionTypeAlias(simpleType) {
    return simpleType.kind === "ALIAS" && simpleType.target.kind === "UNION";
}

var VISIBILITY_NUMBER_MAP = {
    private: 1,
    protected: 2,
    public: 3
};
/**
 * Removes all items from an array with visibilities that are less visible than "visibility".
 * @param visibility
 * @param array
 */
function filterVisibility(visibility, array) {
    if (visibility === void 0) { visibility = "public"; }
    var target = VISIBILITY_NUMBER_MAP[visibility];
    return array.filter(function (item) { return VISIBILITY_NUMBER_MAP[item.visibility || "public"] >= target; });
}

/**
 * Returns the first element in the set
 * @param set
 */
function getFirst(set) {
    return set.values().next().value;
}

/**
 * Transforms results to json.
 * @param results
 * @param program
 * @param config
 */
var jsonTransformer = function (results, program, config) {
    var checker = program.getTypeChecker();
    // Get all definitions
    var definitions = arrayFlat(results.map(function (res) { return res.componentDefinitions; }));
    // Transform all definitions into "tags"
    var tags = definitions.map(function (d) { return definitionToHtmlDataTag(d, checker, config); });
    var htmlData = {
        version: "experimental",
        tags: tags
    };
    return JSON.stringify(htmlData, null, 2);
};
function definitionToHtmlDataTag(definition, checker, config) {
    // Grab path to the definition file if possible
    var node = getFirst(definition.tagNameNodes) || getFirst(definition.identifierNodes);
    var fileName = node === null || node === void 0 ? void 0 : node.getSourceFile().fileName;
    var path$1 = fileName != null && config.cwd != null ? "./" + path.relative(config.cwd, fileName) : undefined;
    var declaration = definition.declaration;
    if (declaration == null) {
        return {
            name: definition.tagName,
            path: path$1
        };
    }
    var attributes = arrayDefined(filterVisibility(config.visibility, declaration.members).map(function (d) { return componentMemberToHtmlDataAttribute(d, checker, config); }));
    var properties = arrayDefined(filterVisibility(config.visibility, declaration.members).map(function (d) { return componentMemberToHtmlDataProperty(d, checker, config); }));
    var events = arrayDefined(filterVisibility(config.visibility, declaration.events).map(function (e) { return componentEventToHtmlDataEvent(e); }));
    var slots = arrayDefined(declaration.slots.map(function (e) { return componentSlotToHtmlDataSlot(e); }));
    var cssProperties = arrayDefined(declaration.cssProperties.map(function (p) { return componentCssPropToHtmlCssProp(p); }));
    var cssParts = arrayDefined(declaration.cssParts.map(function (p) { return componentCssPartToHtmlCssPart(p); }));
    return {
        name: definition.tagName,
        path: path$1,
        description: getDescriptionFromJsDoc(declaration.jsDoc),
        attributes: attributes.length === 0 ? undefined : attributes,
        properties: properties.length === 0 ? undefined : properties,
        events: events.length === 0 ? undefined : events,
        slots: slots.length === 0 ? undefined : slots,
        cssProperties: cssProperties.length === 0 ? undefined : cssProperties,
        cssParts: cssParts.length === 0 ? undefined : cssParts,
        deprecated: declaration.deprecated === true || typeof declaration.deprecated === "string" || undefined,
        deprecatedMessage: typeof declaration.deprecated === "string" ? declaration.deprecated : undefined
    };
}
function componentCssPropToHtmlCssProp(prop, checker) {
    return {
        name: prop.name || "",
        description: getDescriptionFromJsDoc(prop.jsDoc),
        type: prop.typeHint,
        default: prop.default != null ? JSON.stringify(prop.default) : undefined
    };
}
function componentCssPartToHtmlCssPart(part, checker) {
    return {
        name: part.name || "",
        description: getDescriptionFromJsDoc(part.jsDoc)
    };
}
function componentSlotToHtmlDataSlot(slot, checker) {
    return {
        name: slot.name || "",
        description: getDescriptionFromJsDoc(slot.jsDoc)
    };
}
function componentEventToHtmlDataEvent(event, checker) {
    return {
        name: event.name,
        description: getDescriptionFromJsDoc(event.jsDoc),
        deprecated: event.deprecated === true || undefined,
        deprecatedMessage: typeof event.deprecated === "string" ? event.deprecated : undefined
    };
}
function componentMemberToHtmlDataAttribute(member, checker, config) {
    var _a, _b;
    if (member.attrName == null) {
        return undefined;
    }
    return {
        name: member.attrName,
        description: getDescriptionFromJsDoc(member.jsDoc),
        type: getTypeHintFromType((_a = member.typeHint) !== null && _a !== void 0 ? _a : (_b = member.type) === null || _b === void 0 ? void 0 : _b.call(member), checker, config),
        default: member.default != null ? JSON.stringify(member.default) : undefined,
        deprecated: member.deprecated === true || undefined,
        deprecatedMessage: typeof member.deprecated === "string" ? member.deprecated : undefined
    };
}
function componentMemberToHtmlDataProperty(member, checker, config) {
    var _a, _b;
    if (member.propName == null) {
        return undefined;
    }
    return {
        name: member.propName,
        attribute: member.attrName,
        description: getDescriptionFromJsDoc(member.jsDoc),
        type: getTypeHintFromType((_a = member.typeHint) !== null && _a !== void 0 ? _a : (_b = member.type) === null || _b === void 0 ? void 0 : _b.call(member), checker, config),
        default: member.default != null ? JSON.stringify(member.default) : undefined,
        deprecated: member.deprecated === true || undefined,
        deprecatedMessage: typeof member.deprecated === "string" ? member.deprecated : undefined
    };
}
function getDescriptionFromJsDoc(jsDoc) {
    return jsDoc === null || jsDoc === void 0 ? void 0 : jsDoc.description;
}

/**
 * This method returns a "type hint" that represents the method signature
 * The resulting type takes jsdoc into account.
 * I couldn't find a way for Typescript to return the signature string taking jsdoc into account
 *   so therefore I had to do some regex-magic in this method.
 */
function getTypeHintFromMethod(method, checker) {
    var e_1, _a;
    var _b, _c, _d, _e, _f, _g, _h;
    var signature = getTypeHintFromType((_b = method.type) === null || _b === void 0 ? void 0 : _b.call(method), checker, {}) || "";
    // Replace "=>" with ":" and the return type with the returnTypeHint if present
    signature = signature.replace(/\)\s*=>\s?(.*)$/, "): " + ((_f = (_e = (_d = (_c = method.jsDoc) === null || _c === void 0 ? void 0 : _c.tags) === null || _d === void 0 ? void 0 : _d.find(function (tag) { return ["returns", "return"].includes(tag.tag); })) === null || _e === void 0 ? void 0 : _e.parsed().type) !== null && _f !== void 0 ? _f : "$1"));
    try {
        // Replace all "any" types with corresponding type hints
        for (var _j = __values(((_h = (_g = method.jsDoc) === null || _g === void 0 ? void 0 : _g.tags) === null || _h === void 0 ? void 0 : _h.filter(function (tag) { return tag.tag === "param"; })) || []), _k = _j.next(); !_k.done; _k = _j.next()) {
            var parameterJsDocTag = _k.value;
            var parsed = parameterJsDocTag.parsed();
            if (parsed.type != null) {
                signature = signature.replace(new RegExp(parsed.name + "(.*?:\\s*)any\\[?]?"), parsed.name + "$1" + parsed.type);
            }
        }
    }
    catch (e_1_1) { e_1 = { error: e_1_1 }; }
    finally {
        try {
            if (_k && !_k.done && (_a = _j.return)) _a.call(_j);
        }
        finally { if (e_1) throw e_1.error; }
    }
    // Replace "{}" with more pleasant string
    signature = signature.replace("{}", "object");
    return signature;
}

/**
 * Transforms results to json using the schema found in the PR at https://github.com/webcomponents/custom-elements-json/pull/9
 * @param results
 * @param program
 * @param config
 */
var json2Transformer = function (results, program, config) {
    var context = {
        config: config,
        checker: program.getTypeChecker(),
        program: program,
        ts: tsModule
    };
    // Flatten analyzer results expanding inherited declarations into the declaration array.
    var flattenedAnalyzerResults = flattenAnalyzerResults(results);
    // Transform all analyzer results into modules
    var modules = flattenedAnalyzerResults.map(function (result) { return analyzerResultToModuleDoc(result, context); });
    var htmlData = {
        version: "experimental",
        modules: modules
    };
    return JSON.stringify(htmlData, null, 2);
};
/**
 * Transforms an analyzer result into a module doc
 * @param result
 * @param context
 */
function analyzerResultToModuleDoc(result, context) {
    // Get all export docs from the analyzer result
    var exports = getExportsDocsFromAnalyzerResult(result, context);
    return {
        path: getRelativePath(result.sourceFile.fileName, context),
        exports: exports.length === 0 ? undefined : exports
    };
}
/**
 * Returns ExportDocs in an analyzer result
 * @param result
 * @param context
 */
function getExportsDocsFromAnalyzerResult(result, context) {
    // Return all class- and variable-docs
    return __spread(getDefinitionDocsFromAnalyzerResult(result, context), getClassDocsFromAnalyzerResult(result, context), getVariableDocsFromAnalyzerResult(result, context), getFunctionDocsFromAnalyzerResult());
}
/**
 * Returns FunctionDocs in an analyzer result
 * @param result
 * @param context
 */
function getFunctionDocsFromAnalyzerResult(result, context) {
    // TODO: support function exports
    return [];
}
function getDefinitionDocsFromAnalyzerResult(result, context) {
    return arrayDefined(result.componentDefinitions.map(function (definition) {
        // It's not possible right now to model a tag name where the
        //   declaration couldn't be resolved because the "declaration" is required
        if (definition.declaration == null) {
            return undefined;
        }
        return {
            kind: "definition",
            name: definition.tagName,
            declaration: getReferenceForNode(definition.declaration.node, context)
        };
    }));
}
/**
 * Returns VariableDocs in an analyzer result
 * @param result
 * @param context
 */
function getVariableDocsFromAnalyzerResult(result, context) {
    var e_1, _a;
    var varDocs = [];
    // Get all export symbols in the source file
    var symbol = context.checker.getSymbolAtLocation(result.sourceFile);
    if (symbol == null) {
        return [];
    }
    var exports = context.checker.getExportsOfModule(symbol);
    try {
        // Convert all export variables to VariableDocs
        for (var exports_1 = __values(exports), exports_1_1 = exports_1.next(); !exports_1_1.done; exports_1_1 = exports_1.next()) {
            var exp = exports_1_1.value;
            switch (exp.flags) {
                case tsModule.SymbolFlags.BlockScopedVariable:
                case tsModule.SymbolFlags.Variable: {
                    var node = exp.valueDeclaration;
                    if (tsModule.isVariableDeclaration(node)) {
                        // Get the nearest variable statement in order to read the jsdoc
                        var variableStatement = findParent(node, tsModule.isVariableStatement) || node;
                        var jsDoc = getJsDoc(variableStatement, tsModule);
                        varDocs.push({
                            kind: "variable",
                            name: node.name.getText(),
                            description: jsDoc === null || jsDoc === void 0 ? void 0 : jsDoc.description,
                            type: getTypeHintFromType(context.checker.getTypeAtLocation(node), context.checker, context.config),
                            summary: getSummaryFromJsDoc(jsDoc)
                        });
                    }
                    break;
                }
            }
        }
    }
    catch (e_1_1) { e_1 = { error: e_1_1 }; }
    finally {
        try {
            if (exports_1_1 && !exports_1_1.done && (_a = exports_1.return)) _a.call(exports_1);
        }
        finally { if (e_1) throw e_1.error; }
    }
    return varDocs;
}
/**
 * Returns ClassDocs in an analyzer result
 * @param result
 * @param context
 */
function getClassDocsFromAnalyzerResult(result, context) {
    var e_2, _a;
    var classDocs = [];
    try {
        // Convert all declarations to class docs
        for (var _b = __values(result.declarations || []), _c = _b.next(); !_c.done; _c = _b.next()) {
            var decl = _c.value;
            var doc = getExportsDocFromDeclaration(decl, result, context);
            if (doc != null) {
                classDocs.push(doc);
            }
        }
    }
    catch (e_2_1) { e_2 = { error: e_2_1 }; }
    finally {
        try {
            if (_c && !_c.done && (_a = _b.return)) _a.call(_b);
        }
        finally { if (e_2) throw e_2.error; }
    }
    return classDocs;
}
/**
 * Converts a component declaration to ClassDoc, CustomElementDoc or MixinDoc
 * @param declaration
 * @param result
 * @param context
 */
function getExportsDocFromDeclaration(declaration, result, context) {
    var _a, _b;
    // Only include "mixin" and "class" in the output. Interfaces are not outputted..
    if (declaration.kind === "interface") {
        return undefined;
    }
    // Get the superclass of this declaration
    var superclassHeritage = getSuperclassHeritageClause(declaration);
    var superclassRef = superclassHeritage == null ? undefined : getReferenceFromHeritageClause(superclassHeritage, context);
    // Get all mixins
    var mixinHeritage = getMixinHeritageClauses(declaration);
    var mixinRefs = arrayDefined(mixinHeritage.map(function (h) { return getReferenceFromHeritageClause(h, context); }));
    var members = getClassMemberDocsFromDeclaration(declaration, context);
    var classDoc = {
        kind: "class",
        superclass: superclassRef,
        mixins: mixinRefs.length > 0 ? mixinRefs : undefined,
        description: (_a = declaration.jsDoc) === null || _a === void 0 ? void 0 : _a.description,
        name: ((_b = declaration.symbol) === null || _b === void 0 ? void 0 : _b.name) || getNodeName(declaration.node, { ts: tsModule }) || "",
        members: members.length > 0 ? members : undefined,
        summary: getSummaryFromJsDoc(declaration.jsDoc)
    };
    // Find the first corresponding custom element definition for this declaration
    var definition = result.componentDefinitions.find(function (def) { var _a; return ((_a = def.declaration) === null || _a === void 0 ? void 0 : _a.node) === declaration.node; });
    if (definition != null) {
        var events = getEventDocsFromDeclaration(declaration, context);
        var slots = getSlotDocsFromDeclaration(declaration, context);
        var attributes = getAttributeDocsFromDeclaration(declaration, context);
        var cssProperties = getCSSPropertyDocsFromDeclaration(declaration, context);
        var cssParts = getCSSPartDocsFromDeclaration(declaration, context);
        // Return a custom element doc if a definition was found
        var customElementDoc = exports.__assign(exports.__assign({}, classDoc), { tagName: definition.tagName, events: events.length > 0 ? events : undefined, slots: slots.length > 0 ? slots : undefined, attributes: attributes.length > 0 ? attributes : undefined, cssProperties: cssProperties.length > 0 ? cssProperties : undefined, cssParts: cssParts.length > 0 ? cssParts : undefined });
        return customElementDoc;
    }
    return classDoc;
}
/**
 * Returns event docs for a declaration
 * @param declaration
 * @param context
 */
function getEventDocsFromDeclaration(declaration, context) {
    return filterVisibility(context.config.visibility, declaration.events).map(function (event) {
        var _a, _b;
        var type = ((_a = event.type) === null || _a === void 0 ? void 0 : _a.call(event)) || { kind: "ANY" };
        var simpleType = tsSimpleType.isSimpleType(type) ? type : tsSimpleType.toSimpleType(type, context.checker);
        var typeName = simpleType.kind === "GENERIC_ARGUMENTS" ? simpleType.target.name : simpleType.name;
        var customEventDetailType = typeName === "CustomEvent" && simpleType.kind === "GENERIC_ARGUMENTS" ? simpleType.typeArguments[0] : undefined;
        return {
            description: (_b = event.jsDoc) === null || _b === void 0 ? void 0 : _b.description,
            name: event.name,
            inheritedFrom: getInheritedFromReference(declaration, event, context),
            type: typeName == null || simpleType.kind === "ANY" ? "Event" : typeName,
            detailType: customEventDetailType != null ? getTypeHintFromType(customEventDetailType, context.checker, context.config) : undefined
        };
    });
}
/**
 * Returns slot docs for a declaration
 * @param declaration
 * @param context
 */
function getSlotDocsFromDeclaration(declaration, context) {
    return declaration.slots.map(function (slot) {
        var _a;
        return ({
            description: (_a = slot.jsDoc) === null || _a === void 0 ? void 0 : _a.description,
            name: slot.name || "",
            inheritedFrom: getInheritedFromReference(declaration, slot, context)
        });
    });
}
/**
 * Returns css properties for a declaration
 * @param declaration
 * @param context
 */
function getCSSPropertyDocsFromDeclaration(declaration, context) {
    return declaration.cssProperties.map(function (cssProperty) {
        var _a;
        return ({
            name: cssProperty.name,
            description: (_a = cssProperty.jsDoc) === null || _a === void 0 ? void 0 : _a.description,
            type: cssProperty.typeHint,
            default: cssProperty.default != null ? JSON.stringify(cssProperty.default) : undefined,
            inheritedFrom: getInheritedFromReference(declaration, cssProperty, context)
        });
    });
}
/**
 * Returns css parts for a declaration
 * @param declaration
 * @param context
 */
function getCSSPartDocsFromDeclaration(declaration, context) {
    return declaration.cssParts.map(function (cssPart) {
        var _a;
        return ({
            name: cssPart.name,
            description: (_a = cssPart.jsDoc) === null || _a === void 0 ? void 0 : _a.description,
            inheritedFrom: getInheritedFromReference(declaration, cssPart, context)
        });
    });
}
/**
 * Returns attribute docs for a declaration
 * @param declaration
 * @param context
 */
function getAttributeDocsFromDeclaration(declaration, context) {
    var e_3, _a;
    var _b, _c;
    var attributeDocs = [];
    try {
        for (var _d = __values(filterVisibility(context.config.visibility, declaration.members)), _e = _d.next(); !_e.done; _e = _d.next()) {
            var member = _e.value;
            if (member.attrName != null) {
                attributeDocs.push({
                    name: member.attrName,
                    fieldName: member.propName,
                    defaultValue: member.default != null ? JSON.stringify(member.default) : undefined,
                    description: (_b = member.jsDoc) === null || _b === void 0 ? void 0 : _b.description,
                    type: getTypeHintFromType(member.typeHint || ((_c = member.type) === null || _c === void 0 ? void 0 : _c.call(member)), context.checker, context.config),
                    inheritedFrom: getInheritedFromReference(declaration, member, context)
                });
            }
        }
    }
    catch (e_3_1) { e_3 = { error: e_3_1 }; }
    finally {
        try {
            if (_e && !_e.done && (_a = _d.return)) _a.call(_d);
        }
        finally { if (e_3) throw e_3.error; }
    }
    return attributeDocs;
}
/**
 * Returns class member docs for a declaration
 * @param declaration
 * @param context
 */
function getClassMemberDocsFromDeclaration(declaration, context) {
    return __spread(getFieldDocsFromDeclaration(declaration, context), getMethodDocsFromDeclaration(declaration, context));
}
/**
 * Returns method docs for a declaration
 * @param declaration
 * @param context
 */
function getMethodDocsFromDeclaration(declaration, context) {
    var e_4, _a, e_5, _b;
    var _c;
    var methodDocs = [];
    try {
        for (var _d = __values(filterVisibility(context.config.visibility, declaration.methods)), _e = _d.next(); !_e.done; _e = _d.next()) {
            var method = _e.value;
            var parameters = [];
            var returnType = undefined;
            var node = method.node;
            if (node !== undefined && tsModule.isMethodDeclaration(node)) {
                try {
                    // Build a list of parameters
                    for (var _f = (e_5 = void 0, __values(node.parameters)), _g = _f.next(); !_g.done; _g = _f.next()) {
                        var param = _g.value;
                        var name_1 = param.name.getText();
                        var _h = getParameterFromJsDoc(name_1, method.jsDoc), description = _h.description, typeHint = _h.typeHint;
                        parameters.push({
                            name: name_1,
                            type: getTypeHintFromType(typeHint || (param.type != null ? context.checker.getTypeAtLocation(param.type) : undefined), context.checker, context.config),
                            description: description
                        });
                    }
                }
                catch (e_5_1) { e_5 = { error: e_5_1 }; }
                finally {
                    try {
                        if (_g && !_g.done && (_b = _f.return)) _b.call(_f);
                    }
                    finally { if (e_5) throw e_5.error; }
                }
                // Get return type
                var signature = context.checker.getSignatureFromDeclaration(node);
                if (signature != null) {
                    returnType = context.checker.getReturnTypeOfSignature(signature);
                }
            }
            // Get return info from jsdoc
            var _j = getReturnFromJsDoc(method.jsDoc), returnDescription = _j.description, returnTypeHint = _j.typeHint;
            methodDocs.push({
                kind: "method",
                name: method.name,
                privacy: method.visibility,
                type: getTypeHintFromMethod(method, context.checker),
                description: (_c = method.jsDoc) === null || _c === void 0 ? void 0 : _c.description,
                parameters: parameters,
                return: {
                    description: returnDescription,
                    type: getTypeHintFromType(returnTypeHint || returnType, context.checker, context.config)
                },
                inheritedFrom: getInheritedFromReference(declaration, method, context),
                summary: getSummaryFromJsDoc(method.jsDoc)
                // TODO: "static"
            });
        }
    }
    catch (e_4_1) { e_4 = { error: e_4_1 }; }
    finally {
        try {
            if (_e && !_e.done && (_a = _d.return)) _a.call(_d);
        }
        finally { if (e_4) throw e_4.error; }
    }
    return methodDocs;
}
/**
 * Returns field docs from a declaration
 * @param declaration
 * @param context
 */
function getFieldDocsFromDeclaration(declaration, context) {
    var e_6, _a;
    var _b, _c;
    var fieldDocs = [];
    try {
        for (var _d = __values(filterVisibility(context.config.visibility, declaration.members)), _e = _d.next(); !_e.done; _e = _d.next()) {
            var member = _e.value;
            if (member.propName != null) {
                fieldDocs.push({
                    kind: "field",
                    name: member.propName,
                    privacy: member.visibility,
                    description: (_b = member.jsDoc) === null || _b === void 0 ? void 0 : _b.description,
                    type: getTypeHintFromType(member.typeHint || ((_c = member.type) === null || _c === void 0 ? void 0 : _c.call(member)), context.checker, context.config),
                    default: member.default != null ? JSON.stringify(member.default) : undefined,
                    inheritedFrom: getInheritedFromReference(declaration, member, context),
                    summary: getSummaryFromJsDoc(member.jsDoc)
                    // TODO: "static"
                });
            }
        }
    }
    catch (e_6_1) { e_6 = { error: e_6_1 }; }
    finally {
        try {
            if (_e && !_e.done && (_a = _d.return)) _a.call(_d);
        }
        finally { if (e_6) throw e_6.error; }
    }
    return fieldDocs;
}
function getInheritedFromReference(onDeclaration, feature, context) {
    if (feature.declaration != null && feature.declaration !== onDeclaration) {
        return getReferenceForNode(feature.declaration.node, context);
    }
    return undefined;
}
/**
 * Returns a Reference to a node
 * @param node
 * @param context
 */
function getReferenceForNode(node, context) {
    var sourceFile = node.getSourceFile();
    var name = getNodeName(node, context);
    // Test if the source file is from a typescript lib
    // TODO: Find a better way of checking this
    var isLib = sourceFile.isDeclarationFile && sourceFile.fileName.match(/typescript\/lib.*\.d\.ts$/) != null;
    if (isLib) {
        // Only return the name of the declaration if it's from lib
        return {
            name: name
        };
    }
    // Test if the source file is located in a package
    var packageName = getPackageName(sourceFile);
    if (packageName != null) {
        return {
            name: name,
            package: packageName
        };
    }
    // Get the module path name
    var module = getRelativePath(sourceFile.fileName, context);
    return {
        name: name,
        module: module
    };
}
/**
 * Returns the name of the package (if any)
 * @param sourceFile
 */
function getPackageName(sourceFile) {
    // TODO: Make it possible to access the ModuleResolutionHost
    //  in order to resolve the package using "resolveModuleNames"
    //  The following approach is very, very naive and is only temporary.
    var match = sourceFile.fileName.match(/node_modules\/(.*?)\//);
    if (match != null) {
        return match[1];
    }
    return undefined;
}
/**
 * Returns a relative path based on "cwd" in the config
 * @param fullPath
 * @param context
 */
function getRelativePath(fullPath, context) {
    return context.config.cwd != null ? "./" + path.relative(context.config.cwd, fullPath) : path.basename(fullPath);
}
/**
 * Returns description and typeHint based on jsdoc for a specific parameter name
 * @param name
 * @param jsDoc
 */
function getParameterFromJsDoc(name, jsDoc) {
    var e_7, _a;
    if ((jsDoc === null || jsDoc === void 0 ? void 0 : jsDoc.tags) == undefined) {
        return {};
    }
    try {
        for (var _b = __values(jsDoc.tags), _c = _b.next(); !_c.done; _c = _b.next()) {
            var tag = _c.value;
            var parsed = tag.parsed();
            if (parsed.tag === "param" && parsed.name === name) {
                return { description: parsed.description, typeHint: parsed.type };
            }
        }
    }
    catch (e_7_1) { e_7 = { error: e_7_1 }; }
    finally {
        try {
            if (_c && !_c.done && (_a = _b.return)) _a.call(_b);
        }
        finally { if (e_7) throw e_7.error; }
    }
    return {};
}
/**
 * Get return description and return typeHint from jsdoc
 * @param jsDoc
 */
function getReturnFromJsDoc(jsDoc) {
    var _a;
    var tag = (_a = jsDoc === null || jsDoc === void 0 ? void 0 : jsDoc.tags) === null || _a === void 0 ? void 0 : _a.find(function (tag) { return ["returns", "return"].includes(tag.tag); });
    if (tag == null) {
        return {};
    }
    var parsed = tag.parsed();
    return { description: parsed.description, typeHint: parsed.type };
}
/**
 * Converts a heritage clause into a reference
 * @param heritage
 * @param context
 */
function getReferenceFromHeritageClause(heritage, context) {
    var _a;
    var node = (_a = heritage.declaration) === null || _a === void 0 ? void 0 : _a.node;
    var identifier = heritage.identifier;
    // Return a reference for this node if any
    if (node != null) {
        return getReferenceForNode(node, context);
    }
    // Try to get declaration of the identifier if no node was found
    var _b = __read(resolveDeclarations(identifier, context), 1), declaration = _b[0];
    if (declaration != null) {
        return getReferenceForNode(declaration, context);
    }
    // Just return the name of the reference if nothing could be resolved
    var name = getNodeName(identifier, context);
    if (name != null) {
        return { name: name };
    }
    return undefined;
}
/**
 * Flatten all analyzer results with inherited declarations
 * @param results
 */
function flattenAnalyzerResults(results) {
    var e_8, _a, e_9, _b;
    // Keep track of declarations in each source file
    var declarationMap = new Map();
    /**
     * Add a declaration to the declaration map
     * @param declaration
     */
    function addDeclarationToMap(declaration) {
        var sourceFile = declaration.node.getSourceFile();
        var exportDocs = declarationMap.get(sourceFile) || new Set();
        if (!declarationMap.has(sourceFile)) {
            declarationMap.set(sourceFile, exportDocs);
        }
        exportDocs.add(declaration);
    }
    try {
        for (var results_1 = __values(results), results_1_1 = results_1.next(); !results_1_1.done; results_1_1 = results_1.next()) {
            var result = results_1_1.value;
            try {
                for (var _c = (e_9 = void 0, __values(result.declarations || [])), _d = _c.next(); !_d.done; _d = _c.next()) {
                    var decl = _d.value;
                    // Add all existing declarations to the map
                    addDeclarationToMap(decl);
                    visitAllHeritageClauses(decl, function (clause) {
                        // Flatten all component declarations
                        if (clause.declaration != null) {
                            addDeclarationToMap(clause.declaration);
                        }
                    });
                }
            }
            catch (e_9_1) { e_9 = { error: e_9_1 }; }
            finally {
                try {
                    if (_d && !_d.done && (_b = _c.return)) _b.call(_c);
                }
                finally { if (e_9) throw e_9.error; }
            }
        }
    }
    catch (e_8_1) { e_8 = { error: e_8_1 }; }
    finally {
        try {
            if (results_1_1 && !results_1_1.done && (_a = results_1.return)) _a.call(results_1);
        }
        finally { if (e_8) throw e_8.error; }
    }
    // Return new results with flattened declarations
    return results.map(function (result) {
        var declarations = declarationMap.get(result.sourceFile);
        return exports.__assign(exports.__assign({}, result), { declarations: declarations != null ? Array.from(declarations) : result.declarations });
    });
}
/**
 * Returns the content of the summary jsdoc tag if any
 * @param jsDoc
 */
function getSummaryFromJsDoc(jsDoc) {
    var _a;
    var summaryTag = (_a = jsDoc === null || jsDoc === void 0 ? void 0 : jsDoc.tags) === null || _a === void 0 ? void 0 : _a.find(function (tag) { return tag.tag === "summary"; });
    if (summaryTag == null) {
        return undefined;
    }
    return summaryTag.comment;
}

/**
 * Parses and returns examples for a component.
 * @param declaration
 */
function getExamplesFromComponent(declaration) {
    var _a, _b;
    var examples = ((_b = (_a = declaration.jsDoc) === null || _a === void 0 ? void 0 : _a.tags) === null || _b === void 0 ? void 0 : _b.filter(function (tag) { return tag.tag === "example" || tag.tag === "demo"; })) || [];
    return examples.map(exampleFromJsDocTag);
}
/**
 * Returns an example based on a jsdoc tag
 * @param tag
 */
function exampleFromJsDocTag(tag) {
    var _a = discoverCodeFromExampleText(tag.comment || ""), code = _a.code, lang = _a.lang, description = _a.description;
    return {
        lang: lang,
        description: description,
        code: code
    };
}
/**
 * Parses some text and returns the first found example
 * @param text
 */
function discoverCodeFromExampleText(text) {
    // Check if there is a code example already like this: ```code here ```
    var escapedCodeMatch = text.match(/([\s\S]*)```(\S*)([\s\S]+)```/);
    if (escapedCodeMatch != null) {
        return {
            description: (escapedCodeMatch[1] || "").trim() || undefined,
            lang: escapedCodeMatch[2] || undefined,
            code: (escapedCodeMatch[3] || "").trim()
        };
    }
    // Else, assume that the text is the code
    return { code: text.trim(), lang: discoverLanguageFromExampleText(text) };
}
/**
 * Returns the language of some code based on assumptions
 * @param code
 */
function discoverLanguageFromExampleText(code) {
    if (code.includes("html`")) {
        return "javascript";
    }
    if (code.match(/<\S/)) {
        return "html";
    }
    return "javascript";
}

/**
 * Returns a markdown header with a specific level taking global start title level into account.
 * @param title
 * @param level
 * @param config
 */
function markdownHeader(title, level, config) {
    var _a, _b;
    level = level - 1 + (((_a = config.markdown) === null || _a === void 0 ? void 0 : _a.headerLevel) || ((_b = config.markdown) === null || _b === void 0 ? void 0 : _b.titleLevel) || 1);
    return "#".repeat(level) + " " + title;
}
/**
 * Returns a markdown table representation of the rows.
 * Strips unused columns.
 * @param rows
 * @param removeEmptyColumns
 */
function markdownTable(rows, _a) {
    var removeEmptyColumns = (_a === void 0 ? { removeEmptyColumns: true } : _a).removeEmptyColumns;
    // Constants for pretty printing the markdown tables
    var MIN_CELL_WIDTH = 3;
    var MAX_CELL_WIDTH = 50;
    var CELL_PADDING = 1;
    // Count the number of columns
    var columnCount = Math.max.apply(Math, __spread(rows.map(function (r) { return r.length; })));
    if (removeEmptyColumns) {
        // Create a boolean array where each entry tells if a column is used or not (excluding the header)
        var emptyColumns_1 = Array(columnCount)
            .fill(false)
            .map(function (b, i) { return i !== 0 && rows.slice(1).find(function (r) { return r[i] != null && r[i].length > 0; }) == null; });
        // Remove unused columns if necessary
        if (emptyColumns_1.includes(true)) {
            // Filter out the unused columns in each row
            rows = rows.map(function (row) { return row.filter(function (column, i) { return !emptyColumns_1[i]; }); });
            // Adjust the column count
            columnCount = Math.max.apply(Math, __spread(rows.map(function (r) { return r.length; })));
        }
    }
    // Escape all cells in the markdown output
    rows = rows.map(function (r) { return r.map(markdownEscapeTableCell); });
    // Create a boolean array where each entry corresponds to the preferred column width.
    // This is done by taking the largest width of all cells in each column.
    var columnWidths = Array(columnCount)
        .fill(0)
        .map(function (c, i) { return Math.min(MAX_CELL_WIDTH, Math.max.apply(Math, __spread([MIN_CELL_WIDTH], rows.map(function (r) { return (r[i] || "").length; }))) + CELL_PADDING * 2); });
    // Build up the table
    return "\n|" + rows[0].map(function (r, i) { return fillWidth(r, columnWidths[i], CELL_PADDING); }).join("|") + "|\n|" + columnWidths.map(function (c) { return "-".repeat(c); }).join("|") + "|\n" + rows
        .slice(1)
        .map(function (r) { return "|" + r.map(function (r, i) { return fillWidth(r, columnWidths[i], CELL_PADDING); }).join("|") + "|"; })
        .join("\n") + "\n";
}
/**
 * Escape a text so it can be used in a markdown table
 * @param text
 */
function markdownEscapeTableCell(text) {
    return text.replace(/\n/g, "<br />").replace(/\|/g, "\\|");
}
/**
 * Highlights some text
 * @param text
 */
function markdownHighlight(text) {
    if (text == null || text.length === 0)
        return "";
    return "`" + text + "`";
}
/**
 * Creates padding around some text with a target width.
 * @param text
 * @param width
 * @param paddingStart
 */
function fillWidth(text, width, paddingStart) {
    return " ".repeat(paddingStart) + text + " ".repeat(Math.max(1, width - text.length - paddingStart));
}

/**
 * Transforms the component results to markdown
 * @param results
 * @param program
 * @param config
 */
var markdownTransformer = function (results, program, config) {
    // Grab all definitions
    var definitions = arrayFlat(results.map(function (res) { return res.componentDefinitions; }));
    // Transform all definitions to markdown
    var markdownSegments = arrayDefined(definitions.map(function (definition) {
        var e_1, _a;
        var _b, _c;
        // Add tagName as header
        var segmentText = markdownHeader(definition.tagName, 1, config) + "\n";
        var declaration = definition.declaration;
        if (declaration == null) {
            return undefined;
        }
        // Add component jsdoc comment to the output
        if (((_b = declaration.jsDoc) === null || _b === void 0 ? void 0 : _b.description) != null)
            segmentText += "\n" + ((_c = declaration.jsDoc) === null || _c === void 0 ? void 0 : _c.description) + "\n";
        // Add mixins (don't include mixins prefixed with _)
        var mixins = arrayDedupe(arrayDefined(getMixinHeritageClausesInChain(declaration).map(function (clause) { var _a, _b; return ((_b = (_a = clause.declaration) === null || _a === void 0 ? void 0 : _a.symbol) === null || _b === void 0 ? void 0 : _b.name) || clause.identifier.getText(); })).filter(function (name) { return !name.startsWith("_"); }));
        if (mixins.length > 0) {
            segmentText += "\n**Mixins:** " + mixins.join(", ") + "\n";
        }
        // Add examples
        var examples = getExamplesFromComponent(declaration);
        if (examples.length > 0) {
            segmentText += "\n" + markdownHeader("Example" + (examples.length > 1 ? "s" : ""), 2, config) + "\n";
            try {
                for (var examples_1 = __values(examples), examples_1_1 = examples_1.next(); !examples_1_1.done; examples_1_1 = examples_1.next()) {
                    var example = examples_1_1.value;
                    if (example.description != null) {
                        segmentText += "\n" + example.description + "\n";
                    }
                    segmentText += "\n```" + (example.lang || "") + "\n" + example.code + "\n```\n";
                }
            }
            catch (e_1_1) { e_1 = { error: e_1_1 }; }
            finally {
                try {
                    if (examples_1_1 && !examples_1_1.done && (_a = examples_1.return)) _a.call(examples_1);
                }
                finally { if (e_1) throw e_1.error; }
            }
        }
        // Grab all items from the component and add them as tables to the output.
        var properties = filterVisibility(config.visibility, declaration.members
            .filter(function (m) { return m.kind === "property"; })
            .filter(function (m) { return m.modifiers == null || !m.modifiers.has("static"); })).sort(function (a, b) { return (a.propName < b.propName ? -1 : 1); });
        var attributes = filterVisibility(config.visibility, declaration.members.filter(function (m) { return m.kind === "attribute"; })).sort(function (a, b) { return (a.attrName < b.attrName ? -1 : 1); });
        var methods = filterVisibility(config.visibility, declaration.methods).sort(function (a, b) { return (a.name < b.name ? -1 : 1); });
        var slots = declaration.slots.sort(function (a, b) { return (a.name == null ? -1 : b.name == null ? 1 : a.name < b.name ? -1 : 1); });
        var events = declaration.events.sort(function (a, b) { return (a.name < b.name ? -1 : 1); });
        var cssProps = declaration.cssProperties.sort(function (a, b) { return (a.name < b.name ? -1 : 1); });
        var cssParts = declaration.cssParts.sort(function (a, b) { return (a.name < b.name ? -1 : 1); });
        if (attributes.length > 0) {
            segmentText += "\n" + memberAttributeSection(attributes, program.getTypeChecker(), config);
        }
        if (properties.length > 0) {
            segmentText += "\n" + memberPropertySection(properties, program.getTypeChecker(), config);
        }
        if (methods.length > 0) {
            segmentText += "\n" + methodSection(methods, program.getTypeChecker(), config);
        }
        if (events.length > 0) {
            segmentText += "\n" + eventSection(events, program.getTypeChecker(), config);
        }
        if (slots.length > 0) {
            segmentText += "\n" + slotSection(slots, config);
        }
        if (cssParts.length > 0) {
            segmentText += "\n" + cssPartSection(cssParts, config);
        }
        if (cssProps.length > 0) {
            segmentText += "\n" + cssPropSection(cssProps, config);
        }
        return segmentText;
    }));
    return markdownSegments.join("\n\n");
};
/**
 * Returns a markdown table with css props
 * @param cssProperties
 * @param config
 */
function cssPropSection(cssProperties, config) {
    var rows = [["Property", "Type", "Default", "Description"]];
    rows.push.apply(rows, __spread(cssProperties.map(function (prop) {
        var _a;
        var def = (prop.default !== undefined ? JSON.stringify(prop.default) : "") || "";
        return [(prop.name && markdownHighlight(prop.name)) || "", prop.typeHint || "", def, ((_a = prop.jsDoc) === null || _a === void 0 ? void 0 : _a.description) || ""];
    })));
    return markdownHeader("CSS Custom Properties", 2, config) + "\n" + markdownTable(rows);
}
/**
 * Returns a markdown table with css parts
 * @param cssPart
 * @param config
 */
function cssPartSection(cssPart, config) {
    var rows = [["Part", "Description"]];
    rows.push.apply(rows, __spread(cssPart.map(function (part) { var _a; return [(part.name && markdownHighlight(part.name)) || "", ((_a = part.jsDoc) === null || _a === void 0 ? void 0 : _a.description) || ""]; })));
    return markdownHeader("CSS Shadow Parts", 2, config) + "\n" + markdownTable(rows);
}
/**
 * Returns a markdown table with methods
 * @param methods
 * @param checker
 * @param config
 */
function methodSection(methods, checker, config) {
    var showVisibility = shouldShowVisibility(methods, config);
    var rows = [["Method", "Visibility", "Type", "Description"]];
    rows.push.apply(rows, __spread(methods.map(function (method) {
        var _a, _b, _c;
        // Build up a description of parameters
        var paramDescription = ((_b = (_a = method.jsDoc) === null || _a === void 0 ? void 0 : _a.tags) === null || _b === void 0 ? void 0 : _b.filter(function (tag) { return tag.tag === "param" && tag.comment != null; }).map(function (tag) {
            return "**" + tag.parsed().name + "**: " + tag.parsed().description;
        }).join("\n").trim()) || undefined;
        var description = ((_c = method.jsDoc) === null || _c === void 0 ? void 0 : _c.description) || undefined;
        return [
            method.name != null ? markdownHighlight(method.name) : "",
            showVisibility ? method.visibility || "public" : "",
            markdownHighlight(getTypeHintFromMethod(method, checker)),
            "" + (description || "") + (description != null && paramDescription != null ? "\n\n" : "") + (paramDescription || "")
        ];
    })));
    return markdownHeader("Methods", 2, config) + "\n" + markdownTable(rows);
}
/**
 * Returns a markdown table with events
 * @param events
 * @param config
 * @param checker
 */
function eventSection(events, checker, config) {
    var showVisibility = shouldShowVisibility(events, config);
    var rows = [["Event", "Visibility", "Type", "Description"]];
    rows.push.apply(rows, __spread(events.map(function (event) {
        var _a, _b, _c;
        return [
            (event.name && markdownHighlight(event.name)) || "",
            showVisibility ? event.visibility || "public" : "",
            markdownHighlight(getTypeHintFromType((_a = event.typeHint) !== null && _a !== void 0 ? _a : (_b = event.type) === null || _b === void 0 ? void 0 : _b.call(event), checker, config)),
            ((_c = event.jsDoc) === null || _c === void 0 ? void 0 : _c.description) || ""
        ];
    })));
    return markdownHeader("Events", 2, config) + "\n" + markdownTable(rows);
}
/**
 * Returns a markdown table with slots
 * @param slots
 * @param config
 */
function slotSection(slots, config) {
    var rows = [["Name", "Permitted Tag Names", "Description"]];
    rows.push.apply(rows, __spread(slots.map(function (slot) {
        var _a;
        return [
            (slot.name && markdownHighlight(slot.name)) || "",
            (slot.permittedTagNames && slot.permittedTagNames.map(function (tagName) { return markdownHighlight(tagName); }).join(" | ")) || "",
            ((_a = slot.jsDoc) === null || _a === void 0 ? void 0 : _a.description) || ""
        ];
    })));
    return markdownHeader("Slots", 2, config) + "\n" + markdownTable(rows);
}
/**
 * Returns a markdown table with attributes.
 * @param members
 * @param checker
 * @param config
 */
function memberAttributeSection(members, checker, config) {
    var e_2, _a;
    var _b, _c, _d;
    var showVisibility = shouldShowVisibility(members, config);
    var rows = [["Attribute", "Visibility", "Type", "Default", "Description"]];
    try {
        // Add members as rows one by one
        for (var members_1 = __values(members), members_1_1 = members_1.next(); !members_1_1.done; members_1_1 = members_1.next()) {
            var member = members_1_1.value;
            var attrName = markdownHighlight(member.attrName);
            var type = markdownHighlight(getTypeHintFromType((_b = member.typeHint) !== null && _b !== void 0 ? _b : (_c = member.type) === null || _c === void 0 ? void 0 : _c.call(member), checker, config));
            var visibility = member.visibility || "public";
            var def = (member.default !== undefined ? JSON.stringify(member.default) : "") || (member.required && "**required**") || "";
            var comment = ((_d = member.jsDoc) === null || _d === void 0 ? void 0 : _d.description) || "";
            rows.push([attrName, showVisibility ? visibility : "", type, def, comment]);
        }
    }
    catch (e_2_1) { e_2 = { error: e_2_1 }; }
    finally {
        try {
            if (members_1_1 && !members_1_1.done && (_a = members_1.return)) _a.call(members_1);
        }
        finally { if (e_2) throw e_2.error; }
    }
    return markdownHeader("Attributes", 2, config) + "\n" + markdownTable(rows);
}
/**
 * Returns a markdown table with properties
 * @param members
 * @param checker
 * @param config
 */
function memberPropertySection(members, checker, config) {
    var e_3, _a;
    var _b, _c, _d;
    var showVisibility = shouldShowVisibility(members, config);
    var rows = [["Property", "Attribute", "Visibility", "Modifiers", "Type", "Default", "Description"]];
    try {
        // Add properties as rows one by one
        for (var members_2 = __values(members), members_2_1 = members_2.next(); !members_2_1.done; members_2_1 = members_2.next()) {
            var member = members_2_1.value;
            var propName = markdownHighlight(member.propName);
            var attrName = (member.attrName && markdownHighlight(member.attrName)) || "";
            var visibility = member.visibility || "public";
            var type = markdownHighlight(getTypeHintFromType((_b = member.typeHint) !== null && _b !== void 0 ? _b : (_c = member.type) === null || _c === void 0 ? void 0 : _c.call(member), checker, config));
            var mods = member.modifiers != null ? Array.from(member.modifiers).join(", ") : "";
            var def = (member.default !== undefined ? JSON.stringify(member.default) : "") || (member.required && "**required**") || "";
            var comment = ((_d = member.jsDoc) === null || _d === void 0 ? void 0 : _d.description) || "";
            rows.push([propName, attrName, showVisibility ? visibility : "", mods, type, def, comment]);
        }
    }
    catch (e_3_1) { e_3 = { error: e_3_1 }; }
    finally {
        try {
            if (members_2_1 && !members_2_1.done && (_a = members_2.return)) _a.call(members_2);
        }
        finally { if (e_3) throw e_3.error; }
    }
    return markdownHeader("Properties", 2, config) + "\n" + markdownTable(rows);
}
function shouldShowVisibility(items, config) {
    return (config.visibility != null && config.visibility !== "public" && items.some(function (method) { return method.visibility != null && method.visibility !== "public"; }));
}

/**
 * Vscode json output format transformer.
 * @param results
 * @param program
 * @param config
 */
var vscodeTransformer = function (results, program, config) {
    var checker = program.getTypeChecker();
    // Grab all definitions
    var definitions = results.map(function (res) { return res.componentDefinitions; }).reduce(function (acc, cur) { return __spread(acc, cur); }, []);
    // Transform all definitions into "tags"
    var tags = definitions.map(function (d) { return definitionToHtmlDataTag$1(d, checker); });
    var vscodeJson = {
        version: 1,
        tags: tags,
        globalAttributes: [],
        valueSets: []
    };
    return JSON.stringify(vscodeJson, null, 2);
};
function definitionToHtmlDataTag$1(definition, checker) {
    var declaration = definition.declaration;
    if (declaration == null) {
        return {
            name: definition.tagName,
            attributes: []
        };
    }
    // Transform all members into "attributes"
    var customElementAttributes = arrayDefined(declaration.members.map(function (d) { return componentMemberToVscodeAttr(d, checker); }));
    var eventAttributes = arrayDefined(declaration.events.map(function (e) { return componentEventToVscodeAttr(e, checker); }));
    var attributes = __spread(customElementAttributes, eventAttributes);
    return {
        name: definition.tagName,
        description: formatMetadata(declaration.jsDoc, {
            Events: declaration.events.map(function (e) { var _a; return formatEntryRow(e.name, e.jsDoc, (_a = e.type) === null || _a === void 0 ? void 0 : _a.call(e), checker); }),
            Slots: declaration.slots.map(function (s) {
                return formatEntryRow(s.name || " ", s.jsDoc, s.permittedTagNames && s.permittedTagNames.map(function (n) { return "\"" + markdownHighlight(n) + "\""; }).join(" | "), checker);
            }),
            Attributes: declaration.members
                .map(function (m) { var _a; return ("attrName" in m && m.attrName != null ? formatEntryRow(m.attrName, m.jsDoc, m.typeHint || ((_a = m.type) === null || _a === void 0 ? void 0 : _a.call(m)), checker) : undefined); })
                .filter(function (m) { return m != null; }),
            Properties: declaration.members
                .map(function (m) { var _a; return ("propName" in m && m.propName != null ? formatEntryRow(m.propName, m.jsDoc, m.typeHint || ((_a = m.type) === null || _a === void 0 ? void 0 : _a.call(m)), checker) : undefined); })
                .filter(function (m) { return m != null; })
        }),
        attributes: attributes
    };
}
function componentEventToVscodeAttr(event, checker) {
    var _a;
    return {
        name: "on" + event.name,
        description: formatEntryRow(event.name, event.jsDoc, (_a = event.type) === null || _a === void 0 ? void 0 : _a.call(event), checker)
    };
}
function componentMemberToVscodeAttr(member, checker) {
    var _a, _b;
    if (member.attrName == null) {
        return undefined;
    }
    return exports.__assign({ name: member.attrName, description: formatMetadata(formatEntryRow(member.attrName, member.jsDoc, member.typeHint || ((_a = member.type) === null || _a === void 0 ? void 0 : _a.call(member)), checker), {
            Property: "propName" in member ? member.propName : undefined,
            Default: member.default === undefined ? undefined : String(member.default)
        }) }, ((member.type && typeToVscodeValuePart((_b = member.type) === null || _b === void 0 ? void 0 : _b.call(member), checker)) || {}));
}
/**
 * Converts a type to either a value set or string unions.
 * @param type
 * @param checker
 */
function typeToVscodeValuePart(type, checker) {
    var simpleType = tsSimpleType.isSimpleType(type) ? type : tsSimpleType.toSimpleType(type, checker);
    switch (simpleType.kind) {
        case "BOOLEAN":
            return { valueSet: "v" };
        case "STRING_LITERAL":
            return { values: [{ name: simpleType.value }] };
        case "ENUM":
            return { values: typesToStringUnion(simpleType.types.map(function (_a) {
                    var type = _a.type;
                    return type;
                })) };
        case "UNION":
            return { values: typesToStringUnion(simpleType.types) };
    }
    return undefined;
}
/**
 * Returns a list of strings that represents the types.
 * Only looks at literal types and strips the rest.
 * @param types
 */
function typesToStringUnion(types) {
    return arrayDefined(types.map(function (t) {
        switch (t.kind) {
            case "STRING_LITERAL":
            case "NUMBER_LITERAL":
                return { name: t.value.toString() };
            default:
                return undefined;
        }
    }));
}
/**
 * Formats description and metadata so that it can be used in documentation.
 * @param doc
 * @param metadata
 */
function formatMetadata(doc, metadata) {
    var metaText = arrayDefined(Object.entries(metadata).map(function (_a) {
        var _b = __read(_a, 2), key = _b[0], value = _b[1];
        if (value == null) {
            return undefined;
        }
        else if (Array.isArray(value)) {
            var filtered = arrayDefined(value);
            if (filtered.length === 0)
                return undefined;
            return key + ":\n\n" + filtered.map(function (v) { return "  * " + v; }).join("\n\n");
        }
        else {
            return key + ": " + value;
        }
    })).join("\n\n");
    var comment = typeof doc === "string" ? doc : (doc === null || doc === void 0 ? void 0 : doc.description) || "";
    return "" + (comment || "") + (metadata ? "" + (comment ? "\n\n" : "") + metaText : "") || undefined;
}
/**
 * Formats name, doc and type so that it can be presented in documentation
 * @param name
 * @param doc
 * @param type
 * @param checker
 */
function formatEntryRow(name, doc, type, checker) {
    var comment = typeof doc === "string" ? doc : (doc === null || doc === void 0 ? void 0 : doc.description) || "";
    var typeText = typeof type === "string" ? type : type == null ? "" : formatType(type, checker);
    return "" + markdownHighlight(name) + (typeText == null ? "" : " {" + typeText + "}") + (comment == null ? "" : " - ") + (comment || "");
}
/**
 * Formats a type to present in documentation
 * @param type
 * @param checker
 */
function formatType(type, checker) {
    return !tsSimpleType.isAssignableToSimpleTypeKind(type, "ANY", checker) ? markdownHighlight(tsSimpleType.typeToString(type, checker)) : undefined;
}

var transformerFunctionMap = {
    debug: debugJsonTransformer,
    json: jsonTransformer,
    json2: json2Transformer,
    markdown: markdownTransformer,
    md: markdownTransformer,
    vscode: vscodeTransformer
};
/**
 * Transforms the analyzer results into a string representation based on the transformer kind
 * @param kind
 * @param results
 * @param program
 * @param config
 */
function transformAnalyzerResult(kind, results, program, config) {
    if (config === void 0) { config = {}; }
    var func = transformerFunctionMap[kind];
    if (func == null) {
        throw new Error("Couldn't find transformer function for transformer kind: " + kind);
    }
    return func(Array.isArray(results) ? results : [results], program, exports.__assign({ visibility: "public" }, config));
}

exports.ALL_COMPONENT_FEATURES = ALL_COMPONENT_FEATURES;
exports.CustomElementFlavor = CustomElementFlavor;
exports.DEFAULT_COMPONENT_DECLARATION_CACHE = DEFAULT_COMPONENT_DECLARATION_CACHE;
exports.DEFAULT_FEATURE_COLLECTION_CACHE = DEFAULT_FEATURE_COLLECTION_CACHE;
exports.JsDocFlavor = JsDocFlavor;
exports.VERSION = VERSION;
exports.__awaiter = __awaiter;
exports.__generator = __generator;
exports.__read = __read;
exports.__values = __values;
exports.analyzeComponentDeclaration = analyzeComponentDeclaration;
exports.analyzeSourceFile = analyzeSourceFile;
exports.arrayDefined = arrayDefined;
exports.arrayFlat = arrayFlat;
exports.getExtendsHeritageClauses = getExtendsHeritageClauses;
exports.getExtendsHeritageClausesInChain = getExtendsHeritageClausesInChain;
exports.getJsDoc = getJsDoc;
exports.getJsDocType = getJsDocType;
exports.getMixinHeritageClauses = getMixinHeritageClauses;
exports.getMixinHeritageClausesInChain = getMixinHeritageClausesInChain;
exports.getSuperclassHeritageClause = getSuperclassHeritageClause;
exports.makeContextFromConfig = makeContextFromConfig;
exports.parseSimpleJsDocTypeExpression = parseSimpleJsDocTypeExpression;
exports.stripTypescriptValues = stripTypescriptValues;
exports.transformAnalyzerResult = transformAnalyzerResult;
exports.visitAllHeritageClauses = visitAllHeritageClauses;
