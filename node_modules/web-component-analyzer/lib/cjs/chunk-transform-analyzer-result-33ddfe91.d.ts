import { Program, TypeChecker, Type, SourceFile, Node, CallExpression, Expression, ObjectLiteralExpression, JSDocTag } from "typescript";
import { AnalyzerResult } from "./chunk-analyzer-result-908a9464";
import { TransformerConfig } from "./chunk-transformer-config-8314091f";
import { ComponentDeclaration, ComponentFeatures } from "./chunk-component-declaration-14acf67d";
import { ComponentMethod } from "./chunk-component-method-8314091f";
import { VisibilityKind } from "./chunk-visibility-kind-8314091f";
import { SimpleType } from "ts-simple-type";
import { AnalyzerOptions } from "./chunk-analyzer-options-93ab3a41";
import { AnalyzerVisitContext } from "./chunk-analyzer-visit-context-749740e4";
import { AnalyzerDeclarationVisitContext, AnalyzerFlavor, FeatureVisitReturnTypeMap, DefinitionNodeResult, InheritanceResult, ComponentFeatureCollection, FeatureDiscoverVisitMap } from "./chunk-analyzer-flavor-749740e4";
import { ComponentFeature, ComponentFeatureBase } from "./chunk-component-feature-b8a04bb4";
import { ComponentDefinition } from "./chunk-component-definition-e43c39c9";
import { ComponentMember } from "./chunk-component-member-d7983be2";
import { ComponentCssPart } from "./chunk-component-css-part-c0c96ec8";
import { ComponentCssProperty } from "./chunk-component-css-property-bf4b003a";
import { ComponentEvent } from "./chunk-component-event-8314091f";
import { ComponentSlot } from "./chunk-component-slot-b8a04bb4";
import { JsDoc, JsDocTagParsed } from "./chunk-js-doc-14acf67d";
import { ModifierKind } from "./chunk-modifier-kind-d7983be2"; /**
 * Merges based on a name
 * @param entries
 * @param direction
 * @param getName
 * @param merge
 */
import { LitElementPropertyConfig } from "./chunk-lit-element-property-config-a6e5ad36";
import { TransformerKind } from "./chunk-transformer-kind-d63ed54e";
type TransformerFunction = (results: AnalyzerResult[], program: Program, config: TransformerConfig) => string;
/**
 * Vscode json output format transformer.
 * @param results
 * @param program
 * @param config
 */
declare const vscodeTransformer: TransformerFunction;
declare const markdownTransformer: TransformerFunction; /**
 * Returns a markdown table with css props
 * @param cssProperties
 * @param config
 */
/**
 * Returns a markdown table with css props
 * @param cssProperties
 * @param config
 */
/**
 * Returns a markdown table with css props
 * @param cssProperties
 * @param config
 */
/**
 * Returns a markdown table with css props
 * @param cssProperties
 * @param config
 */
/**
 * Returns a markdown table with css props
 * @param cssProperties
 * @param config
 */
/**
 * Returns a markdown table with css props
 * @param cssProperties
 * @param config
 */
/**
 * Returns a markdown table with css props
 * @param cssProperties
 * @param config
 */
/**
 * Returns a markdown header with a specific level taking global start title level into account.
 * @param title
 * @param level
 * @param config
 */
declare function markdownHeader(title: string, level: number, config: TransformerConfig): string; /**
 * Returns a markdown table representation of the rows.
 * Strips unused columns.
 * @param rows
 * @param removeEmptyColumns
 */
/**
 * Returns a markdown table representation of the rows.
 * Strips unused columns.
 * @param rows
 * @param removeEmptyColumns
 */
/**
 * Returns a markdown table representation of the rows.
 * Strips unused columns.
 * @param rows
 * @param removeEmptyColumns
 */
declare function markdownTable(rows: string[][], { removeEmptyColumns }?: {
    removeEmptyColumns: boolean;
}): string; /**
 * Escape a text so it can be used in a markdown table
 * @param text
 */
/**
 * Escape a text so it can be used in a markdown table
 * @param text
 */
/**
 * Escape a text so it can be used in a markdown table
 * @param text
 */
declare function markdownEscapeTableCell(text: string): string; /**
 * Highlights some text
 * @param text
 */
/**
 * Highlights some text
 * @param text
 */
/**
 * Highlights some text
 * @param text
 */
declare function markdownHighlight(text: string | undefined): string; /**
 * Creates padding around some text with a target width.
 * @param text
 * @param width
 * @param paddingStart
 */
/**
 * Creates padding around some text with a target width.
 * @param text
 * @param width
 * @param paddingStart
 */
/**
 * Creates padding around some text with a target width.
 * @param text
 * @param width
 * @param paddingStart
 */
declare function fillWidth(text: string, width: number, paddingStart: number): string;
interface Example {
    lang?: string;
    code: string;
    description?: string;
} /**
 * Parses and returns examples for a component.
 * @param declaration
 */
/**
 * Parses and returns examples for a component.
 * @param declaration
 */
declare function getExamplesFromComponent(declaration: ComponentDeclaration): Example[]; /**
 * Returns an example based on a jsdoc tag
 * @param tag
 */
/**
 * Returns an example based on a jsdoc tag
 * @param tag
 */
/**
 * Returns an example based on a jsdoc tag
 * @param tag
 */
/**
 * Returns an example based on a jsdoc tag
 * @param tag
 */
/**
 * Returns an example based on a jsdoc tag
 * @param tag
 */
/**
 * Returns an example based on a jsdoc tag
 * @param tag
 */
/**
 * Returns an example based on a jsdoc tag
 * @param tag
 */
declare const json2Transformer: TransformerFunction; /**
 * Transforms an analyzer result into a module doc
 * @param result
 * @param context
 */
/**
 * Transforms an analyzer result into a module doc
 * @param result
 * @param context
 */
/**
 * Transforms an analyzer result into a module doc
 * @param result
 * @param context
 */
/**
 * Transforms an analyzer result into a module doc
 * @param result
 * @param context
 */
/**
 * Transforms an analyzer result into a module doc
 * @param result
 * @param context
 */
/**
 * Transforms an analyzer result into a module doc
 * @param result
 * @param context
 */
/**
 * Transforms an analyzer result into a module doc
 * @param result
 * @param context
 */
/**
 * This method returns a "type hint" that represents the method signature
 * The resulting type takes jsdoc into account.
 * I couldn't find a way for Typescript to return the signature string taking jsdoc into account
 *   so therefore I had to do some regex-magic in this method.
 */
declare function getTypeHintFromMethod(method: ComponentMethod, checker: TypeChecker): string | undefined;
/**
 * Transforms results to json.
 * @param results
 * @param program
 * @param config
 */
declare const jsonTransformer: TransformerFunction;
/**
 * Returns the first element in the set
 * @param set
 */
declare function getFirst<T>(set: Set<T>): T | undefined;
/**
 * Removes all items from an array with visibilities that are less visible than "visibility".
 * @param visibility
 * @param array
 */
declare function filterVisibility<T extends {
    visibility?: VisibilityKind;
}>(visibility: "public" | "protected" | "private" | undefined, array: T[]): T[];
declare function getTypeHintFromType(type: string | Type | SimpleType | undefined, checker: TypeChecker, config: TransformerConfig): string | undefined; /**
 * Checks if a type is a type alias simple type
 * @param simpleType
 */
/**
 * Checks if a type is a type alias simple type
 * @param simpleType
 */
/**
 * Checks if a type is a type alias simple type
 * @param simpleType
 */
/**
 * Checks if a type is a type alias simple type
 * @param simpleType
 */
/**
 * Checks if a type is a type alias simple type
 * @param simpleType
 */
/**
 * Checks if a type is a type alias simple type
 * @param simpleType
 */
/**
 * Checks if a type is a type alias simple type
 * @param simpleType
 */
/**
 * Transforms results to json.
 * @param results
 * @param program
 * @param config
 */
declare const debugJsonTransformer: TransformerFunction;
/**
 * Analyzes all components in a source file.
 * @param sourceFile
 * @param options
 */
declare function analyzeSourceFile(sourceFile: SourceFile, options: AnalyzerOptions): AnalyzerResult;
/**
 * Discover all global features using flavors
 * @param node
 * @param context
 */
declare function discoverGlobalFeatures(node: Node, context: AnalyzerVisitContext): ComponentFeatures;
type VisitFeatureEmitMap = {
    [K in ComponentFeature]: (result: FeatureVisitReturnTypeMap[K][]) => void;
}; /**
 * Uses flavors to find features for a node
 * @param node
 * @param context
 * @param emitMap
 */
/**
 * Uses flavors to find features for a node
 * @param node
 * @param context
 * @param emitMap
 */
/**
 * Uses flavors to find features for a node
 * @param node
 * @param context
 * @param emitMap
 */
/**
 * Uses flavors to find global features
 * @param node
 * @param context
 * @param emitMap
 */
declare function visitGlobalFeatures<ReturnType>(node: Node, context: AnalyzerVisitContext, emitMap: Partial<VisitFeatureEmitMap>): void;
declare function discoverDefinitions(sourceFile: SourceFile, context: AnalyzerVisitContext, analyzeDeclaration: (definition: ComponentDefinition, declarationNodes: Node[]) => ComponentDeclaration | undefined): ComponentDefinition[]; /**
 * Finds all component definitions in a file and combine multiple declarations with same tag name.
 * @param sourceFile
 * @param context
 */
/**
 * Finds all component definitions in a file and combine multiple declarations with same tag name.
 * @param sourceFile
 * @param context
 */
/**
 * Finds all component definitions in a file and combine multiple declarations with same tag name.
 * @param sourceFile
 * @param context
 */
/**
 * Finds all component definitions in a file and combine multiple declarations with same tag name.
 * @param sourceFile
 * @param context
 */
/**
 * Finds all component definitions in a file and combine multiple declarations with same tag name.
 * @param sourceFile
 * @param context
 */
/**
 * Finds all component definitions in a file and combine multiple declarations with same tag name.
 * @param sourceFile
 * @param context
 */
/**
 * Finds all component definitions in a file and combine multiple declarations with same tag name.
 * @param sourceFile
 * @param context
 */
/**
 * Uses flavors to visit definitions
 * @param node
 * @param context
 * @param emit
 */
declare function visitDefinitions(node: Node, context: AnalyzerVisitContext, emit: (results: DefinitionNodeResult[]) => void): void;
/**
 * Executes functions in a function map until some function returns a non-undefined value.
 * @param functionMaps
 * @param keys
 * @param arg
 * @param context
 */
declare function executeFunctionsUntilMatch<
// eslint-disable-next-line @typescript-eslint/no-explicit-any
T extends Partial<Record<K, any>>, K extends keyof T, ReturnValue extends ReturnType<NonNullable<T[K]>>, ArgType>(functionMaps: T[], keys: K | K[], arg: ArgType, context: AnalyzerVisitContext): {
    value: NonNullable<ReturnValue>;
    shouldContinue?: boolean;
} | undefined;
/**
 * Visits the source file and finds all component definitions using flavors
 * @param sourceFile
 * @param context
 */
declare function discoverDeclarations(sourceFile: SourceFile, context: AnalyzerVisitContext): ComponentDeclaration[];
/**
 * Uses flavors to refine a declaration
 * @param declaration
 * @param context
 */
declare function refineDeclaration(declaration: ComponentDeclaration, context: AnalyzerDeclarationVisitContext): ComponentDeclaration;
/**
 * Uses flavors to determine if a node should be excluded from the output
 * @param node
 * @param context
 */
declare function excludeNode(node: Node, context: AnalyzerVisitContext): boolean;
/**
 * Uses flavors in order to discover inheritance from one of more nodes.
 * @param startNode
 * @param visitedNodes
 * @param context
 */
declare function discoverInheritance(startNode: Node | Node[], visitedNodes: Set<Node>, context: AnalyzerVisitContext): Required<InheritanceResult>;
/**
 * Uses flavors to find inheritance for a node
 * @param node
 * @param context
 * @param emit
 * @param visitSet
 */
declare function visitInheritance(node: Node, context: AnalyzerVisitContext, emit: (result: InheritanceResult) => void, visitSet?: Set<Node>): void;
/**
 * Discovers features for a given node using flavors
 * @param node
 * @param context
 */
declare function discoverFeatures(node: Node, context: AnalyzerDeclarationVisitContext): ComponentFeatureCollection;
declare function mergeMembers(members: ComponentMember[], context: AnalyzerVisitContext): ComponentMember[]; /**
 * Removes a member from the merge map
 * @param member
 * @param mergeMap
 */
/**
 * Removes a member from the merge map
 * @param member
 * @param mergeMap
 */
/**
 * Removes a member from the merge map
 * @param member
 * @param mergeMap
 */
/**
 * Removes a member from the merge map
 * @param member
 * @param mergeMap
 */
/**
 * Removes a member from the merge map
 * @param member
 * @param mergeMap
 */
/**
 * Removes a member from the merge map
 * @param member
 * @param mergeMap
 */
/**
 * Removes a member from the merge map
 * @param member
 * @param mergeMap
 */
/**
 * Merges multiple slots
 * @param slots
 */
declare function mergeSlots(slots: ComponentSlot[]): ComponentSlot[]; /**
 * Merges multiple css parts
 * @param cssParts
 */
/**
 * Merges multiple css parts
 * @param cssParts
 */
/**
 * Merges multiple css parts
 * @param cssParts
 */
declare function mergeCssParts(cssParts: ComponentCssPart[]): ComponentCssPart[]; /**
 * Merges multiple css properties
 * @param cssProps
 */
/**
 * Merges multiple css properties
 * @param cssProps
 */
/**
 * Merges multiple css properties
 * @param cssProps
 */
declare function mergeCssProperties(cssProps: ComponentCssProperty[]): ComponentCssProperty[]; /**
 * Merges multiple methods
 * @param methods
 */
/**
 * Merges multiple methods
 * @param methods
 */
/**
 * Merges multiple methods
 * @param methods
 */
declare function mergeMethods(methods: ComponentMethod[]): ComponentMethod[]; /**
 * Merges multiple events
 * @param events
 */
/**
 * Merges multiple events
 * @param events
 */
/**
 * Merges multiple events
 * @param events
 */
declare function mergeEvents(events: ComponentEvent[]): ComponentEvent[];
/**
 * Merges based on a name
 * @param entries
 * @param direction
 * @param getName
 * @param merge
 */
declare function mergeNamedEntries<T>(entries: T[], getName: (entry: T) => string, merge?: (left: T, right: T) => T): T[]; /**
 * Merges two jsdocs
 * @param leftJsDoc
 * @param rightJsDoc
 */
/**
 * Merges two jsdocs
 * @param leftJsDoc
 * @param rightJsDoc
 */
/**
 * Merges two jsdocs
 * @param leftJsDoc
 * @param rightJsDoc
 */
declare function mergeJsDoc(leftJsDoc: JsDoc | undefined, rightJsDoc: JsDoc | undefined): JsDoc | undefined; /**
 * Merges modifiers
 * @param leftModifiers
 * @param rightModifiers
 */
/**
 * Merges modifiers
 * @param leftModifiers
 * @param rightModifiers
 */
declare function mergeModifiers(leftModifiers: Set<ModifierKind> | undefined, rightModifiers: Set<ModifierKind> | undefined): Set<ModifierKind> | undefined; /**
 * Merges entries using a "merge" callback
 * @param entries
 * @param isMergeable
 * @param merge
 */
/*export function mergeEntries<T>(entries: T[], isMergeable: (entry: T, merged: T) => boolean, merge: (left: T, right: T) => T): T[] {
let mergedEntries: T[] = [];

for (const entry of entries) {
let mergeableEntry: T | undefined = undefined;
for (const mergedEntry of mergedEntries) {
if (isMergeable(entry, mergedEntry)) {
mergeableEntry = mergedEntry;
break;
}
}

let newEntry: T | undefined = undefined;
if (mergeableEntry == null) {
newEntry = entry;
} else {
mergedEntries = mergedEntries.filter(mergedEntry => mergedEntry !== entry && mergedEntry !== mergeableEntry);
newEntry = merge(mergeableEntry, entry);
}
mergedEntries.push(newEntry);
}

return mergedEntries;
}*/
/**
 * Merges entries using a "merge" callback
 * @param entries
 * @param isMergeable
 * @param merge
 */
/*export function mergeEntries<T>(entries: T[], isMergeable: (entry: T, merged: T) => boolean, merge: (left: T, right: T) => T): T[] {
let mergedEntries: T[] = [];

for (const entry of entries) {
let mergeableEntry: T | undefined = undefined;
for (const mergedEntry of mergedEntries) {
if (isMergeable(entry, mergedEntry)) {
mergeableEntry = mergedEntry;
break;
}
}

let newEntry: T | undefined = undefined;
if (mergeableEntry == null) {
newEntry = entry;
} else {
mergedEntries = mergedEntries.filter(mergedEntry => mergedEntry !== entry && mergedEntry !== mergeableEntry);
newEntry = merge(mergeableEntry, entry);
}
mergedEntries.push(newEntry);
}

return mergedEntries;
}*/
/**
 * Merges entries using a "merge" callback
 * @param entries
 * @param isMergeable
 * @param merge
 */
/*export function mergeEntries<T>(entries: T[], isMergeable: (entry: T, merged: T) => boolean, merge: (left: T, right: T) => T): T[] {
let mergedEntries: T[] = [];

for (const entry of entries) {
let mergeableEntry: T | undefined = undefined;
for (const mergedEntry of mergedEntries) {
if (isMergeable(entry, mergedEntry)) {
mergeableEntry = mergedEntry;
break;
}
}

let newEntry: T | undefined = undefined;
if (mergeableEntry == null) {
newEntry = entry;
} else {
mergedEntries = mergedEntries.filter(mergedEntry => mergedEntry !== entry && mergedEntry !== mergeableEntry);
newEntry = merge(mergeableEntry, entry);
}
mergedEntries.push(newEntry);
}

return mergedEntries;
}*/
/**
 * Merges entries using a "merge" callback
 * @param entries
 * @param isMergeable
 * @param merge
 */
/*export function mergeEntries<T>(entries: T[], isMergeable: (entry: T, merged: T) => boolean, merge: (left: T, right: T) => T): T[] {
let mergedEntries: T[] = [];

for (const entry of entries) {
let mergeableEntry: T | undefined = undefined;
for (const mergedEntry of mergedEntries) {
if (isMergeable(entry, mergedEntry)) {
mergeableEntry = mergedEntry;
break;
}
}

let newEntry: T | undefined = undefined;
if (mergeableEntry == null) {
newEntry = entry;
} else {
mergedEntries = mergedEntries.filter(mergedEntry => mergedEntry !== entry && mergedEntry !== mergeableEntry);
newEntry = merge(mergeableEntry, entry);
}
mergedEntries.push(newEntry);
}

return mergedEntries;
}*/
/**
 * Merges entries using a "merge" callback
 * @param entries
 * @param isMergeable
 * @param merge
 */
/*export function mergeEntries<T>(entries: T[], isMergeable: (entry: T, merged: T) => boolean, merge: (left: T, right: T) => T): T[] {
let mergedEntries: T[] = [];

for (const entry of entries) {
let mergeableEntry: T | undefined = undefined;
for (const mergedEntry of mergedEntries) {
if (isMergeable(entry, mergedEntry)) {
mergeableEntry = mergedEntry;
break;
}
}

let newEntry: T | undefined = undefined;
if (mergeableEntry == null) {
newEntry = entry;
} else {
mergedEntries = mergedEntries.filter(mergedEntry => mergedEntry !== entry && mergedEntry !== mergeableEntry);
newEntry = merge(mergeableEntry, entry);
}
mergedEntries.push(newEntry);
}

return mergedEntries;
}*/
/**
 * Merges entries using a "merge" callback
 * @param entries
 * @param isMergeable
 * @param merge
 */
/*export function mergeEntries<T>(entries: T[], isMergeable: (entry: T, merged: T) => boolean, merge: (left: T, right: T) => T): T[] {
let mergedEntries: T[] = [];

for (const entry of entries) {
let mergeableEntry: T | undefined = undefined;
for (const mergedEntry of mergedEntries) {
if (isMergeable(entry, mergedEntry)) {
mergeableEntry = mergedEntry;
break;
}
}

let newEntry: T | undefined = undefined;
if (mergeableEntry == null) {
newEntry = entry;
} else {
mergedEntries = mergedEntries.filter(mergedEntry => mergedEntry !== entry && mergedEntry !== mergeableEntry);
newEntry = merge(mergeableEntry, entry);
}
mergedEntries.push(newEntry);
}

return mergedEntries;
}*/
/**
 * Merges entries using a "merge" callback
 * @param entries
 * @param isMergeable
 * @param merge
 */
/*export function mergeEntries<T>(entries: T[], isMergeable: (entry: T, merged: T) => boolean, merge: (left: T, right: T) => T): T[] {
let mergedEntries: T[] = [];

for (const entry of entries) {
let mergeableEntry: T | undefined = undefined;
for (const mergedEntry of mergedEntries) {
if (isMergeable(entry, mergedEntry)) {
mergeableEntry = mergedEntry;
break;
}
}

let newEntry: T | undefined = undefined;
if (mergeableEntry == null) {
newEntry = entry;
} else {
mergedEntries = mergedEntries.filter(mergedEntry => mergedEntry !== entry && mergedEntry !== mergeableEntry);
newEntry = merge(mergeableEntry, entry);
}
mergedEntries.push(newEntry);
}

return mergedEntries;
}*/
type RefineFeatureEmitMap = {
    [K in ComponentFeature]: (result: FeatureVisitReturnTypeMap[K]) => void;
}; /**
 * Uses flavors to refine a feature
 * Flavors can also remove a feature
 * @param featureKind
 * @param value
 * @param context
 * @param emitMap
 */
/**
 * Uses flavors to refine a feature
 * Flavors can also remove a feature
 * @param featureKind
 * @param value
 * @param context
 * @param emitMap
 */
/**
 * Uses flavors to refine a feature
 * Flavors can also remove a feature
 * @param featureKind
 * @param value
 * @param context
 * @param emitMap
 */
declare function refineFeature<FeatureKind extends ComponentFeature, ValueType extends ComponentFeatureBase = FeatureVisitReturnTypeMap[FeatureKind]>(featureKind: FeatureKind, value: ValueType | ValueType[], context: AnalyzerVisitContext | AnalyzerDeclarationVisitContext, emitMap: Partial<RefineFeatureEmitMap>): void;
/**
 * Prepares a map of component features and a callback map that adds to the component feature map.
 */
declare function prepareRefineEmitMap(): {
    collection: ComponentFeatureCollection;
    refineEmitMap: RefineFeatureEmitMap;
};
/**
 * Visits lit-element related definitions.
 * Specifically it finds the usage of the @customElement decorator.
 * @param node
 * @param context
 */
declare function discoverDefinitions$0(node: Node, context: AnalyzerVisitContext): DefinitionNodeResult[] | undefined;
declare function discoverMembers(node: Node, context: AnalyzerDeclarationVisitContext): ComponentMember[] | undefined; /**
 * Visits a lit property decorator and returns members based on it.
 * @param node
 * @param context
 */
/**
 * Visits a lit property decorator and returns members based on it.
 * @param node
 * @param context
 */
/**
 * Visits a lit property decorator and returns members based on it.
 * @param node
 * @param context
 */
/**
 * Visits a lit property decorator and returns members based on it.
 * @param node
 * @param context
 */
/**
 * Visits a lit property decorator and returns members based on it.
 * @param node
 * @param context
 */
/**
 * Visits a lit property decorator and returns members based on it.
 * @param node
 * @param context
 */
declare function excludeNode$0(node: Node, context: AnalyzerVisitContext): boolean | undefined;
/**
 * Flavors for analyzing LitElement related features: https://lit-element.polymer-project.org/
 */
declare class LitElementFlavor implements AnalyzerFlavor {
    excludeNode: typeof excludeNode$0;
    discoverDefinitions: typeof discoverDefinitions$0;
    discoverFeatures: {
        member: typeof discoverMembers;
    };
    refineFeature: Partial<import("./chunk-analyzer-flavor-749740e4").FeatureRefineVisitMap> | undefined;
}
declare const refineFeature$0: AnalyzerFlavor["refineFeature"];
type LitElementPropertyDecoratorKind = "property" | "internalProperty";
declare const LIT_ELEMENT_PROPERTY_DECORATOR_KINDS: LitElementPropertyDecoratorKind[]; /**
 * Returns a potential lit element property decorator.
 * @param node
 * @param context
 */
/**
 * Returns a potential lit element property decorator.
 * @param node
 * @param context
 */
/**
 * Returns a potential lit element property decorator.
 * @param node
 * @param context
 */
declare function getLitElementPropertyDecorator(node: Node, context: AnalyzerVisitContext): {
    expression: CallExpression;
    kind: LitElementPropertyDecoratorKind;
} | undefined; /**
 * Returns a potential lit property decorator configuration.
 * @param node
 * @param context
 */
/**
 * Returns a potential lit property decorator configuration.
 * @param node
 * @param context
 */
/**
 * Returns a potential lit property decorator configuration.
 * @param node
 * @param context
 */
declare function getLitElementPropertyDecoratorConfig(node: Node, context: AnalyzerVisitContext): undefined | LitElementPropertyConfig; /**
 * Parses an object literal expression and returns a lit property configuration.
 * @param node
 * @param existingConfig
 * @param context
 */
/**
 * Parses an object literal expression and returns a lit property configuration.
 * @param node
 * @param existingConfig
 * @param context
 */
/**
 * Parses an object literal expression and returns a lit property configuration.
 * @param node
 * @param existingConfig
 * @param context
 */
declare function getLitPropertyOptions(node: ObjectLiteralExpression, context: AnalyzerVisitContext, existingConfig?: LitElementPropertyConfig): LitElementPropertyConfig;
declare function parseLitPropertyOption({ kind, initializer, config }: {
    kind: string | undefined;
    initializer: Expression;
    config: LitElementPropertyConfig;
}, context: AnalyzerVisitContext): LitElementPropertyConfig;
/**
 * Discovers element definitions in "IntrinsicElements"
 * @param node
 * @param context
 */
declare function discoverDefinitions$1(node: Node, context: AnalyzerVisitContext): DefinitionNodeResult[] | undefined;
/**
 * Flavors for analyzing jsx related features
 */
declare class JSXFlavor implements AnalyzerFlavor {
    discoverDefinitions: typeof discoverDefinitions$1;
    discoverGlobalFeatures: Partial<import("./chunk-analyzer-flavor-749740e4").FeatureDiscoverVisitMap<import("./api").AnalyzerVisitContext>> | undefined;
}
/**
 * Discovers members declared on "IntrinsicAttributes"
 */
declare const discoverGlobalFeatures$0: AnalyzerFlavor["discoverGlobalFeatures"];
/**
 * Discovers definitions using "@customElement" or "@element" jsdoc
 * @param node
 * @param context
 */
declare function discoverDefinitions$2(node: Node, context: AnalyzerVisitContext): DefinitionNodeResult[] | undefined;
/**
 * Refines a component declaration by using jsdoc tags
 * @param declaration
 * @param context
 */
declare function refineDeclaration$0(declaration: ComponentDeclaration, context: AnalyzerVisitContext): ComponentDeclaration | undefined;
/**
 * Flavors for analyzing jsdoc related features
 */
declare class JsDocFlavor implements AnalyzerFlavor {
    discoverDefinitions: typeof discoverDefinitions$2;
    discoverFeatures: Partial<import("./chunk-analyzer-flavor-749740e4").FeatureDiscoverVisitMap<import("./api").AnalyzerVisitContext>>;
    discoverGlobalFeatures: Partial<import("./chunk-analyzer-flavor-749740e4").FeatureDiscoverVisitMap<import("./api").AnalyzerVisitContext>> | undefined;
    refineFeature: Partial<import("./chunk-analyzer-flavor-749740e4").FeatureRefineVisitMap> | undefined;
    refineDeclaration: typeof refineDeclaration$0;
}
declare const refineFeature$1: AnalyzerFlavor["refineFeature"]; /**
 * Applies the "@deprecated" jsdoc tag
 * @param feature
 * @param jsDoc
 */
/**
 * Applies the "@deprecated" jsdoc tag
 * @param feature
 * @param jsDoc
 */
/**
 * Applies the "@deprecated" jsdoc tag
 * @param feature
 * @param jsDoc
 */
/**
 * Applies the "@deprecated" jsdoc tag
 * @param feature
 * @param jsDoc
 */
/**
 * Applies the "@deprecated" jsdoc tag
 * @param feature
 * @param jsDoc
 */
/**
 * Applies the "@deprecated" jsdoc tag
 * @param feature
 * @param jsDoc
 */
/**
 * Applies the "@deprecated" jsdoc tag
 * @param feature
 * @param jsDoc
 */
declare const discoverGlobalFeatures$1: AnalyzerFlavor["discoverGlobalFeatures"];
declare const discoverFeatures$0: Partial<FeatureDiscoverVisitMap<AnalyzerVisitContext>>;
/**
 * Transforms jsdoc tags to a T array using a "transform"
 * @param node
 * @param tagNames
 * @param transform
 * @param context
 */
declare function parseJsDocForNode<T>(node: Node, tagNames: string[], transform: (tagNode: JSDocTag | undefined, parsed: JsDocTagParsed) => T | undefined, context: AnalyzerVisitContext): T[] | undefined;
/**
 * Visits custom element definitions.
 * @param node
 * @param ts
 * @param checker
 */
declare function discoverDefinitions$3(node: Node, { ts, checker }: AnalyzerVisitContext): DefinitionNodeResult[] | undefined;
/**
 * Discovers events dispatched
 * @param node
 * @param context
 */
declare function discoverEvents(node: Node, context: AnalyzerVisitContext): ComponentEvent[] | undefined;
/**
 * Discovers inheritance from a node by looking at "extends" and "implements"
 * @param node
 * @param baseContext
 */
declare function discoverInheritance$0(node: Node, baseContext: AnalyzerVisitContext): InheritanceResult | undefined;
/**
 * Discovers members based on standard vanilla custom element rules
 * @param node
 * @param context
 */
declare function discoverMembers$0(node: Node, context: AnalyzerDeclarationVisitContext): ComponentMember /**
 * Transforms the analyzer results into a string representation based on the transformer kind
 * @param kind
 * @param results
 * @param program
 * @param config
 */[] | undefined;
/**
 * Discovers methods
 * @param node
 * @param context
 */
declare function discoverMethods(node: Node, context: AnalyzerDeclarationVisitContext): ComponentMethod[] | undefined;
/**
 * Excludes nodes from "lib.dom.d.ts" if analyzeLibDom is false
 * @param node
 * @param context
 */
declare function excludeNode$1(node: Node, context: AnalyzerVisitContext): boolean | undefined;
/**
 * A flavor that discovers using standard custom element rules
 */
declare class CustomElementFlavor implements AnalyzerFlavor {
    excludeNode: typeof excludeNode$1;
    discoverDefinitions: typeof discoverDefinitions$3;
    discoverFeatures: {
        member: typeof discoverMembers$0;
        event: typeof discoverEvents;
        method: typeof discoverMethods;
    };
    discoverGlobalFeatures: Partial<import("./chunk-analyzer-flavor-749740e4").FeatureDiscoverVisitMap<import("./api").AnalyzerVisitContext>> | undefined;
    discoverInheritance: typeof discoverInheritance$0;
}
/**
 * Discovers global feature defined on "HTMLElementEventMap" or "HTMLElement"
 */
declare const discoverGlobalFeatures$2: AnalyzerFlavor["discoverGlobalFeatures"];
interface HtmlDataValue {
    name: string;
    description?: string;
}
interface HtmlDataValueSet {
    name: string;
    values: HtmlDataValue[];
}
interface HtmlDataMember {
    name: string;
    description?: string;
    values?: HtmlDataValue[];
    valueSet?: string;
    // Suggested fields:
    type?: unknown;
    attribute?: string;
    deprecated?: boolean;
    deprecatedMessage?: string;
}
interface HtmlDataAttribute extends HtmlDataMember {
    // Suggested fields:
    default?: string;
}
interface HtmlDataProperty extends HtmlDataMember {
    // Suggested fields:
    default?: string;
}
interface HtmlDataSlot extends HtmlDataMember {
}
interface HtmlDataEvent extends HtmlDataMember {
}
interface HtmlDataCssProperty extends HtmlDataMember {
    // Suggested fields:
    default?: string;
}
interface HtmlDataCssPart extends HtmlDataMember {
}
interface HtmlDataTag {
    name: string;
    description?: string;
    attributes?: HtmlDataAttribute[];
    path?: string;
    // Suggested fields:
    properties?: HtmlDataProperty[];
    slots?: HtmlDataSlot[];
    events?: HtmlDataEvent[];
    cssProperties?: HtmlDataCssProperty[];
    cssParts?: HtmlDataCssPart[];
    deprecated?: boolean;
    deprecatedMessage?: string;
}
interface HtmlDataV2 {
    version: string;
    tags?: HtmlDataTag[];
    valueSets?: HtmlDataValueSet[];
    // Suggested fields:
    global?: {
        attributes?: HtmlDataMember[];
        properties?: HtmlDataMember[];
        slots?: HtmlDataMember[];
        events?: HtmlDataMember[];
    };
}
type HtmlData = HtmlDataV2;
/**
 * This file comes from the following PR with a proposed JSON schema:
 * https://github.com/webcomponents/custom-elements-json/pull/9
 */
/**
 * The top-level interface of a custom-elements.json file.
 *
 * custom-elements.json documents all the elements in a single npm package,
 * across all modules within the package. Elements may be exported from multiple
 * modules with re-exports, but as a rule, elements in this file should be
 * included once in the "canonical" module that they're exported from.
 */
interface PackageDoc {
    version: string;
    /**
     * An array of the modules this package contains.
     */
    modules: Array<ModuleDoc>;
}
interface ModuleDoc {
    path: string;
    /**
     * A markdown summary suitable for display in a listing.
     */
    summary?: string;
    /**
     * A markdown description of the module.
     */
    description?: string;
    exports?: Array<ExportDoc>;
}
type ExportDoc = ClassDoc | FunctionDoc | VariableDoc | CustomElementDefinitionDoc; /**
 * A reference to an export of a module.
 *
 * All references are required to be publically accessible, so the canonical
 * representation of a refernce it the export it's available from.
 */
/**
 * A reference to an export of a module.
 *
 * All references are required to be publically accessible, so the canonical
 * representation of a refernce it the export it's available from.
 */
/**
 * A reference to an export of a module.
 *
 * All references are required to be publically accessible, so the canonical
 * representation of a refernce it the export it's available from.
 */
interface Reference {
    name: string;
    package?: string;
    module?: string;
}
interface CustomElementDoc extends ClassDoc {
    tagName: string;
    /**
     * The attributes that this element is known to understand.
     */
    attributes?: AttributeDoc[];
    /** The events that this element fires. */
    events?: EventDoc[];
    /**
     * The shadow dom content slots that this element accepts.
     */
    slots?: SlotDoc[];
    cssProperties?: CSSPropertyDoc[];
    cssParts?: CSSPartDoc[];
    demos?: Demo[];
}
interface CustomElementDefinitionDoc {
    kind: "definition";
    name: string;
    declaration: Reference;
}
interface AttributeDoc {
    name: string;
    /**
     * A markdown description for the attribute.
     */
    description?: string;
    /**
     * The type that the attribute will be serialized/deserialized as.
     */
    type?: string;
    /**
     * The default value of the attribute, if any.
     *
     * As attributes are always strings, this is the actual value, not a human
     * readable description.
     */
    defaultValue?: string;
    /**
     * The name of the field this attribute is associated with, if any.
     */
    fieldName?: string;
    /**
     * A reference to the class or mixin that declared this property.
     */
    inheritedFrom?: Reference;
}
interface EventDoc {
    name: string;
    /**
     * A markdown description of the event.
     */
    description?: string;
    /**
     * The type of the event object that's fired.
     *
     * If the event type is built-in, this is a string, e.g. `Event`,
     * `CustomEvent`, `KeyboardEvent`. If the event type is an event class defined
     * in a module, the reference to it.
     */
    type?: Reference | string;
    /**
     * If the event is a CustomEvent, the type of `detail` field.
     */
    detailType?: string;
    /**
     * A reference to the class or mixin that declared this property.
     */
    inheritedFrom?: Reference;
}
interface SlotDoc {
    /**
     * The slot name, or the empty string for an unnamed slot.
     */
    name: string;
    /**
     * A markdown description of the slot.
     */
    description?: string;
    /**
     * A reference to the class or mixin that declared this property.
     */
    inheritedFrom?: Reference;
}
interface CSSPropertyDoc {
    name: string;
    description?: string;
    type?: string;
    default?: string;
    /**
     * A reference to the class or mixin that declared this property.
     */
    inheritedFrom?: Reference;
}
interface CSSPartDoc {
    name: string;
    description?: string;
    /**
     * A reference to the class or mixin that declared this property.
     */
    inheritedFrom?: Reference;
}
interface ClassDoc {
    kind: "class";
    /**
     * The class name, or `undefined` if the class is anonymous.
     */
    name?: string;
    /**
     * A markdown summary suitable for display in a listing.
     * TODO: restrictions on markdown/markup. ie, no headings, only inline
     *       formatting?
     */
    summary?: string;
    /**
     * A markdown description of the class.
     */
    description?: string;
    superclass?: Reference;
    mixins?: Array<Reference>;
    members?: Array<ClassMember>;
}
type ClassMember = FieldDoc | MethodDoc;
interface FieldDoc {
    kind: "field";
    name: string;
    static?: boolean;
    /**
     * A markdown summary suitable for display in a listing.
     * TODO: restrictions on markdown/markup. ie, no headings, only inline
     *       formatting?
     */
    summary?: string;
    /**
     * A markdown description of the field.
     */
    description?: string;
    default?: string;
    // TODO: make this a Type type or a Reference
    privacy?: Privacy;
    type?: string;
    /**
     * A reference to the class or mixin that declared this property.
     */
    inheritedFrom?: Reference;
}
interface MethodDoc extends FunctionLike {
    kind: "method";
    static?: boolean;
    /**
     * A reference to the class or mixin that declared this property.
     */
    inheritedFrom?: Reference;
} /**
 * TODO: tighter definition of mixin:
 *  - Should it only accept a single argument?
 *  - Should it not extend ClassDoc so it doesn't has a superclass?
 *  - What's TypeScript's exact definition?
 */
/**
 * TODO: tighter definition of mixin:
 *  - Should it only accept a single argument?
 *  - Should it not extend ClassDoc so it doesn't has a superclass?
 *  - What's TypeScript's exact definition?
 */
/**
 * TODO: tighter definition of mixin:
 *  - Should it only accept a single argument?
 *  - Should it not extend ClassDoc so it doesn't has a superclass?
 *  - What's TypeScript's exact definition?
 */
interface MixinDoc extends ClassDoc {
}
interface VariableDoc {
    kind: "variable";
    name: string;
    /**
     * A markdown summary suitable for display in a listing.
     */
    summary?: string;
    /**
     * A markdown description of the class.
     */
    description?: string;
    type?: string;
}
interface FunctionDoc extends FunctionLike {
    kind: "function";
}
interface Parameter {
    name: string;
    type?: string;
    description?: string;
}
interface FunctionLike {
    name: string;
    /**
     * A markdown summary suitable for display in a listing.
     */
    summary?: string;
    /**
     * A markdown description of the class.
     */
    description?: string;
    parameters?: Array<Parameter>;
    return?: {
        type?: string;
        description?: string;
    };
    privacy?: Privacy;
    type?: string;
}
type Privacy = "public" | "private" | "protected";
interface Demo {
    /**
     * A markdown description of the demo.
     */
    description?: string;
    /**
     * Relative URL of the demo if it's published with the package. Absolute URL
     * if it's hosted.
     */
    url: string;
}
interface HtmlDataAttrValue {
    name: string;
    description?: string;
}
interface HtmlDataAttr {
    name: string;
    description?: string;
    values?: HtmlDataAttrValue[];
    valueSet?: string;
}
interface HtmlDataTag$0 {
    name: string;
    description?: string;
    attributes: HtmlDataAttr[];
}
interface HtmlDataValueSet$0 {
    name: string;
    values: HtmlDataAttrValue[];
}
interface HtmlDataV1 {
    version: 1;
    tags?: HtmlDataTag$0[];
    globalAttributes?: HtmlDataAttr[];
    valueSets?: HtmlDataValueSet$0[];
}
type VscodeHtmlData = HtmlDataV1;
/**
 * Transforms the analyzer results into a string representation based on the transformer kind
 * @param kind
 * @param results
 * @param program
 * @param config
 */
declare function transformAnalyzerResult(kind: TransformerKind, results: AnalyzerResult | AnalyzerResult[], program: Program, config?: Partial<TransformerConfig>): string;
export { vscodeTransformer, markdownTransformer, markdownHeader, markdownTable, markdownEscapeTableCell, markdownHighlight, fillWidth, Example, getExamplesFromComponent, json2Transformer, getTypeHintFromMethod, jsonTransformer, getFirst, filterVisibility, getTypeHintFromType, debugJsonTransformer, analyzeSourceFile, discoverGlobalFeatures, visitGlobalFeatures, discoverDefinitions, visitDefinitions, executeFunctionsUntilMatch, discoverDeclarations, refineDeclaration, excludeNode, discoverInheritance, visitInheritance, discoverFeatures, mergeMembers, mergeSlots, mergeCssParts, mergeCssProperties, mergeMethods, mergeEvents, mergeNamedEntries, mergeJsDoc, mergeModifiers, RefineFeatureEmitMap, refineFeature, prepareRefineEmitMap, LitElementFlavor, LitElementPropertyDecoratorKind, LIT_ELEMENT_PROPERTY_DECORATOR_KINDS, getLitElementPropertyDecorator, getLitElementPropertyDecoratorConfig, getLitPropertyOptions, parseLitPropertyOption, JSXFlavor, JsDocFlavor, parseJsDocForNode, CustomElementFlavor, HtmlDataValue, HtmlDataValueSet, HtmlDataMember, HtmlDataAttribute, HtmlDataProperty, HtmlDataSlot, HtmlDataEvent, HtmlDataCssProperty, HtmlDataCssPart, HtmlDataTag, HtmlDataV2, HtmlData, PackageDoc, ModuleDoc, ExportDoc, Reference, CustomElementDoc, CustomElementDefinitionDoc, AttributeDoc, EventDoc, SlotDoc, CSSPropertyDoc, CSSPartDoc, ClassDoc, ClassMember, FieldDoc, MethodDoc, MixinDoc, VariableDoc, FunctionDoc, Parameter, FunctionLike, Privacy, Demo, HtmlDataAttrValue, HtmlDataAttr, HtmlDataV1, VscodeHtmlData, transformAnalyzerResult };
//# sourceMappingURL=chunk-transform-analyzer-result-33ddfe91.d.ts.map