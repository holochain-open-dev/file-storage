import { l as __awaiter, n as __generator, o as __values, b as analyzeSourceFile, q as arrayFlat, s as stripTypescriptValues, r as __read, _ as __assign, t as transformAnalyzerResult } from './chunk-transform-analyzer-result-f9714512.js';
import { ScriptTarget, ModuleKind, ModuleResolutionKind, createProgram } from 'typescript';
import 'ts-simple-type';
import { existsSync, lstatSync, mkdirSync, writeFileSync } from 'fs';
import { relative, dirname, resolve, basename, extname } from 'path';
import { usage } from 'yargs';
import fastGlob from 'fast-glob';

/**
 * The most general version of compiler options.
 */
var defaultOptions = {
    noEmitOnError: false,
    allowJs: true,
    maxNodeModuleJsDepth: 3,
    experimentalDecorators: true,
    target: ScriptTarget.Latest,
    downlevelIteration: true,
    module: ModuleKind.ESNext,
    //module: ModuleKind.CommonJS,
    //lib: ["ESNext", "DOM", "DOM.Iterable"],
    strictNullChecks: true,
    moduleResolution: ModuleResolutionKind.NodeJs,
    esModuleInterop: true,
    noEmit: true,
    allowSyntheticDefaultImports: true,
    allowUnreachableCode: true,
    allowUnusedLabels: true,
    skipLibCheck: true
};
/**
 * Compiles an array of file paths using typescript.
 * @param filePaths
 * @param options
 */
function compileTypescript(filePaths, options) {
    if (options === void 0) { options = defaultOptions; }
    filePaths = Array.isArray(filePaths) ? filePaths : [filePaths];
    var program = createProgram(filePaths, options);
    var files = program
        .getSourceFiles()
        .filter(function (sf) { return filePaths.includes(sf.fileName); })
        .sort(function (sfA, sfB) { return (sfA.fileName > sfB.fileName ? 1 : -1); });
    return { program: program, files: files };
}

/**
 * Logs to the console with a specific level.
 * This function takes the config into account
 * @param text
 * @param config
 * @param level
 */
function log(text, config, level) {
    if (level === void 0) { level = "normal"; }
    // Never log if silent
    if (config.silent) {
        return;
    }
    // Never log verbose if verbose is not on
    if (level === "verbose" && !config.verbose) {
        return;
    }
    // "unpack" function
    if (typeof text === "function") {
        text = text();
    }
    // eslint-disable-next-line no-console
    if (typeof text === "object") {
        // eslint-disable-next-line no-console
        console.dir(text, { depth: 10 });
    }
    else {
        // eslint-disable-next-line no-console
        console.log(text);
    }
}
/**
 * Logs only if verbose is set to true in the config
 * @param text
 * @param config
 */
function logVerbose(text, config) {
    log(text, config, "verbose");
}

var IGNORE_GLOBS = ["**/node_modules/**", "**/web_modules/**"];
var DEFAULT_DIR_GLOB = "**/*.{js,jsx,ts,tsx}";
var DEFAULT_GLOBS = [DEFAULT_DIR_GLOB];
/**
 * Parses and analyses all globs and calls some callbacks while doing it.
 * @param globs
 * @param config
 * @param context
 */
function analyzeGlobs(globs, config, context) {
    var _a, _b, _c;
    if (context === void 0) { context = {}; }
    return __awaiter(this, void 0, void 0, function () {
        var filePaths, _d, program, files, results, _loop_1, files_1, files_1_1, file, e_1_1;
        var e_1, _e;
        return __generator(this, function (_f) {
            switch (_f.label) {
                case 0:
                    // Set default glob
                    if (globs.length === 0) {
                        globs = DEFAULT_GLOBS;
                    }
                    return [4 /*yield*/, expandGlobs(globs, config)];
                case 1:
                    filePaths = _f.sent();
                    logVerbose(function () { return filePaths; }, config);
                    // Callbacks
                    (_a = context.didExpandGlobs) === null || _a === void 0 ? void 0 : _a.call(context, filePaths);
                    (_b = context.willAnalyzeFiles) === null || _b === void 0 ? void 0 : _b.call(context, filePaths);
                    _d = compileTypescript(filePaths), program = _d.program, files = _d.files;
                    results = [];
                    _loop_1 = function (file) {
                        var result;
                        return __generator(this, function (_a) {
                            switch (_a.label) {
                                case 0:
                                    result = analyzeSourceFile(file, {
                                        program: program,
                                        verbose: config.verbose || false,
                                        ts: config.ts,
                                        config: {
                                            features: config.features,
                                            analyzeDependencies: config.analyzeDependencies,
                                            analyzeDefaultLib: config.analyzeDefaultLibrary,
                                            analyzeGlobalFeatures: config.analyzeGlobalFeatures,
                                            analyzeAllDeclarations: config.format == "json2" // TODO: find a better way to construct the config
                                        }
                                    });
                                    logVerbose(function () { return stripTypescriptValues(result, program.getTypeChecker()); }, config);
                                    // Callback
                                    return [4 /*yield*/, ((_c = context.emitAnalyzedFile) === null || _c === void 0 ? void 0 : _c.call(context, file, result, { program: program }))];
                                case 1:
                                    // Callback
                                    _a.sent();
                                    results.push(result);
                                    return [2 /*return*/];
                            }
                        });
                    };
                    _f.label = 2;
                case 2:
                    _f.trys.push([2, 7, 8, 9]);
                    files_1 = __values(files), files_1_1 = files_1.next();
                    _f.label = 3;
                case 3:
                    if (!!files_1_1.done) return [3 /*break*/, 6];
                    file = files_1_1.value;
                    return [5 /*yield**/, _loop_1(file)];
                case 4:
                    _f.sent();
                    _f.label = 5;
                case 5:
                    files_1_1 = files_1.next();
                    return [3 /*break*/, 3];
                case 6: return [3 /*break*/, 9];
                case 7:
                    e_1_1 = _f.sent();
                    e_1 = { error: e_1_1 };
                    return [3 /*break*/, 9];
                case 8:
                    try {
                        if (files_1_1 && !files_1_1.done && (_e = files_1.return)) _e.call(files_1);
                    }
                    finally { if (e_1) throw e_1.error; }
                    return [7 /*endfinally*/];
                case 9: return [2 /*return*/, { program: program, files: files, results: results }];
            }
        });
    });
}
/**
 * Expands the globs.
 * @param globs
 * @param config
 */
function expandGlobs(globs, config) {
    return __awaiter(this, void 0, void 0, function () {
        var ignoreGlobs, _a;
        return __generator(this, function (_b) {
            switch (_b.label) {
                case 0:
                    globs = Array.isArray(globs) ? globs : [globs];
                    ignoreGlobs = (config === null || config === void 0 ? void 0 : config.discoverNodeModules) ? [] : IGNORE_GLOBS;
                    _a = arrayFlat;
                    return [4 /*yield*/, Promise.all(globs.map(function (g) {
                            try {
                                // Test if the glob points to a directory.
                                // If so, return the result of a new glob that searches for files in the directory excluding node_modules..
                                var dirExists = existsSync(g) && lstatSync(g).isDirectory();
                                if (dirExists) {
                                    return fastGlob([fastGlobNormalize(g + "/" + DEFAULT_DIR_GLOB)], {
                                        ignore: ignoreGlobs,
                                        absolute: true,
                                        followSymbolicLinks: false
                                    });
                                }
                            }
                            catch (e) {
                                // the glob wasn't a directory
                            }
                            // Return the result of globbing
                            return fastGlob([fastGlobNormalize(g)], {
                                ignore: ignoreGlobs,
                                absolute: true,
                                followSymbolicLinks: false
                            });
                        }))];
                case 1: return [2 /*return*/, _a.apply(void 0, [_b.sent()])];
            }
        });
    });
}
/**
 * Fast glob recommends normalizing paths for windows, because fast glob expects a Unix-style path.
 * Read more here: https://github.com/mrmlnc/fast-glob#how-to-write-patterns-on-windows
 * @param glob
 */
function fastGlobNormalize(glob) {
    return glob.replace(/\\/g, "/");
}

var ERROR_NAME = "CLIError";
/**
 * Make an error of kind "CLIError"
 * Use this function instead of subclassing Error because of problems after transpilation.
 * @param message
 */
function makeCliError(message) {
    var error = new Error(message);
    error.name = ERROR_NAME;
    return error;
}
/**
 * Returns if an error is of kind "CLIError"
 * @param error
 */
function isCliError(error) {
    return error.name === ERROR_NAME;
}

function ensureDirSync(dir) {
    try {
        mkdirSync(dir, { recursive: true });
    }
    catch (err) {
        if (err.code !== "EEXIST")
            throw err;
    }
}

/**
 * Runs the analyze cli command.
 * @param config
 */
var analyzeCliCommand = function (config) { return __awaiter(void 0, void 0, void 0, function () {
    var inputGlobs, outStrategy, context, _a, results, program, filteredResults, outputResultMap, outputResultMap_1, outputResultMap_1_1, _b, outputPath, results_1, tagNames, content;
    var e_1, _c;
    var _d;
    return __generator(this, function (_e) {
        switch (_e.label) {
            case 0:
                inputGlobs = config.glob || [];
                // Log warning for experimental json format
                if (config.format === "json" || config.format === "json2" || ((_d = config.outFile) === null || _d === void 0 ? void 0 : _d.endsWith(".json"))) {
                    log("\n!!!!!!!!!!!!!  WARNING !!!!!!!!!!!!!\nThe custom-elements.json format is for experimental purposes. You can expect changes to this format.\nPlease follow and contribute to the discussion at:\t\t\n  - https://github.com/webcomponents/custom-elements-json\n  - https://github.com/w3c/webcomponents/issues/776\n!!!!!!!!!!!!!  WARNING !!!!!!!!!!!!!\n", config);
                }
                outStrategy = (function () {
                    if (config.outDir == null && config.outFile == null && config.outFiles == null) {
                        switch (config.format) {
                            case "json2":
                                // "json2" will need to output everything at once
                                return "console_bulk";
                            default:
                                return "console_stream";
                        }
                    }
                    return "file";
                })();
                context = {
                    didExpandGlobs: function (filePaths) {
                        if (filePaths.length === 0) {
                            throw makeCliError("Couldn't find any files to analyze.");
                        }
                    },
                    willAnalyzeFiles: function (filePaths) {
                        log("Web Component Analyzer analyzing " + filePaths.length + " file" + (filePaths.length === 1 ? "" : "s") + "...", config);
                    },
                    emitAnalyzedFile: function (file, result, _a) {
                        var program = _a.program;
                        // Emit the transformed results as soon as possible if "outConsole" is on
                        if (outStrategy === "console_stream") {
                            if (result.componentDefinitions.length > 0) {
                                // Always use "console.log" when outputting the results
                                /* eslint-disable-next-line no-console */
                                console.log(transformResults(result, program, __assign(__assign({}, config), { cwd: config.cwd || process.cwd() })));
                            }
                        }
                    }
                };
                return [4 /*yield*/, analyzeGlobs(inputGlobs, config, context)];
            case 1:
                _a = _e.sent(), results = _a.results, program = _a.program;
                filteredResults = results.filter(function (result) { var _a; return result.componentDefinitions.length > 0 || result.globalFeatures != null || (((_a = result.declarations) === null || _a === void 0 ? void 0 : _a.length) || 0) > 0; });
                if (!(outStrategy === "console_bulk")) return [3 /*break*/, 2];
                // Always use "console.log" when outputting the results
                /* eslint-disable-next-line no-console */
                console.log(transformResults(filteredResults, program, __assign(__assign({}, config), { cwd: config.cwd || process.cwd() })));
                return [3 /*break*/, 4];
            case 2:
                if (!(outStrategy === "file")) return [3 /*break*/, 4];
                return [4 /*yield*/, distributeResultsIntoFiles(filteredResults, config)];
            case 3:
                outputResultMap = _e.sent();
                try {
                    // Write all results to corresponding paths
                    for (outputResultMap_1 = __values(outputResultMap), outputResultMap_1_1 = outputResultMap_1.next(); !outputResultMap_1_1.done; outputResultMap_1_1 = outputResultMap_1.next()) {
                        _b = __read(outputResultMap_1_1.value, 2), outputPath = _b[0], results_1 = _b[1];
                        if (outputPath != null) {
                            if (config.dry) {
                                tagNames = arrayFlat(results_1.map(function (result) { return result.componentDefinitions.map(function (d) { return d.tagName; }); }));
                                log("[dry] Intending to write " + tagNames + " to ./" + relative(process.cwd(), outputPath), config);
                            }
                            else {
                                content = transformResults(results_1, program, __assign(__assign({}, config), { cwd: config.cwd || dirname(outputPath) }));
                                ensureDirSync(dirname(outputPath));
                                writeFileSync(outputPath, content);
                            }
                        }
                    }
                }
                catch (e_1_1) { e_1 = { error: e_1_1 }; }
                finally {
                    try {
                        if (outputResultMap_1_1 && !outputResultMap_1_1.done && (_c = outputResultMap_1.return)) _c.call(outputResultMap_1);
                    }
                    finally { if (e_1) throw e_1.error; }
                }
                _e.label = 4;
            case 4: return [2 /*return*/];
        }
    });
}); };
/**
 * Transforms analyze results based on the wca cli config.
 * @param results
 * @param program
 * @param config
 */
function transformResults(results, program, config) {
    var _a, _b;
    results = Array.isArray(results) ? results : [results];
    // Default format is "markdown"
    var format = config.format || "markdown";
    var transformerConfig = {
        inlineTypes: (_a = config.inlineTypes) !== null && _a !== void 0 ? _a : false,
        visibility: (_b = config.visibility) !== null && _b !== void 0 ? _b : "public",
        markdown: config.markdown,
        cwd: config.cwd
    };
    return transformAnalyzerResult(format, results, program, transformerConfig);
}
/**
 * Analyzes input globs and returns the transformed result.
 * @param inputGlobs
 * @param config
 */
function analyzeAndTransformGlobs(inputGlobs, config) {
    return __awaiter(this, void 0, void 0, function () {
        var _a, results, program;
        return __generator(this, function (_b) {
            switch (_b.label) {
                case 0: return [4 /*yield*/, analyzeGlobs(Array.isArray(inputGlobs) ? inputGlobs : [inputGlobs], config)];
                case 1:
                    _a = _b.sent(), results = _a.results, program = _a.program;
                    return [2 /*return*/, transformResults(results, program, config)];
            }
        });
    });
}
/**
 * Distribute results into files and return a map of "path => results"
 * @param results
 * @param config
 */
function distributeResultsIntoFiles(results, config) {
    return __awaiter(this, void 0, void 0, function () {
        var outputPathToResultMap, addToOutputPath, extName, results_2, results_2_1, result, definition, path, path, results_3, results_3_1, result, results_4, results_4_1, result, dir, filename, _a, _b, definition, path;
        var e_2, _c, e_3, _d, e_4, _e, e_5, _f;
        return __generator(this, function (_g) {
            outputPathToResultMap = new Map();
            addToOutputPath = function (path, result) {
                var existing = outputPathToResultMap.get(path) || [];
                existing.push(result);
                outputPathToResultMap.set(path, existing);
            };
            // Output files into directory
            if (config.outDir != null) {
                extName = formatToExtension(config.format || "markdown");
                try {
                    for (results_2 = __values(results), results_2_1 = results_2.next(); !results_2_1.done; results_2_1 = results_2.next()) {
                        result = results_2_1.value;
                        definition = result.componentDefinitions[0];
                        if (definition == null)
                            continue;
                        path = resolve(process.cwd(), config.outDir, "" + definition.tagName + extName);
                        addToOutputPath(path, result);
                    }
                }
                catch (e_2_1) { e_2 = { error: e_2_1 }; }
                finally {
                    try {
                        if (results_2_1 && !results_2_1.done && (_c = results_2.return)) _c.call(results_2);
                    }
                    finally { if (e_2) throw e_2.error; }
                }
            }
            // Output all results into a single file
            else if (config.outFile != null) {
                // Guess format based on outFile extension
                // eslint-disable-next-line require-atomic-updates
                config.format = config.format || extensionToFormat(config.outFile);
                path = resolve(process.cwd(), config.outFile);
                try {
                    for (results_3 = __values(results), results_3_1 = results_3.next(); !results_3_1.done; results_3_1 = results_3.next()) {
                        result = results_3_1.value;
                        addToOutputPath(path, result);
                    }
                }
                catch (e_3_1) { e_3 = { error: e_3_1 }; }
                finally {
                    try {
                        if (results_3_1 && !results_3_1.done && (_d = results_3.return)) _d.call(results_3);
                    }
                    finally { if (e_3) throw e_3.error; }
                }
            }
            // Output all results into multiple files
            else if (config.outFiles != null) {
                // Guess format based on outFile extension
                // eslint-disable-next-line require-atomic-updates
                config.format = config.format || extensionToFormat(config.outFiles);
                try {
                    for (results_4 = __values(results), results_4_1 = results_4.next(); !results_4_1.done; results_4_1 = results_4.next()) {
                        result = results_4_1.value;
                        dir = relative(process.cwd(), dirname(result.sourceFile.fileName));
                        filename = relative(process.cwd(), basename(result.sourceFile.fileName, extname(result.sourceFile.fileName)));
                        try {
                            for (_a = (e_5 = void 0, __values(result.componentDefinitions)), _b = _a.next(); !_b.done; _b = _a.next()) {
                                definition = _b.value;
                                path = resolve(process.cwd(), config
                                    .outFiles.replace(/{dir}/g, dir)
                                    .replace(/{filename}/g, filename)
                                    .replace(/{tagname}/g, definition.tagName));
                                //const path = resolve(process.cwd(), config.outFiles!, definition.tagName);
                                addToOutputPath(path, {
                                    sourceFile: result.sourceFile,
                                    componentDefinitions: [definition]
                                });
                            }
                        }
                        catch (e_5_1) { e_5 = { error: e_5_1 }; }
                        finally {
                            try {
                                if (_b && !_b.done && (_f = _a.return)) _f.call(_a);
                            }
                            finally { if (e_5) throw e_5.error; }
                        }
                    }
                }
                catch (e_4_1) { e_4 = { error: e_4_1 }; }
                finally {
                    try {
                        if (results_4_1 && !results_4_1.done && (_e = results_4.return)) _e.call(results_4);
                    }
                    finally { if (e_4) throw e_4.error; }
                }
            }
            // Not "out" was specified. Add results to the special key "null"
            else {
                outputPathToResultMap.set(null, results);
            }
            return [2 /*return*/, outputPathToResultMap];
        });
    });
}
/**
 * Returns an extension based on a format
 * @param kind
 */
function formatToExtension(kind) {
    switch (kind) {
        case "json":
        case "vscode":
            return ".json";
        case "md":
        case "markdown":
            return ".md";
        default:
            return ".txt";
    }
}
/**
 * Returns a format based on an extension
 * @param path
 */
function extensionToFormat(path) {
    var extName = extname(path);
    switch (extName) {
        case ".json":
            return "json";
        case ".md":
            return "markdown";
        default:
            return "markdown";
    }
}

/**
 * The main function of the cli.
 */
function cli() {
    var _this = this;
    var argv = usage("Usage: $0 <command> [glob..] [options]")
        .command({
        command: ["analyze [glob..]", "$0"],
        describe: "Analyses components and emits results in a specified format.",
        handler: function (config) { return __awaiter(_this, void 0, void 0, function () {
            var e_1;
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        _a.trys.push([0, 2, , 3]);
                        return [4 /*yield*/, analyzeCliCommand(config)];
                    case 1:
                        _a.sent();
                        return [3 /*break*/, 3];
                    case 2:
                        e_1 = _a.sent();
                        if (isCliError(e_1)) {
                            log(e_1.message, config);
                        }
                        else {
                            throw e_1;
                        }
                        return [3 /*break*/, 3];
                    case 3: return [2 /*return*/];
                }
            });
        }); }
    })
        .example("$ $0 analyze", "")
        .example("$ $0 analyze src --format markdown", "")
        .example("$ $0 analyze \"src/**/*.{js,ts}\" --outDir output", "")
        .example("$ $0 analyze my-element.js --outFile custom-elements.json", "")
        .example("$ $0 analyze --outFiles {dir}/custom-element.json", "")
        .option("outDir", {
        describe: "Output to a directory where each file corresponds to a web component",
        nargs: 1,
        string: true
    })
        .option("outFile", {
        describe: "Concatenate and emit output to a single file",
        nargs: 1,
        string: true
    })
        .option("outFiles", {
        describe: "Emit output to multiple files using a pattern. Available substitutions:\no {dir}: The directory of the component\no {filename}: The filename (without ext) of the component\no {tagname}: The element's tag name",
        nargs: 1,
        string: true
    })
        .option("format", {
        describe: "Specify output format",
        choices: ["md", "markdown", "json", "json2", "vscode"],
        nargs: 1,
        alias: "f"
    })
        .option("features", {
        describe: "Features to enable",
        array: true,
        choices: ["member", "method", "cssproperty", "csspart", "event", "slot"]
    })
        .option("analyzeDefaultLibrary", {
        boolean: true,
        hidden: true
    })
        .option("analyzeDependencies", {
        boolean: true,
        hidden: true
    })
        .option("discoverNodeModules", {
        boolean: true,
        hidden: true
    })
        .option("visibility", {
        describe: "Minimum visibility",
        choices: ["private", "protected", "public"]
    })
        .option("inlineTypes", {
        describe: "Inline type aliases",
        boolean: true
    })
        .option("dry", {
        describe: "Don't write files",
        boolean: true,
        alias: "d"
    })
        .option("verbose", {
        boolean: true,
        hidden: true
    })
        .option("silent", {
        boolean: true,
        hidden: true
    })
        // This options makes it possible to use "markdown.<sub-option>" in "strict mode"
        .option("markdown", {
        hidden: true
    })
        // This option makes it possible to specify a base cwd to use when emitting paths
        .option("cwd", {
        string: true,
        hidden: true
    })
        .alias("v", "version")
        .help("h")
        .wrap(110)
        .strict()
        .alias("h", "help").argv;
    if (argv.verbose) {
        /* eslint-disable-next-line no-console */
        console.log("CLI options:", argv);
    }
}

export { analyzeAndTransformGlobs, analyzeCliCommand, cli };
