import { _ as __assign, a as arrayDefined, b as analyzeSourceFile, m as makeContextFromConfig, C as CustomElementFlavor, A as ALL_COMPONENT_FEATURES, D as DEFAULT_FEATURE_COLLECTION_CACHE, c as DEFAULT_COMPONENT_DECLARATION_CACHE, d as analyzeComponentDeclaration } from './chunk-transform-analyzer-result-f9714512.js';
export { A as ALL_COMPONENT_FEATURES, J as JsDocFlavor, V as VERSION, b as analyzeSourceFile, f as getExtendsHeritageClauses, i as getExtendsHeritageClausesInChain, j as getJsDoc, k as getJsDocType, e as getMixinHeritageClauses, h as getMixinHeritageClausesInChain, g as getSuperclassHeritageClause, p as parseSimpleJsDocTypeExpression, t as transformAnalyzerResult, v as visitAllHeritageClauses } from './chunk-transform-analyzer-result-f9714512.js';
import * as tsModule from 'typescript';
import { ScriptKind } from 'typescript';
import 'ts-simple-type';
import { existsSync, readFileSync } from 'fs';
import { join, dirname } from 'path';

/**
 * Analyzes components in code
 * @param {IVirtualSourceFile[]|VirtualSourceFile} inputFiles
 * @param config
 */
function analyzeText(inputFiles, config) {
    if (config === void 0) { config = {}; }
    var ts = config.ts || tsModule;
    // "sys" can be undefined when running in the browser
    var system = ts.sys;
    // Convert arguments into virtual source files
    var files = (Array.isArray(inputFiles) ? inputFiles : [inputFiles])
        .map(function (file) {
        return typeof file === "string"
            ? {
                text: file,
                fileName: "auto-generated-" + Math.floor(Math.random() * 100000) + ".ts",
                entry: true
            }
            : file;
    })
        .map(function (file) { return (__assign(__assign({}, file), { fileName: file.fileName })); });
    var includeLib = files.some(function (file) { return file.includeLib; });
    var readFile = function (fileName) {
        var matchedFile = files.find(function (currentFile) { return currentFile.fileName === fileName; });
        if (matchedFile != null) {
            return matchedFile.text;
        }
        if (includeLib) {
            // TODO: find better method of finding the current typescript module path
            fileName = fileName.match(/[/\\]/) ? fileName : join(dirname(require.resolve("typescript")), fileName);
        }
        if (existsSync(fileName)) {
            return readFileSync(fileName, "utf8").toString();
        }
        return undefined;
    };
    var fileExists = function (fileName) {
        return files.some(function (currentFile) { return currentFile.fileName === fileName; });
    };
    var compilerOptions = {
        module: ts.ModuleKind.ESNext,
        target: ts.ScriptTarget.ESNext,
        allowJs: true,
        sourceMap: false,
        strictNullChecks: true
    };
    var program = ts.createProgram({
        rootNames: files.map(function (file) { return file.fileName; }),
        options: compilerOptions,
        host: {
            writeFile: function () { },
            readFile: readFile,
            fileExists: fileExists,
            getSourceFile: function (fileName, languageVersion) {
                var sourceText = this.readFile(fileName);
                if (sourceText == null)
                    return undefined;
                return ts.createSourceFile(fileName, sourceText, languageVersion, true, fileName.endsWith(".js") ? ScriptKind.JS : ScriptKind.TS);
            },
            getCurrentDirectory: function () {
                return ".";
            },
            getDirectories: function (directoryName) {
                var _a;
                return (_a = system === null || system === void 0 ? void 0 : system.getDirectories(directoryName)) !== null && _a !== void 0 ? _a : [];
            },
            getDefaultLibFileName: function (options) {
                return ts.getDefaultLibFileName(options);
            },
            getCanonicalFileName: function (fileName) {
                return this.useCaseSensitiveFileNames() ? fileName : fileName.toLowerCase();
            },
            getNewLine: function () {
                var _a;
                return (_a = system === null || system === void 0 ? void 0 : system.newLine) !== null && _a !== void 0 ? _a : "\n";
            },
            useCaseSensitiveFileNames: function () {
                var _a;
                return (_a = system === null || system === void 0 ? void 0 : system.useCaseSensitiveFileNames) !== null && _a !== void 0 ? _a : false;
            }
        }
    });
    var checker = program.getTypeChecker();
    // Analyze source files
    var sourceFilesToAnalyze = arrayDefined(files.filter(function (file) { return file.analyze !== false; }).map(function (file) { return program.getSourceFile(file.fileName); }));
    var results = sourceFilesToAnalyze.map(function (sf) { return analyzeSourceFile(sf, __assign({ program: program }, config)); });
    return { checker: checker, program: program, results: results, analyzedSourceFiles: sourceFilesToAnalyze };
}

/**
 * This function only analyzes the HTMLElement declaration found in "lib.dom.d.ts" source file provided by Typescript.
 * @param program
 * @param ts
 */
function analyzeHTMLElement(program, ts) {
    if (ts === void 0) { ts = tsModule; }
    var endsWithLibDom = "lib.dom.d.ts";
    var domLibSourceFile = program.getSourceFiles().find(function (sf) { return sf.fileName.endsWith(endsWithLibDom); });
    if (domLibSourceFile == null) {
        return undefined;
        //throw new Error(`Couldn't find '${endsWith}'. Have you included the 'dom' lib in your tsconfig?`);
    }
    return visit(domLibSourceFile, __assign(__assign({}, makeContextFromConfig({
        program: program,
        ts: ts,
        flavors: [new CustomElementFlavor()],
        config: {
            analyzeDefaultLib: true,
            features: ALL_COMPONENT_FEATURES
        }
    })), { cache: {
            featureCollection: DEFAULT_FEATURE_COLLECTION_CACHE,
            componentDeclarationCache: DEFAULT_COMPONENT_DECLARATION_CACHE,
            general: new Map()
        } }));
}
function visit(node, context) {
    if (context.ts.isInterfaceDeclaration(node) && node.name != null && node.name.text === "HTMLElement") {
        return analyzeComponentDeclaration([node], context);
    }
    return node.forEachChild(function (child) {
        return visit(child, context);
    });
}

export { analyzeHTMLElement, analyzeText };
